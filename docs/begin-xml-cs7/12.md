# 12.XML in。NET 框架

到目前为止，您已经学会了如何处理自己的 XML 数据。这包括读取、写入、验证、序列化和查询 XML 数据。微软已经在。NET 框架。XML 的这种使用有不同的风格，比如 note 的 XAML 标记，ASP.NET 的服务器控件标记，以及。NET 框架。理解 XML 在。因此，NET Framework 对于任何。NET 开发者。本章将向您介绍其中的许多功能。具体来说，您将了解以下主题:

*   使用 XAML 定义 WPF 用户界面
*   使用 ASP.NET 服务器控件定义 web 用户界面
*   了解 ASP.NET 服务器控件，如 XML、XML 数据源、TreeView、菜单和站点地图
*   使用的配置系统。NET 框架
*   理解 XML 文档

请注意，虽然这一章涵盖了广泛的主题，但绝不是对这些主题的详尽论述。这里的重点是简要地指出 XML 在。NET 框架。

## 使用 XAML 定义 WPF 用户界面

在本书中，您一直在开发 Windows 窗体应用程序。如您所知，Windows 窗体是包含显示窗体和事件处理程序所需的所有代码的类。因此，两个关注点——用户界面和功能(事件处理程序)——混合在一起。一个更好的编程方法是将这两个问题分离到它们自己的单元中。

Windows 演示基础(WPF)应用程序就是这样做的。WPF 使用一种称为 XAML(可扩展应用程序标记语言)的特殊 XML 词汇来定义用户界面。XAML 标记通常位于扩展名为`.xaml`的文件中。负责应用程序功能的代码(运行时逻辑，如事件处理程序和方法)包含在 C#类中。当您设计 Windows 窗体应用程序的用户界面时，用户界面被转换为 C#代码。WPF 应用程序的情况并非如此。当您在 Visual Studio 中设计 WPF 用户界面时，用户界面被翻译成 XAML 标记(而不是 C#代码)。

XAML 标记是 XML 标记，因此遵循 XML 语法的所有规则。您可以在任何 XML/文本编辑器中创建和编辑 XAML 标记，但是 Visual Studio 提供了丰富的编辑器来处理它。

为了理解 XAML 标记的外观，您将创建一个如图 [12-1](#Fig1) 所示的 WPF 应用程序。

![A160895_2_En_12_Fig1_HTML.jpg](../Images/A160895_2_En_12_Fig1_HTML.jpg)

图 12-1。

A WPF application fo r managing Employees.xml

这个应用程序对你来说应该很熟悉，因为你在第 [2 章](02.html)中开发了一个类似的 Windows 窗体应用程序。就应用程序的功能而言，完全相同——从`Employees.xml`文件中添加、更新和删除雇员。为了节省篇幅，我们不再讨论功能。我们在这里的主要兴趣是 XAML 加价。您可以从本书的源代码下载中获得该应用程序的完整源代码。

要开发这个应用程序，使用 Visual Studio 创建一个新的 WP F 应用程序项目(参见图 [12-2](#Fig2) )。

![A160895_2_En_12_Fig2_HTML.jpg](../Images/A160895_2_En_12_Fig2_HTML.jpg)

图 12-2。

Creating a new WPF application project

一旦项目被创建，你会注意到其中有两个`.xaml`文件，分别叫做`App.xaml`和`MainWindow.xaml`。我们感兴趣的是`MainWindow.xaml`文件，因为它定义了我们应用程序的用户界面。您可以使用“添加新项目”对话框添加 WPF 窗口。

您可以在 Visual Studio Designer 中打开`MainWindow.xaml`文件(见图 [12-3](#Fig3) )并以两种方式进行编辑:

*   将 WPF 控件从工具箱拖放到设计图面上，并设置它们的属性。这样做将为您生成某些 XAML 标记。
*   手动编辑`.xaml`文件，并将标记(主要由某些元素及其属性组成)直接添加到其中。设计图面也将反映相关的更改。

准备编辑的`MainWindow.xaml`文件如图 [12-3](#Fig3) 所示。图 [12-4](#Fig4) 显示了带有 WPF 控件的工具箱。

![A160895_2_En_12_Fig4_HTML.jpg](../Images/A160895_2_En_12_Fig4_HTML.jpg)

图 12-4。

Toolbox showing WPF controls

![A160895_2_En_12_Fig3_HTML.jpg](../Images/A160895_2_En_12_Fig3_HTML.jpg)

图 12-3。

MainWindow.xaml in th e Visual Studio Designer

你可以试着和设计师一起玩，只是为了熟悉一下。并尝试设计应用程序的用户界面，如前面所示。我们不会在这里深入 UI 设计过程的细节。负责用户界面的 XAML 标记如清单 [12-1](#Par20) 所示(为了节省空间，清单中省略了一些标记)。

```
<Window x:Class="WpfAndXaml.MainWindow"

        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfAndXaml"
        mc:Ignorable="d"
        Title="Window1" Height="400.2" Width="433.431" Loaded="Window_Loaded">
....
        <Grid HorizontalAlignment="Center" Height="367" VerticalAlignment="Center" Width="396" Margin="10,10,9,10">
            <Label Content="Employee ID :" HorizontalAlignment="Left" Margin="13,22,0,0" VerticalAlignment="Top" RenderTransformOrigin="-0.575,0.017"/>
            <Label Content="First Name :" HorizontalAlignment="Left" Margin="23,53,0,0" VerticalAlignment="Top" RenderTransformOrigin="-0.575,0.017"/>
            <Label Content="Last Name :" HorizontalAlignment="Left" Margin="24,84,0,0" VerticalAlignment="Top" RenderTransformOrigin="-0.575,0.017"/>
            <Label Content="Home Phone :" HorizontalAlignment="Left" Margin="11,115,0,0" VerticalAlignment="Top" RenderTransformOrigin="-0.575,0.017"/>

            <Label Content="Notes :" HorizontalAlignment="Left" Margin="49,146,0,0" VerticalAlignment="Top" RenderTransformOrigin="-0.575,0.017"/>
            <ComboBox x:Name="comboBox1" HorizontalAlignment="Left" Margin="106,26,0,0" VerticalAlignment="Top" Width="143"/>
            <TextBox x:Name="textBox1" HorizontalAlignment="Left" Height="23" Margin="106,57,0,0" TextWrapping="Wrap" Text="TextBox" VerticalAlignment="Top" Width="219" RenderTransformOrigin="0.439,-0.159"/>
            <TextBox x:Name="textBox2" HorizontalAlignment="Left" Height="23" TextWrapping="Wrap" Text="TextBox" VerticalAlignment="Top" Width="219" Margin="106,88,0,0"/>
            <TextBox x:Name="textBox3" HorizontalAlignment="Left" Height="23" TextWrapping="Wrap" Text="TextBox" VerticalAlignment="Top" Width="143" Margin="106,119,0,0"/>
            <TextBox x:Name="textBox4" HorizontalAlignment="Left" Height="88" TextWrapping="Wrap" Text="TextBox" VerticalAlignment="Top" Width="219" Margin="106,150,0,0"/>
            <Button x:Name="button1" Content="Add" HorizontalAlignment="Left" VerticalAlignment="Top" Width="75" Margin="49,262,0,0" Click="button1_Click" Height="24"/>
            <Button x:Name="button2" Content="Update" HorizontalAlignment="Left" VerticalAlignment="Top" Width="75" Margin="163,262,0,0" Click="button2_Click" Height="24"/>
            <Button x:Name="button3" Content="Delete" HorizontalAlignment="Left" VerticalAlignment="Top" Width="75" Margin="279,262,0,0" Click="button3_Click" Height="24"/>
.... 

....
        </Grid>
    </Grid>
</Window>
Listing 12-1.XAML Markup Responsible for the User Interface

```

虽然我们不打算从 WPF 的角度理解标记，但让我们从 XML 的角度快速检查一下。

该标记有一个根元素`Window`,表示它是一个窗口。WPF 应用程序使用某些名称空间。其中两个是值得了解的，因为你会发现他们在每一个 WPF XAML 文件:

*   [`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation) 是 WPF 的主要命名空间。它包含所有的 WPF 类，包括用户界面上使用的控件。如您所见，它是整个 XAML 文档的默认名称空间。
*   [`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml) 是 XAML 的命名空间。它的名称空间前缀是`x`。它包括所有应用程序所需的各种 XAML 功能。

`x:` `Class`属性指定一个名为`MainWindow`的 C#类将包含诸如事件处理程序之类的代码。`MainWindow`类继承自窗口类(由`<Window>`元素表示)。这个类通常被称为代码隐藏类。

`<Grid>`部分作为窗口中 WPF 控件容器的布局方案。在内部，有标记元素，如`<ComboBox>`、`<Label>`、`<TextBox>`和`<Button>`，它们代表各自的用户界面元素。每个元素都有自己的属性集(比如`Content`、`Text`、`HorizontalAlignment`、`VerticalAlignment`和`Margin`)。

这些元素实际上映射到 WPF 框架定义的某些类，通常被称为支持类型。例如，`<Button>`元素映射到`System.Windows.Controls.Button`类。`<Button>`元素的`Margin`和`FontSize`属性分别对应于`Button`类的`Margin`和`FontSize`属性。

目前为止一切顺利。现在，让我们看看如何向按钮添加事件处理程序。双击任一按钮控件，打开该按钮的`MainWindow`类(`MainWindow.xaml.cs`文件)和`Click`事件处理程序。`button1` (Add)的`Click`事件处理程序如清单 [12-2](#Par29) 所示。

```
public partial class MainWindow : Window
{

    public MainWindow()
    {
        InitializeComponent();
    }

    private void button1_Click(object sender, RoutedEventArgs e)
    {
      //your code here
    }

Listing 12-2.Click Event Handler of the Button Control

```

`button1_Click()`方法代表按钮的`Click`事件处理程序。生成这个空事件处理程序后，再次查看 XAML 标记。

```
<Button x:Name="button1"
Content="Add"
HorizontalAlignment="Left"
VerticalAlignment="Top"
Width="75"
Margin="49,262,0,0"

Click="button1_Click"

Height="24"/>

```

如您所见，`Click`属性已经被添加到指向`Click`事件处理程序的`<Button>`元素中。

如上所述，我们不会讨论负责运行该应用程序的代码，因为它与您在第 [2](02.html) 章中开发的示例非常相似。您可以从该书的源代码下载中获得完整的源代码。您甚至可以将事件处理程序代码复制并粘贴到您的项目中，以使应用程序按预期工作。

编译应用程序时，XAML 标记被转换为 CLR 类型，并与代码隐藏类(请注意，代码隐藏类是一个分部类)合并，形成一个代码单元。您现在可以运行应用程序，看看它是否如预期的那样工作。

## 在 WPF 应用程序中显示 XML 数据

在上一节中，您了解了 WPF 使用 XAML 来定义其用户界面元素。然而，更有趣的是，看看 XML 数据如何在 WPF 应用程序中显示。为了了解如何做到这一点，您构建了另一个 WPF 应用程序，如图 [12-5](#Fig5) 所示。

![A160895_2_En_12_Fig5_HTML.jpg](../Images/A160895_2_En_12_Fig5_HTML.jpg)

图 12-5。

Employee XML data displayed in a grid

该应用程序的用户界面由一个显示来自`Employees.xml`文件的 XML 数据的数据网格组成。`DataGrid`有五列，分别显示`EmployeeID`、`FirstName`、`LastName`、`HomePhone`和`Notes`。

要开发这个应用程序，像以前一样创建一个新的 WPF 项目，并在其上拖放一个网格控件。然后为网格配置一个资源(不要与 DataGrid 混淆)，如清单 [12-3](#Par38) 所示。

```
<Grid.Resources>
  <XmlDataProvider x:Key="EmployeeData"
   Source="Employees.xml"
   XPath="/employees/employee"/>
</Grid.Resources>
Listing 12-3.Configuring XmlDataProvider

```

资源是您希望在应用程序中经常使用的对象。在这里，您将`XmlDataProvider`配置为一个资源。一个`XmlDataProvider`对象可以指向一个 XML 文件或者包含内嵌的 XML 数据。在我们的例子中，雇员数据存储在`Employees.xml`文件中，因此`XmlDataProvider`的`Source`属性被设置为`Employees.xml`。这个键指定了一个名称，通过这个名称可以识别一个资源，在这个例子中是`EmployeeData`。`XPath`属性指定了一个 XPath 查询，为我们提供所需的数据。在这种情况下，我们希望用来自`<employee>`节点的数据填充网格行。因此，XPath 查询被设置为`/employees/employee`。

从工具箱中拖放一个 DataGrid 控件，并更改它的 XAML(您可以使用设计器的 XAML 编辑器窗格来完成)，类似于清单 [12-4](#Par41) 。

```
<DataGrid x:Name="grid1" DataContext="{StaticResource EmployeeData}"  
 ItemsSource="{Binding XPath=/employees/employee}"
 AutoGenerateColumns="False" HorizontalAlignment="Stretch"
 VerticalAlignment="Stretch">
<DataGrid.Columns>
  <DataGridTextColumn Header="EmployeeID"
   Binding="{Binding XPath=@employeeid}" />
  <DataGridTextColumn Header="FirstName"
   Binding="{Binding XPath=firstname}" />
  <DataGridTextColumn Header="LastName"
   Binding="{Binding XPath=lastname}" />
  <DataGridTextColumn Header="HomePhone"
   Binding="{Binding XPath=homephone}" />
  <DataGridTextColumn Header="Notes"
   Binding="{Binding XPath=notes}"  />
</DataGrid.Columns>
</DataGrid>
Listing 12-4.DataGrid Columns Are Bound to XML Data

```

DataGri d 的`DataContext`属性设置为`XmlDataProvider`(静态资源只是指在加载时而不是运行时解析所考虑的资源)。

还要注意，数据网格有五列，由`DataGridTextColumn`元素定义。EmployeeID 列绑定到`<employee>`元素的`employeeid`属性，因此其绑定属性被配置为使用 XPath 查询`@employeeid`。类似地，其他四列是绑定到`firstname`、`lastname`、`homephone`和`notes`元素的数据。

Note

如果你以前没有使用过 WPF，WPF 使用的数据绑定语法可能看起来有点奇怪。尽管我们不会在本书中深入讨论这种语法的细节，但是您可以阅读 MSDN 文档来了解更多。

一旦 XAML 标记就绪，运行应用程序，查看数据网格中是否填充了雇员数据。

## 在 ASP.NET 使用 XML

ASP.NET 是一个用于构建动态和数据驱动的 web 应用程序的框架。在 ASP.NET，网页被称为网络表单。Web 表单使用`.aspx`扩展名，包含 HTML 标记、服务器控件标记和可选的代码。每个 Web 表单都是一个直接或间接继承自`System.Web.UI.Page`基类的类。

Note

您的 ASP.NET 应用程序可能使用 Web 表单或 MVC。你也可以使用新的 framework—ASP.NET 核心来构建网络应用。以下部分中讨论的讨论和示例使用 ASP.NET Web 窗体。我的目的只是向您展示 ASP.NET 如何在几个地方使用 XML 和基于 XML 的语法。所以，当我说 ASP.NET 时，我指的是 ASP.NET 网络表单。

服务器控件是传统 HTML 元素上面向对象的包装。它们在服务器端由 ASP.NET 处理，这就是它们被称为服务器控件的原因。与传统的 HTML 控件相比，它们提供了许多优势，包括丰富的功能、数据绑定、面向对象的特性等等。ASP.NET 网站是 web 表单和相关资源(如图像、JavaScript 文件和编译后的组件)的集合。

### XML 和 ASP.NET

ASP.NET 在几个地方使用 XML。广泛使用 XML 的一些主要领域如下:

*   服务器控件标记
*   XML 数据源控件
*   导航控件，如树形视图、菜单和站点地图
*   XML 控件
*   网站配置

您将在接下来的章节中了解所有这些特性。

#### 服务器控件标记

如前所述，ASP.NET Web 窗体主要由 HTML 和服务器控件标记组成。服务器控件标记实际上是一种特殊的 XML 词汇表。每个服务器控件都有预定义的标记名、标记前缀和属性。一些服务器控件是空元素(它们不包含任何子元素)，而另一些可以包含标记或文本。

为了更好地理解服务器控件，您将使用 web 窗体开发一个 ASP.NET 网站。Web 表单代表了一个典型的“联系我们”页面。最终用户将使用该页面与您联系，询问有关您网站的任何问题、反馈或意见。

##### 创建网站

若要使用 Visual Studio 创建新网站，您需要选择“文件”“➤新➤网站”菜单选项。该选项打开如图 [12-6](#Fig6) 所示的新建网站对话框。

![A160895_2_En_12_Fig6_HTML.jpg](../Images/A160895_2_En_12_Fig6_HTML.jpg)

图 12-6。

Creating a new web site

ASP.NET Web 窗体网站模板允许您创建网站。“网站位置”下拉列表指示将创建网站的目标位置。可能的位置是文件系统、web 服务器(HTTP)和 FTP 文件夹(FTP)。在我们的示例中，我们将选择文件系统。在位置下拉列表后指定的路径是将在其中创建网站的目标文件夹。确保选择 Visual C#作为语言。单击“确定”按钮创建网站。Visual Studio 将创建一个具有特定文件夹结构的网站，并且还会有一个名为`Default.aspx`的 web 表单。

Note

在我们的大多数例子中，我们不需要由默认项目模板创建的各种项目。您可以简单地将它们从项目中删除以减少混乱。您也可以使用 ASP.NET 空网站项目模板创建一个空项目，并根据需要添加项目。

##### 设计 Web 表单

下一个任务是设计“联系我们”Web 表单。为此，请切换到“设计”视图，从菜单中选择“表格”“➤”“插入表格”,并在默认的 Web 窗体中插入一个 11 行 2 列的表格。现在，您需要拖放各种控件，并将它们排列在该表的单元格中，具体步骤如下。图 [12-7](#Fig7) 为设计完成后的`Default.aspx`图。

![A160895_2_En_12_Fig7_HTML.jpg](../Images/A160895_2_En_12_Fig7_HTML.jpg)

图 12-7。

Designing a Web Form

Web 窗体由许多服务器控件组成，如 Label、TextBox、DropDownList、RadioButtonList、Button、RequiredFieldValidator、RegularExpressionValidator 和 ValidationSummary。要开始设计 Web 表单，请使用下列步骤:

1.  将标签控件拖放到表格的第一行。将其文本属性设置为联系我们。根据您的选择设置它的字体属性。另外，在“联系我们”标签下拖放一个水平标尺 HTML 控件。
2.  在第二行中拖放一个 ValidationSummary 控件。ValidationSummary 控件位于工具箱的“验证”节点中，用于显示当前 Web 表单中验证错误的综合列表。
3.  拖放第 3 行到第 9 行中的七个标签控件。将他们的文本属性分别设置为您的姓名:，您的电子邮件:，联系人:，主题:，邮件:，网站(可选) :，以及您代表:。
4.  将 TextBox 控件分别拖放到您的姓名、电子邮件、主题、消息和网站(可选)标签之后。将消息文本框的 TextMode 属性设置为 MultiLine。
5.  将 DropDownList 控件拖放到 Contacting For 标签之后。
6.  将单选按钮列表拖放到您代表标签之后。
7.  将 Button 控件拖放到第 10 行，并将其 Text 属性设置为 Submit。
8.  将一个 Label 控件拖放到第 11 行，并将其 Text 属性设置为空字符串。该标签将用于向用户显示成功消息。
9.  选择下拉列表控件。打开其属性窗口，找到 Items 属性。在下拉列表中添加四项:请选择、销售报价、技术问题和其他。
10.  选择 RadioButtonList 控件。打开其属性窗口，找到 Items 属性。在 RadioButtonList 中添加两项:个人和公司。
11.  将 RequiredFieldValidator 控件拖放到接受姓名、电子邮件、联系原因、主题和消息的控件前面。RequiredFieldValidator 控件用于验证它所附加的控件是否包含某个值。将所有 RequiredFieldValidator 控件的 ControlToValidate 属性设置为相应文本框或 DropDownList 的 ID 属性。
12.  将附加到 Contacting For 下拉列表的 RequiredFieldValidator 的 InitialValue 属性设置为 Please Select。这样，用户将需要选择“请选择”以外的选项。
13.  将 RegularExpressionValidator 控件拖放到接受电子邮件和网站的控件前面。RegularExpressionValidator 控件验证特定模式的输入值。该模式通过使用正则表达式语法来设置。将两个 RegularExpressionValidator 控件的 ControlToValidate 属性设置为各自文本框的 ID 属性。将第一个 RegularExpressionValidator 控件的 ValidationExpression 属性设置为 Internet 电子邮件地址。同样，将第二个 RegularExpressionValidator 控件的 ValidationExpression 属性设置为 Internet URL。
14.  将所有验证控件(RequiredFieldValidator 和 Regular-ExpressionValidator)的 Text 属性设置为*。每当出现验证错误时，将显示此文本来代替验证控件。此外，将所有验证控件的 ErrorMessage 属性设置为一些有意义的错误信息。如果发生任何验证错误，将在 ValidationSummary 控件中显示 ErrorMessage。

我们的 Web 表单设计现在已经结束了。在 Web 表单设计器的底部，您会发现一个名为 Source 的选项卡。单击它可以看到为我们的 Web 表单生成的标记。`Default.aspx`的相关标注如清单 [12-5](#Par78) 所示。

```
<%@ Page Language="C#" AutoEventWireup="true"
CodeFile="Default.aspx.cs" Inherits="_Default" %>

<!DOCTYPE html>

...
<form id="form1" runat="server">
...
<asp:Label ID="Label1" runat="server" Font-Names="Arial"
Font-Size="X-Large" Text="Contact Us">
</asp:Label>
...
<asp:ValidationSummary ID="ValidationSummary1" runat="server" />
...
<asp:Label ID="Label2" runat="server" Text="Your Name :"></asp:Label>
...
<asp:TextBox ID="TextBox1" runat="server"></asp:TextBox>
<asp:RequiredFieldValidator
                ID="RequiredFieldValidator1"
                runat="server" ControlToValidate="TextBox1"
                Display="Dynamic"
                ErrorMessage="Please enter your name">*
</asp:RequiredFieldValidator>
...
<asp:Label ID="Label3" runat="server" Text="Your Email :"></asp:Label>
...
<asp:TextBox ID="TextBox2" runat="server"></asp:TextBox>
<asp:RequiredFieldValidator

                ID="RequiredFieldValidator2" runat="server"
                ControlToValidate="TextBox2"
                Display="Dynamic"
                ErrorMessage="Please enter your email">*
</asp:RequiredFieldValidator>
<asp:RegularExpressionValidator
                ID="RegularExpressionValidator1"
                runat="server"
                ControlToValidate="TextBox2"
                Display="Dynamic"
                ErrorMessage="Please enter a valid email address"
                ValidationExpression="\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*">*
</asp:RegularExpressionValidator></td>
...
<asp:Label ID="Label4" runat="server" Text="Contacting For :"></asp:Label>
...
<asp:DropDownList ID="DropDownList1" runat="server">
<asp:ListItem Value=" Please select ">Please select</asp:ListItem>
<asp:ListItem Value=" Sales Quotation ">Sales Quotation</asp:ListItem>
<asp:ListItem Value=" Technical Problem ">Technical Problem</asp:ListItem>
<asp:ListItem Value=" Other ">Other</asp:ListItem>
</asp:DropDownList>
<asp:RequiredFieldValidator ID="RequiredFieldValidator3" runat="server"
ControlToValidate="DropDownList1" Display="Dynamic"
ErrorMessage="Please select a reason for contacting us"
InitialValue="PS">*
</asp:RequiredFieldValidator>
...
<asp:Label ID="Label5" runat="server" Text="Subject :"></asp:Label>
...
<asp:TextBox ID="TextBox3" runat="server" Columns="37"></asp:TextBox>
<asp:RequiredFieldValidator
                ID="RequiredFieldValidator4" runat="server" ControlToValidate="TextBox3"
                Display="Dynamic" ErrorMessage="Please enter subject">*
</asp:RequiredFieldValidator>

...
<asp:Label ID="Label6" runat="server" Text="Message :"></asp:Label>
...
<asp:TextBox ID="TextBox4" runat="server" Columns="30" Rows="3"
 TextMode="MultiLine"></asp:TextBox>
<asp:RequiredFieldValidator
ID="RequiredFieldValidator5" runat="server" ControlToValidate="TextBox4"
Display="Dynamic" ErrorMessage="Please enter message">*
</asp:RequiredFieldValidator>
...
<asp:Label ID="Label7" runat="server" Text="Web Site (Optional) :"></asp:Label>
...
<asp:TextBox ID="TextBox5" runat="server"></asp:TextBox>
<asp:RegularExpressionValidator
ID="RegularExpressionValidator2" runat="server" ControlToValidate="TextBox5"
Display="Dynamic" ErrorMessage="Please enter a valid URL"
ValidationExpression="http(s)?://([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?">
*</asp:RegularExpressionValidator>
...
<asp:Label ID="Label8" runat="server" Text="You represent :"></asp:Label>
...
<asp:RadioButtonList ID="RadioButtonList1" runat="server"
RepeatDirection="Horizontal">
<asp:ListItem Selected="True" Value="Individual">Individual</asp:ListItem>
<asp:ListItem Value="ListItem">Company</asp:ListItem>
</asp:RadioButtonList>
...
<asp:Button ID="Button1" runat="server" OnClick="Button1_Click" Text="Submit" />
...
<asp:Label ID="Label9" runat="server" Font-Bold="True" ForeColor="Red"></asp:Label>
...
</html>

Listing 12-5.Server Control Markup from Default.aspx

```

仔细观察标记。在顶部，有一个名为`@Page`的指令。指令向 ASP.NET 处理引擎提供关于某个实体的信息。`@Page`指令给出了当前 Web 表单的详细信息，比如编码语言、代码文件名和代表这个 Web 表单的代码文件中的类。

接下来是一个`<!DOCTYPE>`声明，表明这个文档是一个 HTML5 文档。

如果进一步观察，您会注意到每个服务器控件都由特殊的 XML 标记表示。例如，Label 控件由一个`<asp:Label>`标记表示，TextBox 控件由一个`<asp:TextBox>`标记表示。冒号(`:`)——换句话说，`asp`——之前的部分称为标签前缀。冒号之后的部分——`Label`或`TextBox`——称为标签名。

每个服务器控件都将其`ID`属性设置为一个唯一的值。控件的`ID`用于以编程方式访问它。类似地，每个服务器控件都有一个`runat`属性，该属性的值必须为`server`，并表明该标签是服务器控件标记。您还会发现，通过“属性”窗口设置的所有属性都在服务器控件标记中表示为属性或子元素。因此，ASP.NET 服务器控件标记是一种特殊的 XML 词汇表。

##### 编写代码

在本节中，您将编写一些代码，以便当用户输入有效数据并单击 Submit 按钮时，数据会通过电子邮件发送给您。为了完成这个需求，您需要处理提交按钮的`Click`事件。双击 Submit，您将被带到代码隐藏文件(`Default.aspx.cs`)，在这里您可以编写代码。清单 [12-6](#Par84) 展示了 Web 表单类和`Click`事件处理程序的框架。我们将在下一步填充它。

```
public partial class _Default : System.Web.UI.Page
{
    protected void Button1_Click(object sender, EventArgs e)
    {

    }
}

Listing 12-6.Web Form Class and the Click Event Handler

```

代码隐藏文件包含一个名为`_Default`的分部类，它继承自`System.Web.UI.Page`基类，为您的 Web 表单提供基本功能。记住，`@Page`指令有一个名为`Inherits`的属性引用了这个类。`_Default`类被标记为部分类，因为只有当标记文件(`.aspx`)和代码隐藏文件(`.cs`)组合在一起时，才会生成完整的类。这种合并发生在运行时，是 ASP.NET 框架的工作。另外，请注意在代码隐藏文件顶部导入的几个命名空间。所有以`System.Web`开头的名称空间实际上都位于一个程序集`System.Web.dll`中。这是 ASP.NET Web 窗体的主程序集。

Note

对 ASP.NET 服务器控件和相关概念的深入讨论超出了本书的范围。如果您对使用 web 表单开发 ASP.NET Web 应用程序感兴趣，可以考虑访问 [`https://www.asp.net/web-forms`](https://www.asp.net/web-forms) 了解更多信息。

为了编写功能代码，您需要导入两个名称空间:`System.Net`和`System.Net.Mail`。后一个名称空间提供了发送电子邮件的类。清单 [12-7](#Par88) 显示了添加必要代码后的`Click`事件处理程序。

```
protected void Button1_Click(object sender, EventArgs e)
{
  SmtpClient client = new SmtpClient("localhost");
  client.Credentials = CredentialCache.DefaultNetworkCredentials;
  MailMessage msg = new MailMessage();
  msg.From = new MailAddress(TextBox2.Text);
  msg.To.Add("user@localhost");
  msg.Subject = TextBox3.Text;
  msg.Body =
    "[" + DropDownList1.SelectedItem.Text + "]" + TextBox4.Text + "\r\n" +
      TextBox1.Text + "\r\n" + TextBox5.Text;
  client.Send(msg);
  Label9.Text = "Your message has been sent. Thank you!";
}
Listing 12-7.Sending E-Mail from the Code-Behind File

```

代码声明了一个`SmtpClient`类的对象。`SmtpClient`类允许您基于简单邮件传输协议(SMTP)发送电子邮件。`SmtpClient`类的构造函数接受用于 SMTP 操作的机器的 IP 地址或名称。在我们的例子中，假设您使用 IIS 的本地安装来发送电子邮件，因此`localhost`作为参数被传递。`SmtpClient`类的`Credentials`属性表示用户认证发送方的网络凭证。`CredentialCache`类的`DefaultNetworkCredentials`属性表示当前 Windows 用户的认证凭证。

设置好凭证后，会创建一个新的`MailMessage`。`MailMessage`类代表一个电子邮件消息。这个类的`From`和`To`属性分别代表发送者和接收者，并且属于`MailAddress`类型(确保更改电子邮件地址以适合您的设置)。`Subject`和`Body`属性分别表示电子邮件的主题和正文。所有这些属性都是通过使用在各种 Web 窗体控件中输入的值来分配的。最后，`SmtpClient`类的`Send()`方法将提供的`MailMessage`发送给一个或多个接收者。成功消息显示在标签中，通知用户消息已被接收。

##### 运行 Web 应用程序

要运行您刚刚完成的 web 应用程序，您需要选择 Debug ➤开始调试菜单选项(或者只需按 F5)。Visual Studio 将在后台启动开发 web 服务器，并将在其中承载您的网站。它还会打开一个浏览器并加载`Default.aspx`。图 [12-8](#Fig8) 显示了浏览器中的`Default.aspx` Web 表单。

![A160895_2_En_12_Fig8_HTML.jpg](../Images/A160895_2_En_12_Fig8_HTML.jpg)

图 12-8。

Default.aspx in a browser

如果您尝试在不输入任何值的情况下单击提交按钮，您应该会看到验证错误消息，如图 [12-9](#Fig9) 所示。

![A160895_2_En_12_Fig9_HTML.jpg](../Images/A160895_2_En_12_Fig9_HTML.jpg)

图 12-9。

Web form showing va lidation errors

注意`ValidationSummary`是如何显示一个错误消息的集合列表的，而一个星号被显示来代替单独的验证控件。如果您在控件中输入有效值并单击提交，代码将向您的电子邮件地址发送一封电子邮件，并显示一条成功消息，如图 [12-10](#Fig10) 所示。

![A160895_2_En_12_Fig10_HTML.jpg](../Images/A160895_2_En_12_Fig10_HTML.jpg)

图 12-10。

Successful execution of the Web Form Note

因为这是第一个 ASP.NET 示例，所以我概述了开发和运行该应用程序所需的所有步骤。既然您已经熟悉了 web 站点项目，那么未来的示例将关注正在讨论的主要主题，跳过这些步骤的细节。

### XML 数据源控件

服务器控件的优势之一是它们能够执行与关系数据或分层数据的数据绑定。ASP.NET 数据源控件是一组 web 服务器控件，可自动执行常见的数据访问任务，如获取记录并在其他数据绑定控件中显示它们。所有这些都是在开发人员没有编写任何代码的情况下实现的。正如我们在本书中看到的 XML 一样，我们感兴趣的是 XML 数据源控件。当您使用服务器控件(如 TreeView)来显示分层数据时，此控件非常有用。让我们看看 XML 数据源控件如何与 TreeView 控件一起使用。

首先通过 Visual Studio 创建一个新网站。使用“添加新项”对话框向您的网站添加一个新的 XML 文件，并将其命名为`Navigation.xml`。`Navigation.xml`文件包含表示 web 站点导航结构的 XML 标记。来自`Navigation.`T3 的 XML 标记如清单 [12-8](#Par97) 所示。

```
<?xml version="1.0" encoding="utf-8" ?>
<node text="Home" url="default.aspx">
  <node text="Products" url="products.aspx">
    <node text="Product 1" url="product1.aspx"></node>
    <node text="Product 2" url="product2.aspx"></node>
    <node text="Product 3" url="product3.aspx"></node>
  </node>
  <node text="Services" url="services.aspx">
    <node text="Service 1" url="service1.aspx"></node>
    <node text="Service 2" url="service2.aspx"></node>
    <node text="Service 3" url="service3.aspx"></node>
  </node>
  <node text="About Us" url="about.aspx"></node>
  <node text="Contact Us" url="contact.aspx"></node>
</node>

Listing 12-8.XML Markup from the Navigation.xml File

```

文档的根标签是`<node>`，它进一步包含各种`<node>`标签。每个`<node>`元素代表树形视图控件的一个节点，有两个属性，`text`和`url`:

*   属性指定要在树视图节点中显示的文本。
*   `url`属性指向用户应该被导航到的 URL。

`<node>`元素的嵌套决定了 TreeView 的嵌套。因此，树视图的根节点将是 Home。Home 节点将有四个直接子节点:产品、服务、关于我们和联系我们。类似地,“产品”和“服务”节点各有三个子节点。

现在将一个`XmlDataSource`控件从工具箱拖放到 Web 表单设计器上。将其`DataFile`属性设置为`Navigation.xml`。属性指向一个将向 XML 数据源控件提供数据的 XML 文件。接下来，将一个 TreeView 控件拖放到 Web 表单上，并将其`DataSourceID`属性设置为您刚刚配置的`XmlDataSource`控件的 ID。现在定位树形视图的`DataBindings`属性并打开树形视图数据绑定编辑器(见图 [12-11](#Fig11) )。

![A160895_2_En_12_Fig11_HTML.jpg](../Images/A160895_2_En_12_Fig11_HTML.jpg)

图 12-11。

TreeView DataBindings Edito r

在 Available Data Bindings 区域，您将看到 XML 文件中每个级别的所有节点。选择每个级别的节点，然后单击“添加”按钮。现在，在“选定的数据绑定”区域中将有三个条目。选择第一个数据绑定，并将其`TextField`和`NavigateUrlField`属性分别设置为`text`和`url`。正如您可能已经猜到的，`text`和`url`是`<node>`元素的属性。`DataMember`属性表示提供数据的 XML 文档中元素的名称，并自动设置为`node`。对剩余的两个数据绑定重复相同的过程。清单 [12-9](#Par104) 显示了`Default.aspx`的完整标记。

```
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="Default.aspx.cs"
Inherits="_Default" %>

<!DOCTYPE html>

<html  >
  <head runat="server">
    <title>Untitled Page</title>
  </head>
  <body>
    <form id="form1" runat="server">
      <asp:XmlDataSource ID="XmlDataSource1" runat="server"
                         DataFile="∼/Navigation.xml">
      </asp:XmlDataSource>
      <asp:TreeView ID="TreeView1" runat="server" AutoGenerateDataBindings="False"
                    DataSourceID="XmlDataSource1" Font-Bold="True" Font-Size="Large"
                    ShowLines="True">
        <DataBindings>
          <asp:TreeNodeBinding DataMember="node" NavigateUrlField="url"
                               TextField="text" />
          <asp:TreeNodeBinding DataMember="node" NavigateUrlField="url"
                               TargetField="text" />
          <asp:TreeNodeBinding DataMember="node" NavigateUrlField="url"
                               TargetField="text" />
        </DataBindings>
      </asp:TreeView>
    </form>
  </body>
</html>

Listing 12-9.Markup Containing the XmlDataSource and the TreeView

```

如您所见，XML 数据源控件和 TreeView 控件分别由`<asp:XmlDataSource>`和`<asp:TreeView>`标记表示。每个树视图节点绑定由一个`<asp:TreeNodeBinding>`标签表示。`TreeNodeBinding`元素的`DataMember`、`NavigateUrlField`和`TextField`属性代表您之前分配的属性。

现在像以前一样运行 web 站点，看看 TreeView 控件如何根据在`Navigation.xml`文件中指定的结构呈现各种节点。图 [12-12](#Fig12) 显示了网络表单的运行示例。

![A160895_2_En_12_Fig12_HTML.jpg](../Images/A160895_2_En_12_Fig12_HTML.jpg)

图 12-12。

A TreeView populated by using an XML data source control

#### 应用变换

在前面的示例中，您按原样向 XML 数据源控件提供了 XML 文件。如果您想对 XML 文件应用 XSLT 转换，然后将其与 TreeView 绑定，该怎么办？幸运的是，XML 数据源控件有一个内置的工具来做这件事:`TransformFile`属性，它指向一个 XSLT 文件。在将 XML 数据提供给其他控件(如 TreeView)之前，将 XSLT 样式表应用于 XML 数据，然后传递转换后的数据。假设您将一个 TreeView 控件绑定到一个 XML 文档，如清单 [12-10](#Par108) 所示。

```
<?xml version="1.0" encoding="utf-8"?>
<MenuItem Title="Home" URL="default.aspx">
  <MenuItem Title="Products" URL="products.aspx">
    <MenuItem Title="Product 1" URL="product1.aspx" />
    <MenuItem Title="Product 2" URL="product2.aspx" />
    <MenuItem Title="Product 3" URL="product3.aspx" />
  </MenuItem>
  <MenuItem Title="Services" URL="services.aspx">
    <MenuItem Title="Service 1" URL="service1.aspx" />
    <MenuItem Title="Service 2" URL="service2.aspx" />
    <MenuItem Title="Service 3" URL="service3.aspx" />
  </MenuItem>
  <MenuItem Title="About Us" URL="about.aspx" />
  <MenuItem Title="Contact Us" URL="contact.aspx" />
</MenuItem>
Listing 12-10.XML Document to Be Bound to a TreeView

```

正如您所看到的，这个 XML 文档使用了`<MenuItem>`元素来表示一个 TreeView 节点。`Title`和`URL`属性表示单个树形视图节点的`Text`和`NavigateUrlField`属性。现在假设出于某种原因，您想要将同一个 TreeView 绑定到另一个 XML 文档，如清单 [12-11](#Par110) 所示。

```
<?xml version="1.0" encoding="utf-8" ?>
<node text="Home" url="default.aspx">
  <node text="Products" url="products.aspx">
    <node text="Product 1" url="product1.aspx"></node>
    <node text="Product 2" url="product2.aspx"></node>
    <node text="Product 3" url="product3.aspx"></node>
  </node>
  <node text="Services" url="services.aspx">
    <node text="Service 1" url="service1.aspx"></node>
    <node text="Service 2" url="service2.aspx"></node>
    <node text="Service 3" url="service3.aspx"></node>
  </node>
  <node text="About Us" url="about.aspx"></node>
  <node text="Contact Us" url="contact.aspx"></node>
</node>
Listing 12-11.XML Markup from the 
New XML File

```

您可能已经注意到，这是我们在前面的例子中使用的同一个 XML 文件。为了适应这种变化，您需要重新配置 TreeView 节点数据绑定以适应新的 XML 文档。如果底层数据绑定有复杂的嵌套，这可能不是一件容易的事情。如果对清单 [12-11](#Par110) 中的 XML 应用 XSLT 样式表，并将其转换为与清单 [12-10](#Par108) 中的 XML 匹配，就可以避免这种情况。清单 [12-12](#Par112) 显示了可以完成这种转换的 XSLT 样式表。

```
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <xsl:for-each select=".">
      <xsl:apply-templates/>
    </xsl:for-each>
  </xsl:template>
  <xsl:template match="node">
    <xsl:element name="MenuItem">
      <xsl:attribute name="Title">
        <xsl:value-of select="@text"/>
      </xsl:attribute>
      <xsl:attribute name="URL">
        <xsl:value-of select="@url"/>
      </xsl:attribute>
      <xsl:apply-templates />
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>

Listing 12-12.An XSLT Style Sheet for 
Transforming the New XML Markup

```

样式表将一个`<node>`元素转换成一个`<MenuItem>`元素。此外，它将`text`和`url`属性分别转换为`Title`和`URL`属性。

要测试`TransformFile`属性如何工作，您需要按照以下步骤修改前面的示例:

1.  向网站添加一个名为`Navigation.xslt`的新 XSLT 文件。
2.  键入清单 [12-12](#Par112) 中所示的标记。
3.  将 XML 数据源控件的`TransformFile`属性设置为`Navigation.xslt`。
4.  打开 TreeView 的 TreeView DataBindings 编辑器，修改数据绑定，使用 MenuItem 节点为`DataMember`，Title 为`TextField`，URL 为`NavigateUrlField`。

这一次，树形视图数据绑定编辑器如图 [12-13](#Fig13) 所示。

![A160895_2_En_12_Fig13_HTML.jpg](../Images/A160895_2_En_12_Fig13_HTML.jpg)

图 12-13。

TreeView DataBindings Editor showing transformed nodes

您将会看到，尽管`DataFile`属性仍然是`Navigation.xml`，但是显示的数据绑定是按照 XSLT 样式表中指定的转换进行的。如果您再次运行 Web 表单，输出应该与之前的图 [12-12](#Fig12) 相同。

#### 使用 XPath 表达式过滤数据

有时，您可能希望从源 XML 文件中筛选数据，并将筛选的数据绑定到其他控件。这就是 XML 数据源控件的`XPath`属性的用武之地。`XPath`属性接受一个有效的 XPath 表达式，并将其应用于源 XML 数据。

例如，假设您希望在 TreeView 中只显示与产品相关的节点。您可以通过将 XML 数据源的 XPath 属性设置为`/node/node[@text="Products"]`来实现这一点。这样，将只过滤与产品相关的节点(产品、产品 1、产品 2 和产品 3)。TreeView 最多只能嵌套两层(产品作为顶层节点，其他三个节点作为子节点)。图 [12-14](#Fig14) 显示了设置`XPath`属性后相同 Web 表单的运行示例。

![A160895_2_En_12_Fig14_HTML.jpg](../Images/A160895_2_En_12_Fig14_HTML.jpg)

图 12-14。

TreeView after applying the XPath filter

#### 将 XML 数据源绑定到菜单控件

在前面的示例中，您使用 TreeV iew 显示由 XML 数据源控件提供的数据。ASP.NET 还提供了一个菜单控件，可用于显示分层数据。就 XML 数据绑定而言，Menu 控件与 TreeView 控件非常匹配。但是，它在外观和感觉上有所不同。Menu 控件在 Web 窗体中呈现类似于传统 Windows 应用程序的动态下拉菜单。让我们看一个如何使用它的例子。

在 Visual Studio 中创建新网站。通过使用“添加现有项目”对话框，将先前创建的`Navigation.xml`文件添加到网站。将一个`XmlDataSource`控件拖放到默认的 Web 表单上，并将其`DataFile`属性设置为`Navigation.xml`。现在将一个菜单控件拖放到表单上，并将其`DataSourceID`属性设置为您刚刚配置的`XmlDataSource`控件的 ID。

现在，找到菜单控件的`DataBindings`属性。与 TreeView 类似，Menu 控件打开 Menu DataBindings 编辑器，您可以在其中配置数据绑定。

配置数据绑定的过程与之前完全相同。您需要选择所需的数据绑定，并将它们的`DataMember`、`TextField`和`NavigateUrl`属性分别设置为`node`、`text`和`url`。图 [12-15](#Fig15) 显示了添加了所需数据绑定的菜单数据绑定编辑器。

![A160895_2_En_12_Fig15_HTML.jpg](../Images/A160895_2_En_12_Fig15_HTML.jpg)

图 12-15。

Menu DataBindings Editor

Web 表单的完整标记如清单 [12-13](#Par128) 所示。

```
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="Default.aspx.cs"
         Inherits="_Default" %>

<!DOCTYPE html>
<html  >
  <head runat="server">
    <title>Untitled Page</title>
  </head>
  <body>
    <form id="form1" runat="server">
      <asp:XmlDataSource ID="XmlDataSource1" runat="server"
                         DataFile="∼/Navigation.xml"></asp:XmlDataSource>
      <asp:Menu ID="Menu1" runat="server" BackColor="#E3EAEB"
                DataSourceID="XmlDataSource1"
        <DataBindings>
          <asp:MenuItemBinding DataMember="node" NavigateUrlField="url"
                               TextField="text" />
          <asp:MenuItemBinding DataMember="node" NavigateUrlField="url"
                               TextField="text" />
          <asp:MenuItemBinding DataMember="node" NavigateUrlField="url"
                               TextField="text" />
        </DataBindings>
      </asp:Menu>
    </form>
  </body>
</html>

Listing 12-13.Markup of the Menu Control

```

如您所见，菜单控件由`<asp:Menu>`标记表示。`<DataBindings>`部分定义了一个或多个数据绑定，其中每个数据绑定由一个`<asp:MenuItemBinding>`元素表示。运行 Web 表单应呈现如图 [12-16](#Fig16) 所示的菜单。

![A160895_2_En_12_Fig16_HTML.jpg](../Images/A160895_2_En_12_Fig16_HTML.jpg)

图 12-16。

The Menu control in action

## 使用站点地图

站点地图是一个 XML 文件，它详细描述了网站的总体导航布局。然后，您可以根据需要使用该站点地图文件。站点地图文件的扩展名为`.sitemap`。让我们通过一个例子来研究站点地图文件。看看图 [12-17](#Fig17) 。

![A160895_2_En_12_Fig17_HTML.jpg](../Images/A160895_2_En_12_Fig17_HTML.jpg)

图 12-17。

Structure of a web site

图 [12-17](#Fig17) 显示了一个示例网站的目录结构。主页(`Default.aspx`)和联系我们页面(`contact.aspx`)位于网站的根文件夹中。有两个子文件夹叫做`Products`和`Services`。其中每个都包含两个 Web 表单，分别是`Product1.aspx`和`Product2.aspx`，以及`Service1.aspx`和`Service2.aspx`。现在让我们用一个站点地图来表示这个网站的结构。

使用 Visual Studio 创建新网站。使用添加新项目对话框添加新的站点地图文件(参见图 [12-18](#Fig18) )。将站点地图文件命名为`Web.sitemap`。

![A160895_2_En_12_Fig18_HTML.jpg](../Images/A160895_2_En_12_Fig18_HTML.jpg)

图 12-18。

Adding a new site map

现在将清单 [12-14](#Par134) 中所示的 XML 标记输入到`Web.sitemap`文件中。

```
<?xml version="1.0" encoding="utf-8" ?>
<siteMap  >
<siteMapNode url="default.aspx" title="Home" description="My Web Site">
  <siteMapNode url="∼/products/default.aspx" title="Products">
    <siteMapNode url="∼/products/product1.aspx" title="First Product" />
    <siteMapNode url="∼/products/product2.aspx" title="Second Product" />
  </siteMapNode>
  <siteMapNode url="∼/services/default.aspx" title="Services">
    <siteMapNode url="∼/services/service1.aspx" title="First Service" />
    <siteMapNode url="∼/services/service2.aspx" title="Second Service" />
  </siteMapNode>
<siteMapNode url="contact.aspx" title="Contact Us" />
</siteMapNode>
</siteMap>
Listing 12-14.Contents of the Web.sitemap File

```

站点地图文件包含一组预定义的标签和属性。站点地图文件的根节点是`<siteMap>`。根据您的网站结构，它还包含几个`<siteMapNodes>`标签。`<siteMapNode>`标签有四个重要的属性。它们列于表 [12-1](#Tab1) 中。

表 12-1。

Attributes of a Site Map Node

<colgroup><col> <col></colgroup> 
| 属性 | 描述 |
| --- | --- |
| `title` | 指示页面的标题。导航控件通常使用此属性来显示 URL 的标题。 |
| `url` | 指示此节点表示的页面的 URL。 |
| `description` | 指定目标页面的描述。您可以使用此描述来显示工具提示。 |
| `roles` | 使用安全性调整时，此属性指定允许访问此页面的角色。 |

Note

安全修整是一项功能，它通过仅呈现当前用户允许的节点来实现基于角色的安全性。换句话说，只有当用户的角色在`<siteMapNode>`元素的`roles`属性中指定时，用户才能访问特定的`<siteMapNode>`。

站点地图文件通常用于呈现某种导航结构。使用刚刚创建的站点地图文件有两种常见方式:

*   在`SiteMapPath`控件中
*   在`SiteMapDataSource`控件中

在接下来的几节中，您将会看到这两者。

### 使用 SiteMapPath 控件

`SiteMapPath`控件允许你呈现通常所说的面包屑。图 [12-19](#Fig19) 显示了什么是面包屑。

![A160895_2_En_12_Fig19_HTML.jpg](../Images/A160895_2_En_12_Fig19_HTML.jpg)

图 12-19。

Breadcrumbs

`SiteMapPath`控件显示不同级别的导航。您可以单击父级或根级向后导航或导航到顶层。在我们深入研究细节之前，让我们首先创建所需的目录结构和 Web 表单。首先在网站上添加两个文件夹，分别叫做`Products`和`Services`。添加如表 [12-2](#Tab2) 所示的 Web 表单。

表 12-2。

Folders and Web Forms

<colgroup><col> <col></colgroup> 
| Web 表单名称 | 文件夹 |
| --- | --- |
| `Default.aspx` | 根文件夹 |
| `Contact.aspx` | 根文件夹 |
| `Product1.aspx` | `Products` |
| `Product2.aspx` | `Products` |
| `Service1.aspx` | `Services` |
| `Service2.aspx` | `Services` |

现在将一个`SiteMapPath`控件拖放到每个 Web 表单上。在浏览器中运行`Service2.aspx`，你应该会看到类似图 [12-19](#Fig19) 的东西。`S` `iteMapPath`控件根据当前 Web 表单在站点地图文件中的位置自动呈现它的面包屑。

### 使用 SiteMapDataSource 控件

站点地图的使用不仅限于`SiteMapPath`控件。您还可以将站点地图附加到导航控件，如 TreeView。在这个例子中，我们将使用相同的站点地图文件绑定到一个 TreeView。

使用 Visual Studio 创建新网站。向其中添加相同的`Web.sitemap`文件。这次将一个`SiteMapDataSource`控件拖放到 Web 表单上。`SiteMapDataSource`控件自动拾取`Web.sitemap`文件并将其提供给其他控件。此外，拖放一个 TreeView 控件，并将其`DataSourceID`属性设置为`SiteMapDataSource`的 ID 属性。就这样。运行 Web 表单，它应该类似于图 [12-20](#Fig20) 。

![A160895_2_En_12_Fig20_HTML.jpg](../Images/A160895_2_En_12_Fig20_HTML.jpg)

图 12-20。

TreeView bound with SiteMapDataSource c ontrol

## 使用 XML 控件

在第 6 章中，您学习了将 XSLT 样式表应用于 XML 数据，并将它们从一种词汇表转换成另一种词汇表。您通过创建一个`XslCompiledTransform`类的实例实现了这一点。然后通过使用它的`Load()`方法将 XSLT 样式表加载到其中。最后，您通过使用它的`Transform()`方法完成了转换。ASP.NET 为这种手工编码提供了一种简单的替代方法:XML 控件。XML 控件接受 XML 文档和 XSLT 样式表。然后，它将样式表应用于 XML 数据，并在网页上呈现内容。XML 控件最常见的用途是将 XML 数据转换成 HTML，当然也不一定是 HTML。

为了演示 XML 控件的用法，请创建一个新的网站。添加一个名为`Employees.xml`的新 XML 文件，并键入清单 [12-15](#Par148) 中所示的标记。

```
<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="Employees.xslt"?>
<!-- This is list of employees -->
<employees>
  <employee employeeid="1">
    <firstname>Nancy</firstname>
    <lastname>Davolio</lastname>
    <homephone>(206) 555-9857</homephone>
    <notes>
      <![CDATA[Education includes a BA in psychology from Colorado State University in 1970\. She also completed "The Art of the Cold Call." Nancy is a member of Toastmasters International.]]>
  </notes>
  </employee>
  <employee employeeid="2">
    <firstname>Andrew</firstname>
    <lastname>Fuller</lastname>
    <homephone>(206) 555-9482</homephone>
    <notes>
      <![CDATA[Andrew received his BTS commercial in 1974 and a Ph.D. in
international marketing from the University of Dallas in 1981\. He is fluent in
French and Italian and reads German. He joined the company as a sales
representative, was promoted to sales manager in January 1992 and to vice
president of sales in March 1993\. Andrew is a member of the Sales Management
Roundtable, the Seattle Chamber of Commerce, and the Pacific Rim Importers
Association.]]> 

    </notes>
  </employee>
  <employee employeeid="3">
    <firstname>Janet</firstname>
    <lastname>Leverling</lastname>
    <homephone>(206) 555-3412</homephone>
    <notes>
      <![CDATA[Janet has a BS degree in chemistry from Boston College (1984).
She has also completed a certificate program in food retailing management.
Janet was hired as a sales associate in 1991 and promoted to sales
representative in February 1992.]]>
    </notes>
  </employee>
</employees>

Listing 12-15.XML File That Supplies Data to the XML Control

```

类似地，添加一个名为`Employees.xsl`的新 XSLT 样式表，并输入清单 [12-16](#Par150) 中所示的标记。

```
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <html>
      <body>
        <h1>Employee Listing</h1>
        <table border="1">
          <tr>
            <th>Employee ID</th>
            <th>First Name</th>
            <th>Last Name</th>
            <th>Home Phone</th>
            <th>Notes</th>
          </tr>
          <xsl:for-each select="employees/employee">
            <tr>
              <td>
                <xsl:value-of select="@employeeid"/>
              </td>
              <td>
                <xsl:value-of select="firstname"/>
              </td>
              <td>
                <xsl:value-of select="lastname"/>
              </td>
              <td>
                <xsl:value-of select="homephone"/>
              </td>
              <td>
                <xsl:value-of select="notes"/>
              </td>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
Listing 12-16.XSLT Style Sheet to Be Applied

```

Note

这些文件与您在第 [6](06.html) 章中使用的文件相同。如果需要，您可以将它们添加到您的网站，而不是重新创建它们。

现在将一个 XML 控件拖放到默认的 Web 表单上。将其`DocumentSource`属性设置为`Employees.xml`，将其`TransformSource`属性设置为`Employees.xsl`。前一个属性指向要转换的 XML 文件，而后一个属性指向要应用于 DocumentSource 的 XSLT 样式表。现在运行 Web 表单，你应该会看到类似于图 [12-21](#Fig21) 的东西。

![A160895_2_En_12_Fig21_HTML.jpg](../Images/A160895_2_En_12_Fig21_HTML.jpg)

图 12-21。

XML data transformed to HTML by using the XML control

## 使用。NET 框架配置系统

那个。NET Framework 的配置系统严重依赖 XML 文件。有两个不同的 XML 文件存储。NET Framework 的配置:

*   机器配置文件
*   应用程序配置文件

当您安装。在机器上，一个名为`Machine.config`的 XML 文件在`<installation_path>/Config`文件夹中创建。`Machine.config`文件是主配置文件，包含适用于所有的配置设置。该计算机上运行的. NET 应用程序。

尽管这个文件是 XML 格式的，并且可以直接编辑，但是您应该小心操作。这是因为对该文件所做的任何更改都会影响该机器上运行的所有应用程序。图 [12-22](#Fig22) 显示了`Machine.config`在样本安装中的位置。

![A160895_2_En_12_Fig22_HTML.jpg](../Images/A160895_2_En_12_Fig22_HTML.jpg)

图 12-22。

Location of Machine.config

要覆盖在`Machine.config`文件中指定的设置，您需要创建应用程序配置文件。应用程序配置文件也是包含特殊 XML 标记的 XML 文件。对于基于 Windows 的应用程序，应用程序配置文件的格式是`<exe_name>.exe.config`，其中`exe_name`是应用程序可执行文件的名称。

Note

在 Visual Studio 中开发 windows 应用程序时，你会发现项目的根文件夹中有`App.config`文件。该文件保存开发时应用程序配置。在`Bin\Debug or Bin\Release`文件夹中可以找到`<exe_name>.exe.config`。您应该将`<exe_name>.exe.config`与您的应用程序一起部署，而不是`App.config`文件。

对于 web 应用程序，应用程序配置文件名必须是`web.config`。在接下来的小节中，您将了解更多关于`web.config`文件和其中使用的 XML 词汇表。

Note

还有存储代码访问安全相关配置的安全配置文件。这些文件应该使用代码访问安全策略工具(`Caspol.exe`)进行更改。建议您只有在意识到这些文件会对安全策略产生影响的情况下，才更改这些文件。在本书中，我们不会深入讨论安全配置文件的任何细节。

### web.config 文件的结构

清单 [12-17](#Par163) 显示了一个`web.config`文件的总体结构轮廓。

```
<configuration>
    <appSettings />
    <connectionStrings />
    <system.web />
</configuration>
Listing 12-17.Structural Outline of web.config

```

如您所见，`web.config`文件的根节点是`<configuration>`，有三个主要的子部分:

*   `<appSettings>`部分用于指定应用程序配置设置。
*   `<connectionStrings>`部分用于存储一个或多个数据库连接字符串。
*   `<system.web>`部分包含适用于网络应用程序的所有设置。

所有这些部分都是可选的。然而，在大多数实际情况下，您至少会有`<system.web>`部分。

Note

`web.config`文件包含许多配置部分。这里不可能涵盖所有部分。我将只讨论一些常用的部分。

### Web.config 继承

文件展示了通常所说的继承行为。在一个 web 应用程序中，不同的文件夹中可以有一个或多个`web.config`文件。一个`web.config`文件的设置会应用到它所在的文件夹及其所有子文件夹。但是，如果子文件夹包含自己的`web.config`，则该`web.config`中指定的设置优先。

## 将 Web.config 用于常见配置任务

现在我们对`web.config`的工作原理有了基本的了解，让我们看看如何执行一些常见的配置任务。我们将简要介绍以下具体任务:

*   如何存储和检索应用程序配置设置
*   如何存储和检索数据库连接字符串
*   如何使用表单身份验证
*   如何处理会话状态
*   如何在网站中提供自定义错误页面

### 存储和检索应用程序配置设置

在许多现实世界的应用程序中，避免硬编码值是一项强制性要求。在本章的前面，我们开发了一个联系我们 Web 表单，它将用户的消息发送到指定的电子邮件地址。在该示例中，我们在代码隐藏文件中硬编码了一个电子邮件地址。如果部署后电子邮件地址发生变化，该怎么办？显然，您需要更改源代码以匹配新的电子邮件地址，并重新部署应用程序。对于真实世界的应用程序，这不是推荐的做法。如果我们能够将电子邮件地址从应用程序中分离出来，存储在一个外部位置，并在您的代码中检索它，这不是很好吗？之前。NET Framework 中，开发人员通过使用`.INI`文件或注册表来实现这一点。英寸 NET 中，您有一个很好的选择:配置文件的应用程序配置部分。

`web.config`的`<appSettings>`部分允许您存储此类特定于应用程序的设置。然后，您可以在源代码中读取这些设置。如果在部署应用程序后设置发生了变化，您只需要更改`web.config`文件，而不是源代码。让我们修改联系我们 Web 表单以使用应用程序配置设置。

Note

尽管这里讨论的例子在 web 应用程序中使用了`<appSettings>`部分，但是`<appSettings>`同样适用于 Windows 应用程序。

从菜单中选择“文件”“➤”“打开➤网站”,打开同一网站。打开`web.config`文件，修改`<appSettings>`段，如清单 [12-18](#Par181) 所示。

```
<appSettings>
    <add key="host" value="localhost"/>
    <add key="email" value="user@localhost"/>
</appSettings>
Listing 12-18.Storing Values

in the <appSettings> Section

```

`<appSettings>`部分可以包含一个或多个`<add>`元素。`<add>`元素有两个属性:

*   `key`属性定义了一个键，用它可以在代码中访问值。
*   `value`属性指定键的实际值。

在我们的例子中，我们定义了两个键:`host`和`email`。前者存储 SMTP 主机的值，后者存储您的电子邮件地址。现在打开 Web 表单的代码隐藏，修改提交按钮的`Click`事件处理程序，如清单 [12-19](#Par186) 所示。

```
protected void Button1_Click(object sender, EventArgs e)
{
  string host = ConfigurationManager.AppSettings["host"];

  string email = ConfigurationManager.AppSettings["email"];

  SmtpClient client = new SmtpClient(host);

  client.Credentials = CredentialCache.DefaultNetworkCredentials;
  MailMessage msg = new MailMessage();
  msg.From = new MailAddress(TextBox2.Text);
  msg.To.Add(email);

  msg.Subject = TextBox3.Text;
  msg.Body =
    "[" + DropDownList1.SelectedItem.Text + "]" + TextBox4.Text + "\r\n" +
      TextBox1.Text + "\r\n" + TextBox5.Text;
  client.Send(msg);
  Label9.Text = "Your message has been sent. Thank you!";
}
Listing 12-19.Retrieving Values fr

om the <appSettings> Section

```

注意粗体标记的代码。代码使用了一个名为`ConfigurationManager`的类，它位于`System.Configuration`名称空间中。默认情况下，`System.Configuration`是在代码隐藏中导入的。`ConfigurationManager`类的`AppSettings`属性将整个`<appSettings>`部分公开为一个`NameValueCollection`。您可以通过使用索引或键名来访问单个值，但更常见的是使用键名来访问它们。

代码检索两个键的值——`host`和`email`——并将它们存储在一个字符串变量中。`SmtpClient`类的构造函数现在接受存储在`host`字符串变量中的值，而不是硬编码的值。类似地，`Add()`方法接受存储在`email`字符串变量中的值，而不是硬编码的值。如果您运行该应用程序，您应该像以前一样得到结果，但是现在您可以自由地更改主机名和电子邮件地址，而无需接触源代码。

### 存储和检索数据库连接字符串

在源代码之外存储数据库连接字符串可能是最常见的配置任务。配置文件有一个特殊的部分来存储数据库连接字符串，称为`<connectionStrings>`。`<connectionStrings>`部分允许您存储一个或多个数据库连接字符串，稍后可以在您的代码中检索这些字符串。要检索存储在`<connectionStrings>`部分的连接字符串，您需要再次使用`ConfigurationManager`类。

为了演示`<connectionStrings>`部分的用法，您将开发一个简单的员工列表 Web 表单。Web 窗体将在 GridView 控件中显示雇员列表。首先，像以前一样使用 Visual Studio 创建一个新网站。

Note

尽管这里讨论的例子在 web 应用程序中使用了`<connectionStrings>`部分，但是`<connectionStrings>`同样适用于 Windows 应用程序。

在 IDE 中打开`web.config`文件，修改`<connectionStrings>`部分，如清单 [12-20](#Par193) 所示。

```
<connectionStrings>
  <add name="northwind"
       connectionString="data source=.;initial catalog=Northwind;
       integrated security=true"
       providerName="System.Data.SqlClient"/>
</connectionStrings>
Listing 12-20.Adding a Connection String to the <connectionStrings> Section

```

`<connectionStrings>`部分可以包含一个或多个`<add>`元素，每个元素定义一个数据库连接字符串:

*   `<add>`元素的`name`属性定义了该连接字符串的名称。稍后将使用该名称来访问连接字符串。
*   `connectionString`属性指定实际的数据库连接字符串。
*   最后，`providerName`属性表示。NET 数据提供程序，可用于与数据库通信。

现在打开默认的 Web 窗体，将一个 GridView 控件拖放到上面。然后在 Web 表单的`Page_Load`事件中输入清单 [12-21](#Par199) 所示的代码。

```
protected void Page_Load(object sender, EventArgs e)
{
  string strConn=

    ConfigurationManager.ConnectionStrings["northwind"].ConnectionString;

  SqlDataAdapter da =
    new SqlDataAdapter("SELECT EmployeeID,FirstName, LastName FROM Employees",
                       strConn);
  DataSet ds = new DataSet();
  da.Fill(ds, "employees");
  GridView1.DataSource = ds;
  GridView1.DataBind();
}
Listing 12-21.Retrieving the Connection String

```

代码使用`ConfigurationManager`类来检索连接字符串值。可以通过使用索引或连接字符串名称来访问`ConnectionStrings`集合。在我们的例子中，我们用一个名字来访问它。

存储在`<connectionStrings>`部分的每个连接字符串由一个`ConnectionStringSettings`类表示，这个类的`ConnectionString`属性返回实际的连接字符串。然后连接字符串被用作`SqlDataAdapter`构造函数的第二个参数，第一个参数是`SELECT`查询。

然后通过使用`SqlDataAdapter`类的`Fill()`方法来填充`DataSet`。这样创建的`DataSet`充当 GridView 控件的`DataSource`。GridView 控件的`DataBind()`方法将来自`DataSet`的数据绑定到 GridView。如果您在编写代码后运行 Web 表单，您应该会看到类似于图 [12-23](#Fig23) 的内容。

![A160895_2_En_12_Fig23_HTML.jpg](../Images/A160895_2_En_12_Fig23_HTML.jpg)

图 12-23。

Web Form displaying an employee listing

### 使用表单身份验证

开发网站时，您可能需要确保只有应用程序的有效用户才能访问页面。此外，您可能希望只允许属于特定角色的用户(比如管理员)访问页面。后者通常被称为基于角色的安全性。要实现这样的安全特性，您需要使用身份验证和授权。

身份验证是一个决定一个人是否是应用程序的有效用户的过程。通常，这种有效性是由用户名和密码的组合决定的。授权是一个决定经过身份验证的用户是否可以访问特定页面或功能的过程。授权用户的一种常见方式是将他们添加到一个或多个角色中。

`web.config`文件有两个部分——`<authentication>`和`<authorization>`——允许您为网站配置各自的安全方面。作为一个例子，让我们构建一个简单的 web 站点，该站点对用户进行身份验证，并在成功登录时显示一条欢迎消息。

Note

为了简单起见，在这个例子中，我们不会实现数据库驱动的身份验证和基于角色的安全性。在实际情况中，您可以使用 ASP.NET 成员和角色，或者更好的是，使用 ASP.NET 身份为您的网站开发一个完整的身份验证和授权方案。

像以前一样使用 Visual Studio 创建一个新网站。然后在 IDE 中打开`web.config`文件，添加`<authentication>`和`<authorization>`部分，如清单 [12-22](#Par208) 所示。

```
<authentication mode="Forms">
  <forms loginUrl="∼/login.aspx"
         defaultUrl="∼/default.aspx">
  </forms>
</authentication>
<authorization>
  <deny users="?"/>
</authorization>
Listing 12-22.Configuring Forms Authentication

```

清单 [12-22](#Par208) 中显示的标记将`<authentication>`部分的模式属性设置为`Forms`。模式属性可以取这些值之一— `None`、`Forms`、`Windows`、`Passport`和`Federated`。`Forms`身份验证是一种非常常见的身份验证形式，其中向用户呈现一个登录页面，用户输入一些用户名和密码，然后根据一些数据存储(如 SQL Server)验证这些凭证。

`<authentication>`部分包含配置`Forms`认证的`<forms>`元素。`<forms>`标签的`loginUrl`属性表示`Login.aspx`是应用程序的登录页面。如果任何用户试图在没有登录的情况下访问其他页面，他将被重定向到该页面。`<forms>`标签的`defaultUrl`属性表示在成功登录后，用户可以被重定向到默认页面。

`<authorization>`部分包含了`<deny>`元素。`<deny>`标签的`users`属性被设置为`?`，表示不允许匿名用户访问网站。

现在向项目添加两个 Web 表单— `Default.aspx`和`Login.aspx`。然后打开`Login.aspx`，从工具箱中拖拽一个登录控件到上面。正如您可能已经猜到的，Login 控件允许您轻松地捕获用户的用户名和密码。在这个阶段，`Login.aspx`应该如图 [12-24](#Fig24) 所示。

![A160895_2_En_12_Fig24_HTML.jpg](../Images/A160895_2_En_12_Fig24_HTML.jpg)

图 12-24。

Login.aspx with Login control

现在双击 Login 控件，转到它的`Authenticate`事件处理程序。`Authenticate`事件处理程序是编写验证用户凭证的代码的地方。在现实世界中，这里会涉及到数据库访问。为了简单起见，我们的例子使用了硬编码的用户名和密码。`Authenticate`事件处理程序如清单 [12-23](#Par214) 所示。

```
protected void Login1_Authenticate(object sender, AuthenticateEventArgs e)
{
    if(Login1.UserName=="admin" && Login1.Password=="password")
    {
        FormsAuthentication.SetAuthCookie(Login1.UserName, Login1.RememberMeSet);
        e.Authenticated = true;
        Response.Redirect(FormsAuthentication.DefaultUrl);
    }
    else
    {
        e.Authenticated = false;
    }
}
Listing 12-23.Authenticate Event Handler

```

`Authenticate`事件处理程序检查登录控件的`UserName`和`Password`属性。如果它们分别是`admin`和`password`，那么它调用`FormsAuthentication`类(`System.Web.Security`名称空间)的`SetAuthCookie()`方法。`Forms`认证在 cookie 的帮助下工作(默认情况下)。该 cookie 与请求一起出现表明用户是经过身份验证的用户。缺少此 cookie 表示用户尚未通过身份验证。`SetAuthCookie()`方法将这个 cookie 发布给用户。`SetAuthCookie()`方法的两个参数是`username`和关闭浏览器后是否还记得登录状态(持久 cookie)。

发出身份验证 cookie 后，代码会将用户重定向到默认页面。注意如何使用`FormsAuthentication`类的`DefaultUrl`属性来检索您之前在配置文件中设置的`defaultUrl`。

如果用户名和密码与指定的值不匹配，`AuthenticateEventArgs`类的`Authenticated`属性被设置为`false`。这样，登录控件将向用户显示一条错误消息。

接下来，打开`Default.aspx`文件，在上面拖放两个 Label 控件和一个 Button 控件。将按钮的 Text 属性设置为 Logout。默认页面将向用户显示欢迎消息。要指定此消息，请在`Page_Load`事件处理程序中编写清单 [12-24](#Par219) 所示的代码。

```
protected void Page_Load(object sender, EventArgs e)
{
    Label1.Text = $"Welcome {Page.User.Identity.Name}!";
    if (Request.IsAuthenticated)
    {
        Label2.Text = "You are an authenticated user.";
    }
}

Listing 12-24.Retrieving the Username

```

代码使用`Page.User.Identity.Name`检索当前登录用户的名字，并基于它形成一个欢迎消息。然后代码检查`Request`对象的`IsAuthenticated`属性。此属性指示请求是否经过身份验证。如果请求通过了身份验证，第二个标签中将显示一条消息。

现在，双击按钮控件进入它的`Click`事件处理程序。在`Click`事件处理程序中编写清单 [12-25](#Par222) 所示的代码。

```
protected void Button1_Click(object sender, EventArgs e)
{
    FormsAuthentication.SignOut();
    Response.Redirect(FormsAuthentication.LoginUrl);
}
Listing 12-25.Logging a User Out

```

代码调用了`FormsAuthentication`类的`SignOut()`方法。`SignOut()`方法删除了之前发布的认证 cookie。删除 cookie 后，用户将返回登录页面。这是通过将控件重定向到页面来实现的，如`FormsAuthentication`的`LoginUrl`属性所示。

如果您运行该应用程序，您将被带到前面显示的登录页面。如果您输入有效的凭证，将显示如图 [12-25](#Fig25) 所示的默认页面。

![A160895_2_En_12_Fig25_HTML.jpg](../Images/A160895_2_En_12_Fig25_HTML.jpg)

图 12-25。

Default page displaying w elcome message

如您所见，欢迎消息显示了用户名。您可以单击“注销”按钮注销并返回登录页面。

### 配置会话状态

ASP.NET 会话允许你存储任意的信息。会话状态是基于每个用户来维护的。会话被公开为一个内部对象—`Session`—它将数据存储为键值对。为了配置会话的行为，`web.config`具有`<sessionState>`元素。使用`<sessionState>`元素，您可以微调会话的各个方面，比如它的存储模式、超时和无 cookie 特性。

要了解如何使用`<sessionState>`，像以前一样创建一个新的 ASP.NET 网站。打开`web.config`文件并添加`<sessionState>`元素，如清单 [12-26](#Par228) 所示。

```
<sessionState
        mode="InProc"
        timeout="2"
        cookieless="true">
</sessionState>
Listing 12-26.The <sessionState> Element

```

清单 [12-26](#Par228) 中显示的`<sessionState>`元素将模式属性设置为`InProc`。模式属性控制会话数据的存储位置。可能的值有`Off`、`InProc`、`StateServer`、`SQLServer`和`Custom`。如果您将模式设置为`Off`，会话将关闭，您无法在会话中存储任何数据。`InProc`的值表示会话数据存储在托管应用的网络服务器的存储器中。`StateServer`和`SQLServer`模式允许您在 web 服务器之外存储会话状态(我们不会在本书中讨论它们)。

`timeout`属性设置空闲时间(以分钟为单位),超过该时间后会话将被清空。值为 2 意味着如果您在会话中存储了一些数据，并且此后 2 分钟内没有使用该应用程序，则这些数据将从会话中删除。默认会话超时为 20 分钟。

默认情况下，会话需要在客户端浏览器上启用 cookies。这个 cookie 通常存储一个会话的 ID。如果出于某种原因您不想使用 cookies，那么`cookieless`属性可以派上用场。将`cookieless`设置为`false`意味着会话不会使用 cookies 相反，ASP.NET 会在 URL 中添加一些东西(你马上就会看到)。

现在，打开`Default.aspx`，在上面拖拽一个标签控件。然后将清单 [12-27](#Par233) 中所示的代码添加到`Page_Load`事件处理程序中。

```
protected void Page_Load(object sender, EventArgs e)
{
    if(Session["timestamp"]==null)
    {
        Session["timestamp"] = DateTime.Now.ToString();
    }
    Label1.Text = Session["timestamp"].ToString();
}
Listing 12-27.The Page_Load event handler

```

`Page_Load`事件处理程序首先检查`Session`是否包含一个名为`timestamp`的键。如果该键不存在(值为`null`，那么当前日期和时间值将存储到会话中。然后将时间戳值分配给标签。

运行网站；您的 Web 表单应该类似于图 [12-26](#Fig26) 。

![A160895_2_En_12_Fig26_HTML.jpg](../Images/A160895_2_En_12_Fig26_HTML.jpg)

图 12-26。

Timestamp displayed from the session

如果你刷新浏览器，你会发现时间戳没有改变。这表明在页面第一次运行期间存储在会话中的值正在按预期使用。现在，让浏览器窗口闲置 3-4 分钟，然后再次刷新。你会发现时间戳变了。这是因为超时值为 2 分钟。经过 2 分钟的空闲时间后，时间戳密钥从会话中删除，因此存储了一个新的时间戳。

还要注意浏览器的地址栏。您将看到一些字符串片段插入到 URL 中。这是将`cookieless`属性设置为`true`的结果。由于这种设置，ASP.NET 将会话的 ID 添加到 URL 中，而不是存储在 cookie 中。

### 显示自定义错误页面

即使在编码阶段非常小心，错误也可能在运行时突然出现在您的网站中。用户在页面 URL 中输入错误，并试图访问受限制的区域，网络故障可能会发生，等等。作为一种健壮的编程实践，您应该做好准备来捕获所有这样的意外错误。为此，ASP.NET 允许您在`web.config`文件中指定所谓的定制错误页面。这是使用`web.config`的`<customErrors>`元素完成的。让我们看看怎么做。

在 Visual Studio 中创建新网站。在其中添加一个名为`Admin`的新文件夹。该文件夹应该包含管理页面，用户无权访问它。添加表 [12-3](#Tab3) 中列出的五个 Web 表单。

表 12-3。

Web Forms Arrangement

<colgroup><col> <col> <col></colgroup> 
| Web 表单 | 文件夹 | 描述 |
| --- | --- | --- |
| `Default.aspx` | 根 | 网站的默认页面 |
| `FileNotFound.aspx` | 根 | 为 HTTP 错误代码 404 显示的自定义错误页 |
| `UnAuthorized.aspx` | 根 | 为 HTTP 错误代码 403 显示的自定义错误页 |
| `GlobalErrorPage.aspx` | 根 | 为代码中任何其他未处理的错误或其他错误显示的自定义错误页 |
| `Default.aspx` | `Admin` | 代表`Admin`文件夹的默认页面 |

现在从 ro ot 文件夹设计`Default.aspx`，看起来像图 [12-27](#Fig27) 所示的页面。

![A160895_2_En_12_Fig27_HTML.jpg](../Images/A160895_2_En_12_Fig27_HTML.jpg)

图 12-27。

Design of Default.aspx

`Default.` `aspx`包含两个标题为“转到管理文件夹”和“转到不存在的文件”的超链接控件。将这些超链接控件的`NavigateUrl`属性分别设置为`∼/admin/default.aspx`和`∼/notexists.aspx`。注意，我们故意将第二个超链接的`NavigateUrl`设置为一个不存在的文件。现在拖放一个 LinkButton 控件，并将其`Text`属性设置为`Throw Exception`。将清单 [12-28](#Par242) 中所示的代码添加到其`Click`事件处理程序中。

```
protected void LinkButton1_Click(object sender, EventArgs e)
{
  throw new Exception("Unexpected Error");
}
Listing 12-28.Throwing an Exception

```

代码只是抛出一个新的异常。因为这是一个未处理的异常，我们将有机会通过使用自定义错误页面来捕获它。现在在`FileNotFound.aspx`、`UnAuthorized.aspx`和`GlobalErrorPage.aspx`上分别添加一个标签和一个超链接控件。将标签控件的`Text`属性设置为友好的错误信息。将`HyperLink`指向`Default.aspx`，这样用户可以很容易地回到主页。

在`Admin/Default.aspx` Web 表单的`Page_Load`事件中添加清单 [12-29](#Par245) 所示的代码。

```
protected void Page_Load(object sender, EventArgs e)
{
  throw new HttpException(403, "Unauthorized");
}
Listing 12-29.Throwing an HttpException

```

代码引发一个状态代码为 403 的`HttpException`和一个字符串消息。`HttpException`类表示特定于 HTTP 的异常。这样，我们用状态代码 403(未授权访问)触发一个异常。

现在在 IDE 中打开`web.config`，在`<system.web>`部分下添加清单 [12-30](#Par248) 所示的标记。

```
<customErrors mode="On" defaultRedirect="GlobalErrorPage.aspx">
  <error statusCode="403" redirect="∼/UnAuthorized.aspx"/>
  <error statusCode="404" redirect="∼/FileNotFound.aspx"/>
</customErrors>
Listing 12-30.
Specifying

Custom Error Pages

```

`<customErrors>`部分允许您为您的网站指定定制的错误页面。`mode`属性有三个可能的值:

*   如果`mode`为`On`，则所有浏览网站的机器都会启用自定义错误页面。
*   如果`mode`为`Off`，所有机器的自定义错误页面被禁用。
*   如果`mode`是`RemoteOnly`，自定义错误仅对浏览网站的远程机器有效，但对本地浏览器无效。

在开发过程中，通常你的 web 服务器和浏览器会运行在同一台机器上，因此你应该将模式设置为`On`。

`defaultRedirect`属性指向在出现任何应用程序范围内的未处理错误时要显示的网页。

`<customErrors>`部分可以有许多`<error>`标签。`<error>`标签的`statusCode`属性指定了 web 服务器级别的 HTTP 错误代码。`redirect`属性指定在出现错误时显示的网页。在我们的示例中，我们配置了两个自定义错误页面:一个用于状态代码 403 ( `UnAuthorized.aspx`)，另一个用于状态代码 404 ( `FileNotFound.aspx`)。

现在运行`Default.aspx`并一个接一个地点击所有三个链接。您会注意到，这次 ASP.NET 没有显示默认的错误页面，而是显示了在`web.config`中指定的自定义错误页面。图 [12-28](#Fig28) 显示了网站的一个运行示例。

![A160895_2_En_12_Fig28_HTML.jpg](../Images/A160895_2_En_12_Fig28_HTML.jpg)

图 12-28。

Custom erro r page for status c ode 403

## 用 XML 注释记录代码

记录您的源代码是任何专业开发中的常见需求。每个人都知道文档良好的代码的重要性。然而，记录您的源代码只是故事的一部分。通常，您还需要生成应用程序附带的专业帮助文件，供最终用户使用。

创建文档和帮助文件有多种方法。大多数都是手动的，有些人(开发人员或技术人员)需要输入 HTML 或 PDF 格式的帮助文本。然后用一个工具(比如微软 HTML Help Workshop)把源文件编译成一个`.CHM`文件。这意味着存在重复工作。首先，开发人员需要在源代码中编写注释。那么帮助文件中会重复出现相同的信息。

幸运的是。NET Framework 和 Visual Studio 支持一种称为 XML 注释的功能。通过使用这个特性，您可以使用特定的 XML 词汇表向源代码添加注释。稍后，您可以将这些 XML 注释提取到一个单独的 XML 文件中，并将其转换为 HTML 或其他格式。因此，代码的文档化是自动化的，并且避免了重复。

在 C#中，XML 注释由三个正斜杠(`///`)表示。有几个 XML 标签可以在 XML 注释中使用。在接下来的章节中，你将会学到其中的许多。

### 创建类库

首先，您需要创建一个名为`XmlComments.dll`的类库。这个类库代表了一个简单的数学计算器，由一个名为`Calculator`的类组成。`Calculator`类允许你对数字进行加、减、除和乘。虽然这个例子听起来可能太简单了(确实如此)，但是您的目标是学习 XML 注释语法。

在 Visual Studio 中创建新的类库项目。将项目命名为`XmlComments`，将类命名为`Calculator`。将清单 [12-31](#Par263) 中的代码输入到`Calculator`类中。

```
public class Calculator
{
  public int Add(int a, int b)
  {
    return (a + b);
  }
  public int Subtract(int a, int b)
  {
    return (a - b);
  }
  public int Divide(int a, int b)
  {
    return (a / b);
  }
  public int Multiply(int a, int b)
  {
    return (a * b);
  }
}
Listing 12-31.The Calculator Class

```

该类由四种方法组成:`Add()`、`Subtract()`、`Divide()`和`Multiply()`。每个方法都接受两个参数，并对它们执行相应的操作。计算的结果被返回给调用者。现在您已经准备好了这个类，让我们向它添加 XML 文档注释。

#### 记录摘要和备注

为了描述你的类和其中的成员，你可以使用两个标签:`<summary>`和`<remarks>`。`<summary>`标签用来描述一个类型或者它的成员。`<remarks>`标签用于指定关于类型或成员的附加信息，而不是在`<summary>`中指定的信息。清单 [12-32](#Par266) 显示了添加`<summary>`和`<remarks>`标签后的`Calculator`类。

```
/// <summary>
/// This is a class that represents
/// a simple mathematical calculator.
/// </summary>
/// <remarks>
/// This class is developed on .NET Framework 4.7
/// </remarks>
public class Calculator
{
... 

Listing 12-32.Adding <summary> and <remarks>

```

#### 添加段落

摘要或备注可以由多个文本段落组成。每个段落由一个`<para>`标签表示。注意，`<para>`标签总是`<summary>`或`<remarks>`的子元素。清单 [12-33](#Par268) 显示了一个`<para>`标签的使用。

```
/// <summary>
/// This is a class that represents
/// a simple mathematical calculator.

/// <para>

/// You can use it to add, subtract,

/// divide and multiply integers and

/// fractional numbers.

/// </para>

/// </summary>
/// <remarks>
/// This class is developed on .NET Framework 4.7
/// </remarks>

Listing 12-33.Using a <para> Tag

```

#### 记录方法参数和返回值

方法通常带有一个或多个参数。它们也可能向调用者返回一些值。参数由`<param>`标签表示，而返回值由`<return>`标签表示。`<param>`标签有一个属性——`name`——表示参数的名称。清单 [12-34](#Par270) 展示了这两个标签在`Add()`方法中的使用。

```
/// <summary>
/// This method adds two integers.
/// </summary>

/// <param name="a">The first number</param>

/// <param name="b">The second number</param>

/// <returns>An integer representing addition of a and b</returns>

public int Add(int a, int b)
{
  return (a + b);
}
Listing 12-34.Documenting Parameters

and Return Values

```

#### 指定范围和权限

您的类可能包含私有、受保护或公共成员。这些成员的范围可以通过使用`<permission>`标签来表示。`<permission>`标签有一个名为`cref`的属性，它指定给定上下文中成员的名称。清单 [12-35](#Par272) 展示了一个使用`<permission>`标签的例子。

```
/// <summary>
/// This method adds two integers.
/// </summary>
/// <param name="a">The first number</param>
/// <param name="b">The second number</param>
/// <returns>An integer representing addition of a and b</returns>

/// <permission cref="Add">Public method</permission>

public int Add(int a, int b)
{
  return (a + b);
}
Listing 12-35.Using the <permission> Tag

```

#### 指定到其他成员的链接

你可能需要交叉引用你的类的成员。MSDN 图书馆本身就是一个很好的例子。在许多地方，一个类的文档指向另一个相关的类。此外，在文档页面的底部，会出现一个名为“请参阅”的部分。您可以通过使用`<see>`和`<seealso>`标签为您的文档实现同样的事情。`<see>`标签必须用在`<summary>`或`<remarks>`标签内。`<seealso>`标签有一个名为`cref`的属性，它指向另一个成员，可以在`<summary>`标签之外使用。清单 [12-36](#Par274) 举例说明了`<seealso>`标签的使用。

```
/// <summary>
/// This method adds two integers.
/// </summary>
/// <param name="a">The first number</param>
/// <param name="b">The second number</param>
/// <returns>An integer representing addition of a and b</returns>
/// <permission cref="Add">Public method</permission>

/// <seealso cref="Subtract"/>

public int Add(int a, int b)
{
  return (a + b);
}

Listing 12-36.Using the <seealso> Tag

```

#### 添加列表

您的文档可能需要项目符号或编号列表。这可以通过使用三个标签来实现:`<list>`、`<item>`和`<listheader>`。`<item>`和`<listheader>`标签必须出现在`<list>`标签内。`<list>`标签有一个名为`type`的属性，它可以取值为`bullet`、`number`或`table`。标签`<listheader>`的作用是为列表提供一个标题。最后，`<item>`标签封装了列表中的一个条目。清单 [12-37](#Par276) 显示了这些标签的用法。

```
/// <summary>
/// This is a class that represents
/// a simple mathematical calculator.
/// <para>
/// You can use it to add, subtract,
/// divide and multiply integers and
/// fractional numbers.
/// </para>

/// <list type="bullet">

/// <listheader>Supported Operations</listheader>

/// <item>Addition</item>

/// <item>Subtraction</item>

/// <item>Division</item>

/// <item>Multiplication</item>

/// </list>

/// </summary>
/// <remarks>
/// This class is developed on .NET Framework 4.7
/// </remarks>
public class Calculator
{
... 

Listing 12-37.Using the <list>, <item>, and <listheader> Tags

```

#### 从注释生成 XML 文档

要从源代码注释生成 XML 文档，需要打开项目属性对话框(见图 [12-29](#Fig29) )。

![A160895_2_En_12_Fig29_HTML.jpg](../Images/A160895_2_En_12_Fig29_HTML.jpg)

图 12-29。

Generating XML documentation

Build 选项卡的 Output 部分允许您指定是否生成 XML 文档和文件名。将文件名指定为`XmlComments.xml`并构建`XmlComments`类库。作为编译的结果，您将在输出文件夹中得到`XmlComments.dll`和`XmlComments.xml`。图 [12-30](#Fig30) 显示`XmlComments.xml`在浏览器中打开。

![A160895_2_En_12_Fig30_HTML.jpg](../Images/A160895_2_En_12_Fig30_HTML.jpg)

图 12-30。

XmlComments.xml viewed in browser

正如您可能已经猜到的那样，XML 文档很好，但是需要转换成可读性更好的格式，比如 HTML 或帮助文件。在 Visual Studio 中没有内置的方法来做到这一点。生成用户友好的文档文件的一些方法包括:

*   编写将 XML 文档转换为 HTML 的 XSLT 样式表。
*   使用第三方工具读取 XML 注释或 XML 文档文件，并为您生成可读的文档。

在下一节中，您将使用后一种技术从 XML 注释中生成文档。

### 使用 Sandcastle 帮助文件生成器生成帮助文件

Sandcastle Help File Builder (SHFB)是一个从上一节学到的 XML 注释生成文档的工具。这个工具可以在 GitHub 的 [`https://github.com/EWSoftware/SHFB`](https://github.com/EWSoftware/SHFB) 找到。你可以喂任何东西。NET 程序集添加到工具中，并生成以下任何格式的文档:

*   HTML 帮助 1 ( `.chm`)
*   MS 帮助查看器(`.mshc`)
*   打开 XML ( `.docx`)
*   降价(`.md`
*   HTML ( `.htm` / `.html`)

为了使用 SHFB，您必须安装它及其依赖项。安装向导将引导您完成所有步骤。

安装完 SHFB 后，打开它并通过选择文件➤新项目创建一个新的 SHFB 项目。将新创建的项目保存在某个文件夹中。然后右键单击项目浏览器下的文档源，从前面的例子中选择`XmlComments.dll`文件。这样做表明您希望从该程序集生成文档。在这个阶段，你的 SHFB 窗口将如图 [12-31](#Fig31) 所示。

![A160895_2_En_12_Fig31_HTML.jpg](../Images/A160895_2_En_12_Fig31_HTML.jpg)

图 12-31。

Documentation sources added to SHFB

注意文档来源也自动列出了`XmlComments.xml`。从帮助文件格式列表中，选中唯一网站选项。选择此选项将生成 HTML 格式的文档，您可以在任何浏览器中轻松查看。

接下来，从菜单中选择 Documentation ➤构建项目，让工具为您生成文档。一旦生成了文档，您可以转到 SHFB 项目文件夹下的`Help`文件夹，并在任何浏览器中启动`Index.html`。图 [12-32](#Fig32) 显示了为`XmlComments`组件生成的文档。

![A160895_2_En_12_Fig32_HTML.jpg](../Images/A160895_2_En_12_Fig32_HTML.jpg)

图 12-32。

Documentation for the Calculator class

正如你所看到的，SHFB·conv 把你的 XML 注释放进了格式和风格都很好的网页中。尝试使用左边的树导航到文档的各个部分。

## 摘要

那个。NET Framework 不仅允许您使用一系列 XML 技术，而且它本身也在许多地方使用 XML。本章向您介绍了这些领域。

您从 WPF 应用程序开始，那里的用户界面是由 XAML 定义的。您还在 WPF 应用程序的数据网格中显示了来自 XML 文档的数据。

ASP.NET 大量使用 XML 进行服务器控件标记和配置。然后，您了解了应用程序配置文件。具体来说，您学习了存储和检索应用程序配置设置和数据库连接字符串。`web.config`文件是一个存储 ASP.NET 配置信息的 XML 文件。您了解了如何配置网站以使用表单身份验证和会话状态。您还学习了如何配置自定义错误页面来处理网站中的意外错误。

最后，您了解了 XML 注释——一个可以帮助文档生成的特性。您还使用了 Sandcastle 帮助文件生成器(SHFB)将 XML 注释转换成 HTML 文档。