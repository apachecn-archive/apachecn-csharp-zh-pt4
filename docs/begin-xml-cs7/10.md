# 10.WCF 和 Web API 中的 XML

第 9 章向您介绍了 web 服务，您学习了开发基于服务的应用程序。Web 服务基于特定的标准和协议，如 SOAP、XML 和 WSDL。当涉及到开发基于互联网访问的标准服务时，它们是很棒的。然而，有时你的需求是不同的。例如，您可能希望为 intranet 应用程序开发服务，并且出于性能原因希望在 TCP 上使用二进制格式。或者您希望使用一些高度安全的通信机制，这些机制使用一些自定义的加密策略。在这种情况下，Web 服务可能无法满足您的需求。

认识到需要在各种组件技术之间架起一座桥梁，微软开发了众所周知的 Windows 通信基础(WCF)。WCF 是一个通用框架，它为开发面向服务的软件组件提供了一个统一的模型。在 WCF 下，你可以使用同一个软件，不管你是通过互联网还是内部网使用它。您可以首先为 TCP 网络设计和开发您的软件，然后通过 HTTP 使用它。这可以在不改变源代码的情况下实现。我们更感兴趣的是，默认情况下，WCF 使用 XML (SOAP)作为数据传输格式。这意味着在客户端和服务器之间发送的数据是 XML (SOAP)格式的。您还可以自定义对象在网络上的序列化方式。

WCF 是开发服务的通用框架。它需要大量的配置。许多开发人员发现这种配置很乏味。尤其是对于底层通信通道是 HTTP 并且数据传输是以某种基于文本的格式(XML、SOAP、JSON 等)进行的 web 应用程序，WCF 的大量特性集和配置是不必要的。Web API 就是这样产生的。Web API 是构建 RESTful 服务的框架。Web API 框架是专门针对 Web 应用程序和 HTTP 开发的，它为开发人员提供了一个简单的编程模型。

本章向您介绍以下主题:

*   与 WCF 相关的常用术语
*   创建和使用 WCF 服务
*   XML 在 WCF 服务中的作用
*   使用 Web API 创建和消费服务
*   配置 Web API 以使用 XML 格式

Note

本章并不打算教你 WCF 和 Web API 的基础知识。它更关注 XML 如何与这些服务开发框架相关联。如果您不熟悉 WCF 和 Web API，可以考虑从微软的官方文档中学习它们的基础知识。

## 基于运营的服务与基于资源的服务

广义地说，服务可以分为基于操作的服务和基于资源的服务。这是什么意思？考虑一下你在第 9 章中开发的`EmployeeManager` web 服务。您实际上是根据您的需求将方法添加到 web 服务中。在该示例中，您添加了五个方法来实现 CRUD 操作。但是您可以根据自己的需求添加任意数量的组件。稍后，您通过在代理上调用这些方法来调用它们。因此，您显式地调用了服务的操作。这是一个基于运营的服务示例。

基于资源的服务是面向资源的。资源可以是任何东西，比如业务对象、数据库或文件。基于资源的服务允许您对资源执行操作，例如添加资源、更新资源、删除资源和获取资源。因此，基于资源的服务将其自身局限于一个资源。这不同于基于操作的服务，在基于操作的服务中，服务可以自由地做你选择的任何事情。RESTful 服务是基于资源的服务(您将在后面的章节中了解更多关于 REST 的内容)。

开发服务的每种方法都有其优缺点。我们不会在本书中深入探讨这些细节。可以说，WCF 允许您开发两种类型的服务，而 Web API 允许您构建 RESTful 服务。在本章的后面几节中，您将开发这两种服务。您还将观察 XML 在整个画面中的位置。

## 理解 WCF 词汇

在第 9 章中，你学习了 Web 服务描述语言(WSDL)。WSDL 使用端口、消息、服务类型、绑定和服务等术语。WCF 的词汇与 WSDL 相似，但有一些不同。在这一部分，你将学习 WCF 词汇:

*   服务模型:WCF 提供的构建软件组件的模型。
*   通道层:WCF 中处理底层网络编程的部分。来自通道层的类由 WCF 的高级类使用。
*   服务:响应网络通信的软件。服务有一个或多个端点。与服务的通信被重定向到这些端点之一。
*   端点:对服务的实际请求被重定向的地方。端点由地址、绑定和协定组成。
*   地址:只是网络上底层服务的唯一位置。客户端使用这个地址与服务进行对话。地址采用统一资源定位符(URL)的形式—例如，`http://localhost:8000/MyService`。
*   绑定:地址只是一个可以定位服务的 URL。然而，这还不够。您还需要知道用于通信的协议，如 TCP 或 HTTP。这是借助于绑定来指定的。绑定指定了对请求和响应进行编码的协议，以及通过网络传输它们的协议。
*   契约:由服务公开的一组操作。换句话说，契约是在给定端点上可用的一组操作。在代码级别，契约是在接口的帮助下定义的。
*   服务类型:实现协定的类。

## 创建和使用 WCF 服务

要创建和使用 WCF 服务，您基本上需要开发三个软件:

*   一种或多种服务类型
*   发布由网络上的服务类型公开的服务的主机
*   使用服务类型公开的功能的客户端应用程序

WCF 的所有核心功能都可以在`System.ServiceModel.dll`组件中获得。

名称空间包含许多与 WCF 相关的类和属性。因此，您必须引用这个程序集，并在需要时导入`System.ServiceModel`名称空间。在接下来的几节中，您将学习如何开发这三个部分。

### 创建服务

创建 WCF 服务需要以下步骤:

1.  为服务定义一个合同。
2.  实现服务合同。
3.  定义将数据从服务传送到客户端的数据结构(如果有)。

现在，您已经对创建 WCF 服务所涉及的内容有了一个大致的了解，让我们来创建一个服务。

首先创建一个名为`EmployeeWCFService` `(`的 WCF 服务库类型的新项目，见图 [10-1](#Fig1) `)`。

![A160895_2_En_10_Fig1_HTML.jpg](img/.jpg)

图 10-1。

Creating a new WCF service library

然后使用 Add New Item 对话框向项目添加一个接口，并将其命名为`IEmployeeManager`。

Note

默认情况下，创建 WCF 服务库类型的新项目时，Visual Studio 会添加一个用于创建新服务的模板。此外，Visual Studio 的“添加新项”对话框还提供了一个用于添加新 WCF 服务的模板。然而，为了清楚地理解，我不打算使用默认的代码模板。

在接口文件的顶部导入`System.ServiceModel`名称空间，并在接口中添加清单 [10-1](#Par38) 中所示的代码。

```cs
using System;
using System.Collections.Generic;
using System.Text;

using System.ServiceModel;

using System.Data;

namespace EmployeeWCFService
{
  [ServiceContract]

  public interface IEmployeeManager
  {
    [OperationContract]

    List<EmployeeDataContract> SelectAll();

    [OperationContract]

    EmployeeDataContract SelectByID(int id);

    [OperationContract]

    string Update(EmployeeDataContract emp);
  }
}

Listing 10-1.Creating the IEmployeeManager Interface

```

接口就像一个 WCF 契约。`IEmployeeManager`接口定义了三种方法:`SelectAll()`、`SelectByID()`和`Update()`。实现后的`SelectAll()`方法将从 Northwind 数据库的`Employees`表中返回所有雇员的列表。实现后的`SelectByID()`方法将返回特定雇员的详细信息。本节稍后将定义和解释`EmployeeDataContract`类。注意关于`IEmployeeManager` WCF 合同的两件事:

*   接口必须用`[ServiceContract]`属性来修饰。该属性指示由其修饰的接口是 WCF 服务协定。
*   接口中的每个方法签名都必须标记有`[OperationContract]`属性，这表明由其修饰的方法将作为服务的一部分公开。方法在 WCF 被称为操作。

在您定义了一个契约之后，您需要实现它。您可以通过创建一个实现协定接口的类来实现这一点。除了实现服务契约之外，您不需要对服务类型做任何特殊的事情。

在我们的例子中，`EmployeeDataContract`类用于从服务向客户端传送雇员的详细信息。这是服务的数据契约。因此，将`EmployeeDataContract`类添加到项目中。还要添加一个对`System.Runtime.Serialization`组件的引用。然后在`EmployeeDataContract`类的顶部导入`System.ServiceModel`和`System.Runtime.Serialization`名称空间。清单 [10-2](#Par44) 显示了组成`Employee`类的完整代码。

```cs
using System;
using System.Collections.Generic;
using System.Text;

using System.ServiceModel;

using System.Runtime.Serialization;

using System.Data;

namespace EmployeeWCFService
{
    [DataContract]

    public class EmployeeDataContract
    {
        [DataMember]

        public int EmployeeID { get; set; }
        [DataMember]

        public string LastName { get; set; }
        [DataMember]

        public string FirstName { get; set; }
        [DataMember]

        public string HomePhone { get; set; }
        [DataMember]

        public string Notes { get; set; }
    }
}

Listing 10-2.The EmployeeDataContract Class

```

`EmployeeDataContra` `ct`类由五个公共属性组成:`EmployeeID`、`FirstName`、`LastName, HomePhone`和`Notes`。注意这个类是如何用`[DataContract]`属性标记的，而单个属性是如何用`[DataMember]`属性标记的。这样，类及其状态信息被序列化到客户端。每当您想从您的服务方法中返回定制对象时，您需要用`[DataContract]`属性标记这样的类。此外，将被传输到客户机的类的每个成员必须用`[DataMember]`属性标记。您可能会注意到,`[DataContract]`属性的使用类似于`[Serializable]`属性。

Note

您会发现这段代码很熟悉，因为在学习 XML 序列化时，您在第 [8](08.html) 章中使用了`[DataContract]`和`[DataMember]`属性。

`EmployeeDataContract` s 隐含定义了`EmployeeManager`服务所需的数据契约。但是，您需要编写从 Northwind 数据库获取数据的代码。当然，您可以使用简单的 ADO.NET 代码来完成这项任务。但是为了节省时间和代码，我们将首先使用实体框架代码。要生成 EF 模型和上下文，在名为`Models`的项目根目录中添加一个新文件夹，右键单击它并打开添加新项对话框。然后在数据部分下，选择 ADO.NET 实体数据模型(图 [10-2](#Fig2) )。

![A160895_2_En_10_Fig2_HTML.jpg](img/.jpg)

图 10-2。

Adding ADO.NET Entity D ata Model

命名和型号为 Northwind，然后单击添加。这将启动一个向导。首先从数据库选项中选择代码(图 [10-3](#Fig3) )，然后按照向导生成上下文和实体类。

![A160895_2_En_10_Fig3_HTML.jpg](img/.jpg)

图 10-3。

Generating a model using the code-first approach

成功运行向导会将`Northwind.cs`和`Employee.cs`文件添加到`Models`文件夹中。前一个文件包含上下文类，而后一个文件包含`Employee`实体类。因为这些类是自动生成的，所以这里不讨论它们。

创建该服务的最后一步是在名为`EmployeeManager`的类中实现服务契约。清单 [10-3](#Par51) 显示了`EmployeeService`类的完整代码。

```cs
public class EmployeeManager:IEmployeeManager
{
    public List<EmployeeDataContract> SelectAll()
    {
        using (Northwind db = new Northwind())
        {
            var query = from e in db.Employees
                        orderby e.EmployeeID ascending
                        select new EmployeeDataContract()
                        {
                            EmployeeID = e.EmployeeID,
                            FirstName = e.FirstName,
                            LastName = e.LastName,
                            HomePhone = e.HomePhone,
                            Notes = e.Notes
                        };
            return query.ToList();
        }
    }

    public EmployeeDataContract SelectByID(int id)
    {
        using (Northwind db = new Northwind())
        {
            var query = from e in db.Employees
                        where e.EmployeeID == id
                        select new EmployeeDataContract()
                        {
                            EmployeeID = e.EmployeeID,
                            FirstName = e.FirstName,
                            LastName = e.LastName,
                            HomePhone = e.HomePhone,
                            Notes = e.Notes
                        };
            return query.SingleOrDefault();
        }
    }

    public string Update(EmployeeDataContract emp)
    {
        using (Northwind db = new Northwind())
        {
            Employee existing = db.Employees.Find(emp.EmployeeID);
            existing.FirstName = emp.FirstName;
            existing.LastName = emp.LastName;
            existing.HomePhone = emp.HomePhone;
            existing.Notes = emp.Notes;
            db.SaveChanges();
            return "Employee modified successfully!";
        }
    } }

Listing 10-3.The EmployeeService Class

```

`EmployeeManager`类实现了`IEmployeeManager`接口。`SelectAll()`方法用所有雇员填充一个列表，并将它返回给调用者。注意，`SelectAll()`方法需要返回`EmployeeDataContract`对象。这是通过使用 LINQ 到实体查询将数据从`Employee`对象映射到`EmployeeDataContract`对象来完成的。

`SelectByID()`方法接受一个雇员 ID。然后，它使用 LINQ 实体查询从数据库中获取该员工的详细信息。然后将`EmployeeDataContract`对象返回给调用者。

`Update()`方法接受一个`EmployeeDataContract`对象。在内部，它根据 EmployeeID 找到一个现有的雇员。然后使用来自`EmployeeDataContract`的值修改现有雇员的属性。`SaveChanges()`方法保存对数据库的更改。一条消息被发送回调用者，表明该雇员已被成功修改。

编译`EmployeeWCFService`项目以产生`EmployeeWCFService.dll`组件。

### 托管服务

现在您已经创建了服务类型，是时候考虑托管它了。托管服务将使其在网络上可用，以便客户端应用程序可以使用它。要托管服务，您有多种选择。其中一些包括:

*   创建一个控制台应用程序，并将其用作主机。
*   在 IIS 中承载 WCF 服务。
*   在 Windows 服务应用程序中承载 WCF 服务。

在这个例子中，我们使用一个控制台应用程序作为主机。在后面的小节中，您将学习使用 IIS 来托管 WCF 服务。

在与服务相同的解决方案中添加一个控制台应用程序类型的新项目，并将其命名为`EmployeeWCFServiceHost`。见图 [10-4](#Fig4) 。

![A160895_2_En_10_Fig4_HTML.jpg](img/.jpg)

图 10-4。

Creating a console application to host the WCF service

添加对`System.ServiceModel`和`EmployeeWCFService`组件的引用。新创建的控制台应用程序项目已经包含了一个`App.config`文件。在 Visual Studio 编辑器中打开`App.config`文件，并在`<configuration>`根元素中输入清单 [10-4](#Par63) 所示的标记。

```cs
<system.serviceModel>
  <services>
    <service name="EmployeeWCFService.EmployeeManager"
             behaviorConfiguration="EmployeeWCFServiceBehavior">
      <endpoint address="EmployeeManager"
                binding="basicHttpBinding"
                contract="EmployeeWCFService.IEmployeeManager">
      </endpoint>
    </service>
  </services>
  <behaviors>
    <serviceBehaviors>
      <behavior name="EmployeeWCFServiceBehavior">
        <serviceMetadata httpGetEnabled="True"/>
        <serviceDebug includeExceptionDetailInFaults="true" />
      </behavior>
    </serviceBehaviors>
  </behaviors>
</system.serviceModel>
Listing 10-4.Configuring the Service

```

配置文件的`<system.serviceModel>`部分包含所有与托管 WCF 服务相关的配置设置。有两个子部分:`<services>`和`<behaviors>`。

前者包含一个或多个服务在名称、端点和地址方面的配置信息。后者包含关于在`<services>`部分中定义的服务所展示的行为的配置信息。行为是修改或扩展服务或客户端功能的类。它还可以修改频道设置。

来自`<services>`部分的每个服务通过`<service>`部分配置:

*   `name`属性指定服务类型的完全限定名(在我们的例子中是`EmployeeWCFService.EmployeeManager`)。
*   `behaviorConfiguration`属性指向在`<serviceBehaviors>`部分定义的服务行为的名称。
*   `<endpoint>`元素详细描述了服务可用的一个或多个端点。
*   元素的属性指定了服务的地址。
*   `binding`属性指定用于通信的协议。两个常用的绑定是用于 TCP 的`net.tcp`和用于 HTTP 的`basicHttpBinding`。还提供了其他几种绑定，如`netMsmqBinding`、`netNamedPipeBinding`等。
*   最后，`contract`属性指定了提供服务契约的接口的完全限定名(在我们的例子中是`IEmployeeManager`)。

在我们的例子中，我们为基于 HTTP 的通信创建了一个端点。

`<serviceBehaviors>`部分包含一个或多个`<behavior>`元素:

*   元素的属性指定了该行为的名称。该名称用于`<service>`元素的`behaviorConfiguration`属性中。
*   `<serviceMetadata>`元素表示可以通过使用 HTTP `GET`请求来检索服务的元数据。您会发现这个特性类似于 web 服务，在 web 服务中，您通过使用一个查询字符串(即一个`GET`请求)来检索 WSDL。

现在打开控制台应用程序的`Main()`方法，输入清单 [10-5](#Par78) 所示的代码。

```cs
static void Main(string[] args)
{
    try
    {
        Type t = typeof(EmployeeManager);
        Uri http = new Uri("http://localhost:8000/EmployeeWCFService");
        ServiceHost host = new ServiceHost(t, tcp, http);
        host.Open();
        Console.WriteLine("Employee Manager Service Published.");
        Console.ReadLine();
        host.Close();
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
        Console.ReadLine();
    }
}

Listing 10-5.Hosting the WCF Service

```

代码通过使用`typeof()`表达式检索服务类型类的`Type`。然后，它创建一个`Uri`类的实例，指向基于 HTTP 的 URL，服务将被发布到这个 URL。请注意端口号是如何设置为 8000 的。您可以使用任何端口号，但要确保它没有被任何其他应用程序使用，并且没有在网络上被阻止。

然后创建一个`ServiceHost`类的实例。`ServiceHost`类通过在指定的 URIs 发布服务类型来托管服务。注意，`ServiceHost`类的构造函数接受 URIs 的参数数组。在我们的示例中，我们已经传递了两个，但是如果您愿意，您可以传递更多。下面的构造函数签名将清楚地表明这一点:

```cs
public ServiceHost (Type serviceType, params Uri[] baseAddresses)
{
  ...
}

```

然后调用`ServiceHost`类的`Open()`方法。该方法实际上根据配置信息来托管服务。只要宿主应用程序处于活动状态，服务就会保持发布状态。这就是为什么调用了`Console`类的`ReadLine()`方法。它使应用程序保持活动状态，直到用户按下回车键。最后，调用`ServiceHost`类的`Close()`方法。这就完成了宿主应用程序。

Note

在开发过程中，您还可以使用 Visual Studio 内置的 WCF 服务宿主，完全跳过宿主应用程序。然而，为了清楚地理解所涉及的所有步骤，我们不会在这个例子中使用内置主机。

### 消费服务

在本节中，您将创建一个客户端应用程序，它使用我们之前创建的`EmployeeWCFService`。首先，你需要创建一个名为`EmployeeWCFServiceClient`的 Windows 应用程序，如图 [10-5](#Fig5) 所示。

![A160895_2_En_10_Fig5_HTML.jpg](img/.jpg)

图 10-5。

The client consuming the WCF service

该应用程序由一个列表框组成，其中包含所有雇员的列表。单击特定员工将在下方的文本框中显示他们的详细信息。您可以更改名字、姓氏、家庭电话和注释等详细信息。单击更新按钮将保存对数据库的更改。还会使用标签向用户显示一条成功消息。

在使用服务之前，您应该为它创建一个代理。运行您之前开发的服务宿主应用程序(确保从 Visual Studio 外部运行该应用程序，以便您可以完成下一步)。然后右击客户端应用程序项目，并选择“添加服务引用”菜单选项。这将打开一个如图 [10-6](#Fig6) 所示的对话框。

![A160895_2_En_10_Fig6_HTML.jpg](img/.jpg)

图 10-6。

Adding a service reference

输入 WCF 服务的 HTTP 端点地址(即`http://localhost:8000/EmployeeWCFService`)和`EmployeeWCFServiceReference`作为代理类的名称空间名称。

这将为服务创建一个服务引用。添加到项目中的所有服务引用都会在解决方案浏览器中列出，如图 [10-7](#Fig7) 所示。

![A160895_2_En_10_Fig7_HTML.jpg](img/.jpg)

图 10-7。

Service reference as shown in the Solution Explorer

添加服务引用还会在客户端的应用程序配置文件中添加一些标记。现在，您可以从客户端代码调用服务。清单 [10-6](#Par90) 显示了表单的`Load`事件处理程序。

```cs
private string endPoint = "BasicHttpBinding_IEmployeeManager";

private void Form1_Load(object sender, EventArgs e)
{
    EmployeeManagerClient proxy = new EmployeeManagerClient(endPoint);
    EmployeeDataContract[] data = proxy.SelectAll();
    foreach(EmployeeDataContract emp in data)
    {
        comboBox1.Items.Add(emp.EmployeeID);
    }
  proxy.Close();
}

Listing 10-6.
Retrieving

the List of Employees

```

代码声明了一个局部变量—endpoint—来存储服务端点的名称。您可以从客户端的应用程序配置文件中找出端点配置名称。

然后，代码创建代理类的新实例。注意代理类是如何命名的`XXXXClient`(在我们的例子中是`EmployeeManagerClient`)，其中`XXXX`是原始服务类的名称。在代理类的构造函数中，传递所需的端点配置名。

然后，代码调用代理对象上的`SelectAll()`方法来检索所有雇员的详细信息。注意，在代理上调用的`SelectAll()`方法返回了一组`EmployeeDataContract`对象。然后一个`foreach`循环将`EmployeeIDs`填充到组合框中。最后，通过调用代理的`Close()`方法关闭底层通信通道。

当用户单击组合框中列出的任何雇员时，该雇员的详细信息将显示在其他文本框中。这是在组合框的`SelectedIndexChanged`事件处理程序中完成的(参见清单 [10-7](#Par95) )。

```cs
private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
{
    EmployeeManagerClient proxy = new EmployeeManagerClient(endPoint);
    EmployeeDataContract data = proxy.SelectByID((int)comboBox1.SelectedItem);
    textBox1.Text = data.FirstName;
    textBox2.Text = data.LastName;
    textBox3.Text = data.HomePhone;
    textBox4.Text = data.Notes;
    label6.Text = "";
    proxy.Close();
}
Listing 10-7.Retrieving the Details of an Employee

```

代码与您之前看到的非常相似。这一次，它通过传递选中的`EmployeeID`来调用代理上的`SelectByID()`方法。`SelectByID()`方法返回一个填充了所需细节的`EmployeeDataContract`对象。详细信息如`EmployeeID`、`FirstName`、`LastName, HomePhone`和`Notes`将显示在各自的文本框中。

一旦员工的详细信息显示在文本框中，您就可以对其进行更改，然后单击 Update 将其保存到数据库中。更新按钮的`Click`事件处理程序如清单 [10-8](#Par98) 所示。

```cs
private void button1_Click(object sender, EventArgs e)
{
    EmployeeManagerClient proxy = new EmployeeManagerClient(endPoint);
    EmployeeDataContract data = new EmployeeDataContract();
    data.EmployeeID = (int)comboBox1.SelectedItem;
    data.FirstName = textBox1.Text;
    data.LastName = textBox2.Text;
    data.HomePhone = textBox3.Text;
    data.Notes = textBox4.Text;
    label6.Text=proxy.Update(data);
    proxy.Close();
}
Listing 10-8.Saving the Modifications

to the Database

```

代码很简单——它像以前一样创建一个代理对象。这一次，它还创建了一个新的`EmployeeDataContract`对象，并用修改后的雇员详细信息填充它。然后调用代理的`Update()`方法，试图保存对数据库的更改。一个标签控件显示由`Update()`方法返回的成功消息。

### 测试主机和客户端

既然您已经编写了所有三个部分(服务、主机和客户机)，让我们测试它们。首先，编译解决方案中的所有项目。然后运行主机控制台应用程序。如果一切顺利，您应该会看到如图 [10-8](#Fig8) 所示的命令提示符。

![A160895_2_En_10_Fig8_HTML.jpg](img/.jpg)

图 10-8。

Running the host application

接下来打开浏览器，在地址栏中输入服务端点的 URL(`http:// localhost:8000/EmployeeWCFService`)。你应该得到一个如图 [10-9](#Fig9) 所示的网页。

![A160895_2_En_10_Fig9_HTML.jpg](img/.jpg)

图 10-9。

Testing to see whether the service is hosted properly

如果您看到此页面，则服务被正确托管。点击网页顶部指定的 URL，应该会看到服务的 WSDL，如图 [10-10](#Fig10) 所示。

![A160895_2_En_10_Fig10_HTML.jpg](img/.jpg)

图 10-10。

WSDL of the service

您会发现这种机制非常类似于 web 服务，在 web 服务中，您只需通过指定`wsdl`查询字符串参数来检索 web 服务的 WSDL。

现在运行客户端应用程序，您应该会看到组合框中填充了所有员工的列表。单击单个员工姓名，他们的详细信息将显示在各个文本框中。还要测试在单击 Update 按钮后，对员工详细信息的任何修改是否保存在数据库中。

### 在 IIS 中托管 WCF 服务

在前面的例子中，我们使用了一个控制台应用程序来托管我们的服务。但是，您也可以使用 IIS(或 Visual Studio 开发 web 服务器)来承载 WCF 服务。这样，当 IIS 应用程序启动时，您的服务会自动启动，并且您还可以为您的服务获得 IIS 的所有安全功能。

首先，向当前解决方案添加一个新的 ASP.NET Web 应用程序项目(参见图 [10-11](#Fig11) )。

![A160895_2_En_10_Fig11_HTML.jpg](img/.jpg)

图 10-11。

Adding a new ASP.NET web application

创建项目时，选择空的项目模板，如图 [10-12](#Fig12) 所示。

![A160895_2_En_10_Fig12_HTML.jpg](img/.jpg)

图 10-12。

Project based on the Empty template

这样，您将拥有一个只有基本项目条目的项目，比如`web.config`。接下来，像在前面的例子中一样，添加对`EmployeeWCFService`程序集的引用。现在，使用添加新项目对话框向项目添加一个新的 WCF 服务(参见图 [10-13](#Fig13) )。

![A160895_2_En_10_Fig13_HTML.jpg](img/.jpg)

图 10-13。

Adding a new WCF service

这将向项目添加一个新的`.svc`文件及其代码隐藏。`.svc`文件包含关于被公开的 WCF 服务的信息。您可以删除代码隐藏文件，因为我们的服务已经捆绑在一个程序集中。

然后在 Visual Studio 文本编辑器中打开`EmployeeManager.svc`文件。你会发现`.svc`文件包含了`@ServiceHost`指令。修改该指令，如清单 [10-9](#Par111) 所示。

```cs
<%@ServiceHost Service="EmployeeWCFService.EmployeeManager" %>
Listing 10-9.Adding the ServiceHost

Directive

```

`@ServiceHost`指令表明该文件是一个 WCF 服务主机。`Service`属性指定服务类型的完全限定名。现在向网站添加一个`web.config`文件，并键入清单 [10-10](#Par113) 中所示的标记。

```cs
<system.serviceModel>
  <services>
    <service name="EmployeeWCFService.EmployeeManager"
             behaviorConfiguration="EmployeeWCFServiceBehavior">
      <endpoint address=""

                binding="basicHttpBinding"

                contract="EmployeeWCFService.IEmployeeManager">

      </endpoint>
    </service>
  </services>
  <behaviors>
    <serviceBehaviors>
      <behavior name="EmployeeWCFServiceBehavior">
        <serviceMetadata httpGetEnabled="True"/>
        <serviceDebug includeExceptionDetailInFaults="true" />
      </behavior>
    </serviceBehaviors>
  </behaviors>
</system.serviceModel>
Listing 10-10.Configuring the Host

```

它本质上与您为控制台主机指定的标记相同。唯一的区别是`<endpoint>`元素的`address`属性是一个空字符串。这是因为对于 IIS 托管的服务，该地址与托管该服务的`.svc`文件的 URI 相同

要访问 IIS 中托管的`EmployeeService`，端点 URL 将是`http://localhost:49303/EmployeeManager.svc`(更改端口号以匹配您的端口号)。注意到 URL 指向了`.svc`文件。您还可以附加`wsdl`查询字符串参数来提取它的 WSDL。图 [10-14](#Fig14) 显示了在浏览器中运行`.svc`文件的示例。

![A160895_2_En_10_Fig14_HTML.jpg](img/.jpg)

图 10-14。

Navigating to the .svc file in a browser

您可以将这个 URL 提供给代理生成器，代理就会自动生成。代理创建和调用服务的整个过程与上一个示例中的相同。

## 理解 XML 在 WCF 服务中的作用

从您到目前为止所学的内容来看，很明显 WCF 使用 XML 来配置各种服务。然而，故事还没完。

在您刚刚开发的示例中，来自`EmployeeManager`服务的雇员数据神奇地出现在客户端应用程序中。然而，这是怎么回事呢？数据是如何在电线上传送的？就基本的 HTTP 绑定而言，数据在网络上被序列化为 SOAP 消息。这意味着 XML 数据以 SOAP 信封的形式被发送到客户端。

Note

基于 SOAP 的通信由于其庞大的特性会导致性能下降。然而，当互操作性对您的应用程序更重要时，SOAP 是一个自然的选择。WCF 还允许你在 TCP 上使用二进制通信。这种通信可以为您的应用程序带来性能优势。对这些细节的讨论超出了本书的范围。

为了理解刚才所说的内容，请转到 EmployeeWCFService 项目并按 F5。这样做将打开 WCF 测试客户端，如图 [10-15](#Fig15) 所示。

![A160895_2_En_10_Fig15_HTML.jpg](img/.jpg)

图 10-15。

Observing a message in WCF test client

WCF 测试客户端允许您调用服务方法。在左侧，双击`SelectAll()`方法。然后单击面板右侧的 Invoke 按钮。这将调用该方法，并将返回所有的`EmployeeDataContract`对象。切换到 XML 选项卡，您将看到 SOAP 请求和 SOAP 响应消息。

对于 WCF RESTful 服务(您将在后面的章节中了解到)，数据被序列化为普通的 XML 而不是 SOAP 消息。

### 使用 XmlSerializer 而不是 DataContractSerializer

WCF 框架在序列化 XML 数据时可以使用两种方法:

*   默认情况下，WCF 使用`DataContractSerializer`类(`XmlObjectSerializer)`的一个实现)来序列化 XML 数据。你已经在第 8 章中学习了`DataContractSerializer`职业。
*   您还可以指示 WCF 使用`XmlSerializer`进行 XML 序列化。这样做可以让您更好地控制数据的序列化方式。您可以通过使用各种属性来定制序列化过程，例如`[XmlAttribute]`和`[XmlElement]`。你已经在第 8 章[中学习了`XmlSerializer`职业。](08.html)

要指示 WCF 框架应该使用`XmlSerializer`而不是`DataContractSerializer`，您需要做的就是用`[XmlSerializerFormat]`属性装饰服务契约接口。应用`[XmlSerializerFormat]`属性后的`IEmployeeManager`界面如清单 [10-11](#Par127) 所示。

```cs
[ServiceContract]
[XmlSerializerFormat]
public interface IEmployeeManager
{
  ....
  ....
}
Listing 10-11.Applying the [XmlSerializerFormat] Attribute

```

## 了解 REST 服务

到目前为止，我们讨论的 WCF 服务都是基于操作的，因为您总是显式地调用服务的特定方法或操作。现代 web 应用程序经常创建和使用 RESTful 服务。从我们之前的讨论中，您知道 REST 服务是基于资源的服务。虽然这一章并不试图教你 REST 服务的基本原理，但是简短的讨论 REST 是值得的。

REST 代表代表性状态转移。休息不是标准；这是构建服务的一种方式。与使用简单对象访问协议(SOAP)和 web 服务描述语言(WSDL)等协议和标准的 ASMX web 服务或基于 WCF 操作的服务不同，RESTful 服务利用了 HTTP 的简单性和强大功能。

以下是 RESTful 服务的一些基本特征:

*   REST 服务使用 HTTP 协议。
*   REST 服务发出 HTTP 请求(使用有意义的 HTTP 动词，如`GET`、`POST`、`PUT`和`DELETE`)来获取和提交数据。
*   REST 服务本质上是无状态的。
*   REST 将服务公开为可通过 URL 访问和发现的资源。
*   REST 服务通常以 JSON 或 XML 格式传输数据。

至于。NET 框架认为有两种方法可以创建 RESTful 服务——WCF REST 服务和 Web API。如今，对于 web 应用程序来说，使用 JSON (JavaScript Object Notation)作为服务和客户端之间的数据传输格式更为常见，但是您也可以使用 XML。当然，我们的兴趣是看看 XML 如何与这些框架一起使用。

HTTP 动词如`GET`、`POST`、`PUT`和`DELETE`表示对资源执行的期望动作。如果服务在数据库上执行创建、读取、更新和删除(CRUD)操作，您可以使用`POST`来表示`INSERT`操作，`GET`来表示`SELECT`操作，`PUT`来表示`UPDATE`操作，`DELETE`来表示`DELETE`操作。然而，仅仅使用一个特定的动词不会强制一个特定类型的操作。在服务中实现这些动词取决于应用程序的需求。

现在您已经了解了什么是 REST 服务，您将看到如何创建它们，首先使用 WCF，然后使用 Web API。

## 使用 WCF 创建 REST 服务

使用 WCF 创建 RESTful 服务需要您熟悉的相同步骤。然而，两个主要变化是:

*   因为 REST 服务使用 HTTP 动词来调用方法，所以您使用`webHttpBinding`。在 IIS 或 web 服务器中托管这样的服务也很常见(如前所述)。
*   HTTP 动词和服务方法之间的映射在服务契约中指定。

除了这些变化之外，服务的其余部分或多或少与以前相同。

首先，基于空项目模板创建一个新的 ASP.NET Web 应用程序。正如您对`EmployeeWCFService`项目所做的，添加一个`Models`文件夹并生成实体框架上下文和实体类(`Employee`)。还像以前一样加`EmployeeDataContract`级。

接下来，向项目添加一个接口— `IEmployeeManager`。完成的`IEmployeeManager`接口如清单 [10-12](#Par145) 所示。

```cs
[ServiceContract]
public interface IEmployeeManager
{
    [OperationContract]
    [WebGet(UriTemplate = "/employees",

            ResponseFormat =WebMessageFormat.Xml)]

    List<EmployeeDataContract> SelectAll();

    [OperationContract]
    [WebGet(UriTemplate = "/employees/{id}",

          ResponseFormat = WebMessageFormat.Xml)]

    EmployeeDataContract SelectByID(string id);

    [OperationContract]
    [WebInvoke(Method = "POST",

               UriTemplate = "/employees",

               RequestFormat =WebMessageFormat.Xml ,

               ResponseFormat = WebMessageFormat.Xml)]

    string Insert(EmployeeDataContract emp);

    [OperationContract]
    [WebInvoke(Method = "PUT",

               UriTemplate = "/employees/{id}",

               RequestFormat =WebMessageFormat.Xml,

               ResponseFormat = WebMessageFormat.Xml)]

    string Update(string id,EmployeeDataContract emp);

    [OperationContract]
    [WebInvoke(Method = "DELETE",

               UriTemplate = "/employees/{id}",

               ResponseFormat = WebMessageFormat.Xml)]

    string Delete(string id);
}

Listing 10-12.IEmployeeManager Interface

```

仔细观察`IEmployeeManager`界面。它看起来与前面的例子非常相似，但是多了一些操作。现在总共有五个操作——`SelectAll()`、`SelectByID()`、`Insert()`、`Update()`和`Delete()`。

这些操作用`[OperationContract]`属性来修饰。此外，它们具有`[WebGet]`或`[WebInvoke]`属性。这些属性来自`System.ServiceModel.Web`名称空间，表明 WCF 服务遵循 REST 编程模型。

`[WebGet]`属性表示`SelectAll()`和`SelectByID()`是检索操作。`[WebInvoke]`属性表示`Insert()`、`Update()`、`and Delete()`为调用操作。

`[WebGet]`和`[WebInvoke]`的属性配置 REST 服务。下面讨论这些属性:

*   `Method`:`Method`属性表示调用操作的 HTTP 动词。常见的动词有`GET`、`POST`、`PUT`、`DELETE`。
*   `UriTemplate`:表示用于调用方法的端点 URL 的模板。比如`http://localhost/employees`或者`http://localhost/employees/1`。注意 EmployeeID 是如何使用`{id}`语法参数化的。这个`id`值被认为是一个字符串，因此所有底层操作都将`id`参数指定为字符串类型。
*   `RequestFormat`:表示请求所附数据的格式。可能的值是`Xml`和`Json` ( `WebMessageFormat`枚举)。
*   `ResponseFormat`:表示响应附带的数据的格式。可能的值是`Xml`和`Json` ( `WebMessageFormat`枚举)。

现在`IEmployeeManager`接口已经准备好了，向名为`EmployeeManager.svc`的项目添加一个 WCF 服务。`.svc`文件的代码隐藏文件将包含`EmployeeManager`类。这个类像以前一样实现了`IEmployeeManager`接口。清单 [10-13](#Par155) 显示了`EmployeeManager`类的完整代码。

```cs
public class EmployeeManager:IEmployeeManager
{
    public List<EmployeeDataContract> SelectAll()
    {
        using (Northwind db = new Northwind())
        {
            var query = from e in db.Employees
                        orderby e.EmployeeID ascending
                        select new EmployeeDataContract()
                        {
                            EmployeeID = e.EmployeeID,
                            FirstName = e.FirstName,
                            LastName = e.LastName,
                            HomePhone = e.HomePhone,
                            Notes = e.Notes
                        };
            return query.ToList();
        }
    }

    public EmployeeDataContract SelectByID(string id)
    {
        using (Northwind db = new Northwind())
        {
            int empId = int.Parse(id);
            var query = from e in db.Employees
                        where e.EmployeeID == empId
                        select new EmployeeDataContract()
                        {
                            EmployeeID = e.EmployeeID,
                            FirstName = e.FirstName,
                            LastName = e.LastName,
                            HomePhone = e.HomePhone,
                            Notes = e.Notes
                        };
            return query.SingleOrDefault();
        }
    }

    public string Insert(EmployeeDataContract obj)
    {
        using (Northwind db = new Northwind())
        {
            Employee emp = new Employee();
            Emp.EmployeeID = obj.EmployeeID;
            emp.FirstName = emp.FirstName;
            emp.LastName = emp.LastName;
            emp.HomePhone = emp.HomePhone;
            emp.Notes = emp.Notes;
            db.Employees.Add(emp);
            db.SaveChanges();
            return "Employee added successfully!";
        }
    }

    public string Update(string id,EmployeeDataContract obj)
    {
        using (Northwind db = new Northwind())
        {
            Employee emp = db.Employees.Find(int.Parse(id));
            emp.FirstName = obj.FirstName;
            emp.LastName = obj.LastName;
            emp.HomePhone = obj.HomePhone;
            emp.Notes = obj.Notes;
            db.SaveChanges();
            return "Employee modified successfully!";
        }
    }

    public string Delete(string id)
    {
        using (Northwind db = new Northwind())
        {
            Employee emp = db.Employees.Find(int.Parse(id));
            db.Employees.Remove(emp);
            db.SaveChanges();
            return "Employee deleted successfully!";
        }
    }
}

Listing 10-13.EmployeeManager Class Implements IEmployeeManager

```

您应该对这个实现很熟悉，因为`SelectAll()`、`SelectByID()`和`Update()`与前面的例子非常相似。

`Insert()`方法接受一个新的`EmployeeDataContract`对象，并从中构造一个新的雇员。然后，它将新创建的雇员添加到`Employees DbSet`中。`SaveChanges()`方法将数据保存到数据库中。

`Delete()`方法接受一个要删除的 EmployeeID。在内部，它找到那个雇员，并使用`Remove()`方法将他们从`Employees DbSet`中移除。`SaveChanges()`方法保存对数据库的更改。

现在，打开`web.config`文件并添加清单 [10-14](#Par160) 中所示的配置。

```cs
<system.serviceModel>
  <services>
    <service name="EmployeeWCFServiceREST.EmployeeManager"
             behaviorConfiguration="EmployeeWCFServiceRESTBehavior">
      <endpoint address=""
                binding="webHttpBinding"
                contract="EmployeeWCFServiceREST.IEmployeeManager"
                behaviorConfiguration="web">
      </endpoint>
    </service>
  </services>

  <behaviors>
    <serviceBehaviors>
      <behavior name="EmployeeWCFServiceRESTBehavior">
        <serviceMetadata httpGetEnabled="true" httpsGetEnabled="true" />
        <serviceDebug includeExceptionDetailInFaults="false" />
      </behavior>
      <behavior>
        <serviceMetadata httpGetEnabled="true" httpsGetEnabled="true" />
        <serviceDebug includeExceptionDetailInFaults="false" />
      </behavior>
    </serviceBehaviors>
    <endpointBehaviors>
      <behavior name="web">
        <webHttp/>
      </behavior>
    </endpointBehaviors>
  </behaviors>

</system.serviceModel>

Listing 10-14.Configuring of the EmployeeManager Service

```

这种配置与您在前面的主机应用程序中使用的配置非常相似。主要区别是它使用了`webHttpBinding`绑定而不是`basicHttpBinding`。

这就完成了 EmployeeManager REST 服务。现在是时候从客户端应用程序使用它了。

### 创建使用 EmployeeManager REST 服务的客户端

使用 EmployeeManager REST 服务的客户端应用程序将是一个 Windows 窗体应用程序。该应用如图 [10-16](#Fig16) 所示。

![A160895_2_En_10_Fig16_HTML.jpg](img/.jpg)

图 10-16。

Client application consuming the REST service

客户端应用程序看起来与您在前面的示例中开发的非常相似。但是现在它多了两个按钮——插入和删除——用于调用相应的操作。输入除 EmployeeID 之外的新雇员的详细信息，然后单击 Insert 按钮添加该雇员。因为 EmployeeID 是一个标识列，所以不需要在用户界面中指定它。从组合框中选择一个 EmployeeID，然后单击 Delete 按钮删除该雇员。从插入、更新和删除操作返回的成功消息显示在按钮下方的标签控件中。

尽管客户端应用程序的用户界面类似于前面的示例，但内部工作方式完全不同。以前，您在客户机应用程序中创建了一个代理，然后在代理上调用所需的方法。这没什么，因为这项服务是基于运营的。现在，这个客户端应用程序想要使用 REST 服务。这里，HTTP 动词决定调用服务的什么方法。因此，不需要生成代理。相反，这个应用程序将使用来自`System.Net.Http`名称空间的`HttpClient`组件。让我们看看怎么做。

表单的`Load`事件处理程序如清单 [10-15](#Par167) 所示。

```cs
private HttpClient client;

private void Form1_Load(object sender, EventArgs e)
{
    client = new HttpClient();
    client.BaseAddress = new Uri("http://localhost:49833");
    client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/xml"));
    HttpResponseMessage response = client.GetAsync("/EmployeeManager.svc/employees").Result;

    string xmlData = response.Content.ReadAsStringAsync().Result;
    XmlDocument doc = new XmlDocument();
    doc.LoadXml(xmlData);
    XmlNodeList list = doc.GetElementsByTagName("EmployeeID");
    foreach(XmlNode item in list)
    {
        comboBox1.Items.Add(item.InnerText);
    }
}

Listing 10-15.Getting Employee Data When the Form Loads

```

代码声明了一个用于调用 REST 服务的`HttpClient`变量——client。因为我们想从多个地方调用服务，所以这个对象是在表单级别创建的，而不是事件处理程序的一个局部变量。

`Load`事件处理程序实例化`HttpClient`,并将其`BaseAddress`属性设置为 REST 服务所在的基本 URL。在我们的例子中，这是我们添加了`EmployeeManager.svc`文件的 web 应用程序的 URL。确保根据您的设置更改端口号。您可以通过查看。`svc`浏览器中的文件。

下一行将`Accept`头添加到`DefaultRequestHeaders`集合中。`application/xml`的`Accept`头值意味着服务应该以 XML 格式返回数据。

然后代码调用服务的`SelectAll()`。请注意，没有提到操作名称。代码使用了`HttpClient`对象的`GetAsync()`方法，并指定了服务的端点 URL。回想一下`IEmployeeManager`指定了这个`UriTemplate`。`GetAsync()`方法使用`GET`动词发出请求。`HttpClient`的所有方法本质上都是异步的。访问`Result`属性会阻塞当前线程，直到方法完成。

`GetAsync()`方法返回`HttpResponseMessage`—一个包装实际返回值的对象。要获取实际值，可以使用`ReadAsStringAsync()`方法。`ReadAsStringAsync()`方法返回 REST 服务返回的数据的 XML 表示。这个 XML 片段然后被加载到一个`XmlDocument`中。因为我们想用 EmployeeID 值填充组合框，所以使用`GetElementsByTagName()`方法检索所有的`<EmployeeID>`元素。一个`foreach`循环遍历检索到的元素，并根据需要填充组合框。

如果您在 Visual Studio 的快速观察窗口中观察`xmlData`字符串变量，您将看到如清单 [10-16](#Par174) 所示的 XML 标记。

```cs
<ArrayOfEmployeeDataContract  xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
<EmployeeDataContract>
<EmployeeID>1</EmployeeID>
<FirstName>Nancy</FirstName>
<HomePhone>(206) 555-9857</HomePhone>
<LastName>Davolio</LastName>
<Notes>Education includes a BA in psychology from Colorado State University in 1970\.  She also completed "The Art of the Cold Call."  Nancy is a member of Toastmasters International.</Notes>
</EmployeeDataContract>
....
....
</ArrayOfEmployeeDataContract>
Listing 10-16.REST Service Returns Data in XML Format

```

Note

这里我们使用由 WCF REST 服务返回的原始 XML。如果需要，可以将这个 XML 数据加载到客户机应用程序中的 Employee/EmployeeDataContract 对象中(需要在客户机应用程序中创建这些类)。这样，客户端应用程序可以根据需要处理这些对象。我们在这里不会这样做，因为我们的主要兴趣是了解这些框架如何使用 XML 数据格式。

好了，现在让我们看看如何在组合框的`SelectedIndexChanged`事件处理程序中调用`SelectByID()`(参见清单 [10-17](#Par177) )。

```cs
private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
{
    HttpResponseMessage response = client.GetAsync("/EmployeeManager.svc/employees/" + comboBox1.SelectedItem).Result;

    string xmlData = response.Content.ReadAsStringAsync().Result;
    XmlDocument doc = new XmlDocument();
    doc.LoadXml(xmlData);
    textBox1.Text = doc.GetElementsByTagName("FirstName")[0].InnerText;
    textBox2.Text = doc.GetElementsByTagName("LastName")[0].InnerText;
    textBox3.Text = doc.GetElementsByTagName("HomePhone")[0].InnerText;
    textBox4.Text = doc.GetElementsByTagName("Notes")[0].InnerText;
    label6.Text = "";
}
Listing 10-17.Calling the SelectByID() Method

```

这段代码类似于前面的清单。然而，`GetAsync()`方法也在 URL 中传递一个 EmployeeID。这个 REST 服务的方法`SelectByID()`被调用。剩下的代码只是读取返回的 XML 数据，并用 FirstName、LastName、HomePhone 和 Notes 值填充各个文本框。

插入按钮的`Click`事件处理程序负责调用 REST 服务的`Insert()`方法。该事件处理程序如清单 [10-18](#Par180) 所示。

```cs
private void button1_Click(object sender, EventArgs e)
{
    string xmlEmp = $"<EmployeeDataContract xmlns='http://schemas.datacontract.org/2004/07/EmployeeWCFServiceREST' xmlns:i='http://www.w3.org/2001/XMLSchema-instance'><FirstName>{textBox1.Text}</FirstName><HomePhone>{textBox3.Text}</HomePhone><LastName>{textBox2.Text}</LastName><Notes>{textBox4.Text}</Notes></EmployeeDataContract>";

    HttpContent content = new StringContent(xmlEmp, Encoding.UTF8, "application/xml");

    HttpResponseMessage response = client.PostAsync("/EmployeeManager.svc/employees", content).Result;

    string xmlMsg = response.Content.ReadAsStringAsync().Result;

    XmlDocument doc = new XmlDocument();
    doc.LoadXml(xmlMsg);
    label6.Text = doc.DocumentElement.InnerText;

}

Listing 10-18.Calling the Insert() Method of the REST Service

```

我们已经将 REST 服务配置为对请求和响应使用 XML 格式。在添加雇员时，我们首先需要形成一个表示一个`EmployeeDataContract`对象的 XML 片段。这是通过创建如下所示的 XML 片段来完成的。这个 XML 片段基本上创建了一个包含四个子元素的`<EmployeeDataContract></EmployeeDataContract>`元素，这四个子元素是`<FirstName>`、`<LastName>`、`<HomePhone>`和<、T5。这些子元素的值是从各自的文本框中设置的。如您所见，根元素的名称与数据契约类的名称相匹配，子元素的名称与数据成员的名称相对应。

然后，XML 片段被包装在一个`StringContent`对象中。然后调用`HttpClient`的`PostAsync()`方法。`PostAsync()`方法向指定的服务发出一个`POST`请求。包含雇员详细信息的`StringContent`对象也伴随着请求。

服务的`Insert()`方法返回成功消息。该消息使用`ReadAsStringAsync()`方法从`HttpResponseMessage`解包。然后，此消息显示在标签控件中。

更新按钮的`Client`事件处理程序类似，如清单 [10-19](#Par185) 所示。

```cs
private void button2_Click(object sender, EventArgs e)
{
    string xmlEmp = $"<EmployeeDataContract xmlns='http://schemas.datacontract.org/2004/07/EmployeeWCFServiceREST' xmlns:i='http://www.w3.org/2001/XMLSchema-instance'><EmployeeID>{comboBox1.SelectedItem}</EmployeeID><FirstName>{textBox1.Text}</FirstName><HomePhone>{textBox3.Text}</HomePhone><LastName>{textBox2.Text}</LastName><Notes>{textBox4.Text}</Notes></EmployeeDataContract>";

    HttpContent content = new StringContent(xmlEmp, Encoding.UTF8, "application/xml");

    HttpResponseMessage response = client.PutAsync("/EmployeeManager.svc/employees/" + comboBox1.SelectedItem, content).Result;

    string xmlMsg = response.Content.ReadAsStringAsync().Result;

    XmlDocument doc = new XmlDocument();
    doc.LoadXml(xmlMsg);
    label6.Text = doc.DocumentElement.InnerText;
}

Listing 10-19.Calling the Update() Method

of the REST Service

```

这里的主要区别是已经调用了`HttpClient`的`PutAsync()`方法。这样做会向服务发出一个`PUT`请求。请求 URL 还包括要修改的 EmployeeID。

最后，删除按钮的`Click`事件处理程序负责调用服务的`Delete()`方法，如清单 [10-20](#Par188) 所示。

```cs
private void button3_Click(object sender, EventArgs e)
{
    HttpResponseMessage response = client.DeleteAsync("/EmployeeManager.svc/employees/" + comboBox1.SelectedItem).Result;

    string xmlMsg = response.Content.ReadAsStringAsync().Result;
    XmlDocument doc = new XmlDocument();
    doc.LoadXml(xmlMsg);
    label6.Text = doc.DocumentElement.InnerText;
}
Listing 10-20.Calling Delete() Method of the REST Service

```

这里，代码调用了`HttpClient`的`DeleteAsync(`方法。要删除的 EmployeeID 作为 URL 的一部分传递。

这就完成了客户端应用程序。运行客户端，查看组合框中是否填充了现有的 EmployeeID 值。还可以尝试添加、修改和删除雇员，以确认 EmployeeManager REST 服务的工作情况。

## 使用 Web API 创建 REST 服务

现在您已经知道了使用 WCF 创建 REST 服务需要什么，让我们看看如何使用 Web API 来实现这个目的。在本节中，您将创建一个 Web API 服务，该服务公开 CRUD 功能，就像您在上一节中创建的 WCF 服务一样。然后，基于 Windows 窗体的客户端应用程序使用该服务。

首先，基于 Web API 项目模板创建一个新的 ASP.NET we b 应用程序(见图 [10-17](#Fig17) )。

![A160895_2_En_10_Fig17_HTML.jpg](img/.jpg)

图 10-17。

Creating a project based on Web API template

新创建的项目包含一个 Web API 服务。将服务(文件和类)重命名为`EmployeeManagerController`。接下来，为 Northwind 数据库的`Employees`表生成实体框架模型，就像您在前面的例子中所做的那样。

在 Visual Studio 编辑器中打开`EmployeeManagerController`。你会注意到`EmployeeManagerController`类继承自`ApiController`。然后在`EmployeeManagerController`中编写执行 CRUD 操作的动作。这些动作的框架如清单 [10-21](#Par195) 所示。

```cs
public class EmployeeManagerController : ApiController
{
    [HttpGet]
    public List<Employee> SelectAll()
    {
    }

    [HttpGet]
    public Employee SelectByID(int id)
    {
    }

    [HttpPost]
    public string Insert(Employee obj)
    {
    }

    [HttpPut]
    public string Update(int id, Employee obj)
    {
    }

    [HttpDelete]
    public string Delete(int id)
    {
    }
}

Listing 10-21.Skeleton of the Web API Service

```

总共有五种方法— `SelectAll()`、`SelectByID()`、`Insert()`、`Update()`、`Delete()`。这些方法对您来说应该很熟悉，因为 WCF REST 服务也有它们。但是有一些不同之处:

*   Web API 服务使用`Employee`对象。我们在这里没有创建正式的数据契约。如果需要的话，你可以这样做，但是在 Web API 中，你不需要像`[DataContract]`和`[DataMember]`这样的属性。
*   Web API 动作由某些属性修饰，这些属性将它们映射到 HTTP 动词。例如，添加在`Insert()`动作之上的`[HttpPost]`表示`POST`请求将被映射到`Insert()`动作。如果遵循默认的命名约定，就可以避免用这些属性来修饰操作——操作名称以它处理的 HTTP 谓词开始。例如，`Get()`自动映射到`GET`动词，`Post()`自动映射到`POST`动词，等等。

这些操作的内部代码非常类似于 EmployeeManager WCF 服务。所以，这里就不一一讨论了。为了清楚起见，在清单 [10-22](#Par200) 中只显示了`SelectAll()`和`Post()`。

```cs
[HttpGet]
public List<Employee> SelectAll()
{
    using (Northwind db = new Northwind())
    {
        var query = from e in db.Employees
                    orderby e.EmployeeID ascending
                    select e;
        return query.ToList();
    }
}

[HttpPost]
public string Insert(Employee obj)
{
    using (Northwind db = new Northwind())
    {
        Employee emp = db.Employees.Find(obj.EmployeeID);
        emp.FirstName = emp.FirstName;
        emp.LastName = emp.LastName;
        emp.HomePhone = emp.HomePhone;
        emp.Notes = emp.Notes;
        db.Employees.Add(emp);
        db.SaveChanges();
        return "Employee added successfully!";
    }

}

Listing 10-22.The SelectAll() and Post() Web API Actions

```

与 WCF 不同，Web API 不需要向`web.config`添加任何主机配置。这就是 Web API 提供的简单编程模型的好处。

### 创建使用 EmployeeManager Web API 服务的客户端

使用 Web API 的客户端应用程序与您之前创建的 WCF 客户端应用程序非常相似，如图 [10-18](#Fig18) 所示。

![A160895_2_En_10_Fig18_HTML.jpg](img/.jpg)

图 10-18。

Client application that calls the Web API

虽然客户端应用程序与您之前开发的非常相似，但是有两个不同之处:

*   REST 服务的端点 URL 现在将会改变，并将遵循 Web API 约定。
*   由于 Web API 现在返回并接受`Employee`对象，从客户端接收和发送的 XML 数据将被包装在一个`<Employee>`元素中。

为了理解这些变化是如何反映在代码中的，清单 [10-23](#Par207) 显示了表单的`Load`事件处理程序。

```cs
private void Form1_Load(object sender, EventArgs e)
{
    client = new HttpClient();
    client.BaseAddress = new Uri("http://localhost:49443");

    client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/xml"));

    HttpResponseMessage response = client.GetAsync("/api/EmployeeManager").Result;

    string xmlData = response.Content.ReadAsStringAsync().Result;

    XmlDocument doc = new XmlDocument();
    doc.LoadXml(xmlData);

    XmlNodeList list = doc.GetElementsByTagName("EmployeeID");
    foreach(XmlNode item in list)
    {
        comboBox1.Items.Add(item.InnerText);
    }

}

Listing 10-23.Load Event Handler 

Receives Employee Objects in XML Format

```

请注意用粗体标记的行。`BaseAddress`属性现在指向 Web API 应用程序的地址。您应该根据您的设置更改端口号。

第二个粗体行指定了 Web API 的 URL。请注意，URL 采用了`/api/<api_controller>`的形式。该模式来自 Web API 的默认路径，您可以在 Web API 项目的`WebApiConfig.cs`文件中更改它。

如果您观察从 Web API 返回的`xmlData`,您应该会看到类似这样的内容:

```cs
<ArrayOfEmployee xmlns:i="http://www.w3.org/2001/XMLSchema-instance" >
<Employee>
  <EmployeeID>1</EmployeeID>
  <FirstName>Nancy</FirstName>
  <HomePhone>(206) 555-9857</HomePhone>
  <LastName>Davolio</LastName>
  <Notes>Education includes a BA in psychology from Colorado State University in 1970\. She also completed "The Art of the Cold Call." Nancy is a member of Toastmasters International.</Notes>
</Employee>
....
</ArrayOfEmployee>

```

如您所见，雇员的详细信息现在包装在一个`<Employee>`元素中。

这也意味着在`POST`和`PUT`操作期间，您应该发送包装在`<Employee>`元素中的数据。例如，考虑清单 [10-24](#Par214) 中所示的代码，它显示了更新按钮的`Click`事件处理程序。

```cs
private void button2_Click(object sender, EventArgs e)
{
    string xmlEmp = $"<Employee xmlns='http://schemas.datacontract.org/2004/07/EmployeeWebAPIService.Models' xmlns:i='http://www.w3.org/2001/XMLSchema-instance'><EmployeeID>{comboBox1.SelectedItem}</EmployeeID><FirstName>{textBox1.Text}</FirstName><HomePhone>{textBox3.Text}</HomePhone><LastName>{textBox2.Text}</LastName><Notes>{textBox4.Text}</Notes></Employee>";

    HttpContent content = new StringContent(xmlEmp, Encoding.UTF8, "application/xml");
    HttpResponseMessage response = client.PutAsync("/api/EmployeeManager/" + comboBox1.SelectedItem, content).Result;
    string xmlMsg = response.Content.ReadAsStringAsync().Result;
    XmlDocument doc = new XmlDocument();
    doc.LoadXml(xmlMsg);
    label6.Text = doc.DocumentElement.InnerText;
}

Listing 10-24.Calling PutAsync() to Modify an Employee

```

修改后的雇员详细信息现在与名称空间详细信息一起包装在`<Employee>`元素中。

这里不讨论其他事件处理程序，因为它们与前面的例子非常相似。只要注意这些差异，并自己完成它们(或者从书中的源代码中获取它们)。

一旦客户端应用程序准备就绪，运行应用程序并测试 CRUD 操作是否按预期工作。

### 使用 XmlSerializer 而不是 DataContractSerializer

就像 WCF 服务一样，Web API 也使用`DataContractSerializer`来执行 XML 序列化。如果您想使用`XmlSerializer`来代替，您需要相应地配置 Web API。

要配置 Web API 使用`XmlSerializer`而不是`DataContractSerializer`，从`App_Start`文件夹中打开`WebApiConfig.cs`文件。然后添加清单 [10-25](#Par220) 中所示的代码。

```cs
public static void Register(HttpConfiguration config)
{
    config.MapHttpAttributeRoutes();
    config.Formatters.XmlFormatter.UseXmlSerializer = true;

    config.Routes.MapHttpRoute(
        name: "DefaultApi",
        routeTemplate: "api/{controller}/{id}",
        defaults: new { id = RouteParameter.Optional }
    );
}
Listing 10-25.Configuring Web API to Use XmlSerializer

```

注意粗体显示的代码。将`XmlFormatter` ( `XmlFormatter`是`XmlMediaTypeFormatter`的对象)的`UseXmlSerializer`属性设置为`true`。因为 Web API 现在被配置为使用`XmlSerializer`，所以在向 Web API 发送数据时，您不再需要指定那些数据契约 XML 名称空间。

## 摘要

本章向您介绍了两个服务开发框架——Windows Communication Foundation(WCF)和 Web API。WCF 允许你开发基于操作和基于资源的休息服务。另一方面，Web API 允许您构建基于资源的 REST 服务。WCF 和 Web API 可以处理各种数据格式，尽管 JSON 和 XML 目前非常流行。我们的兴趣是看看如何使用这些框架以 XML 格式发送和接收数据。

创建基于操作的 WCF 服务包括三个部分——服务、主机和客户端应用程序。客户端应用程序为调用其操作的服务生成一个代理。WCF 使用 XML 配置来配置服务。此外，WCF 使用 SOAP 消息通过 HTTP 传递数据。

使用 WCF 和 Web API 创建 REST 服务包括两部分——服务和客户端应用程序。这两种框架都可以使用 XML 格式通过网络传输数据。客户端应用程序不创建任何代理，而是使用`HttpClient`直接调用服务。访问 REST 服务返回的 XML 数据的一个简单方法是将其加载到`XmlDocument`中。