# 5.验证 XML 文档

在第 [2](02.html) 、 [3](03.html) 和 [4](04.html) 章中，您学习了如何读写 XML 文档，尽管我们总是假设源 XML 文档中包含的 XML 结构(标记名、属性名、嵌套等等)是正确的。然而，在许多实际情况下，这种假设可能并不正确。例如，采购订单应用程序可能接受来自不同客户的 XML 格式的订单。如何保证每个提交的订单都符合商定的 XML 结构？如果有人偏离了商定的结构怎么办？这就是 XML 模式的用武之地。

XML 架构描述了 XML 文档的结构；打个比方，它们的作用与数据库模式相同。例如，数据库表的模式告诉您它有哪些列，它们的数据类型是什么，它们是否可以包含 NULL，等等。XML Schema 对 XML 文档做类似的事情。在模式的帮助下，您可以做以下重要的事情:

*   您可以为 XML 文档定义元数据——元素、属性、类型等等。
*   您可以基于该模式创建 XML 文档。
*   您可以根据模式验证 XML 文档。

在本章中，您将了解以下内容:

*   定义 XML 文档结构的各种方法
*   什么是 XML 模式
*   如何创建 XML 模式
*   如何根据模式验证 XML 文档
*   如何使用架构对象模型(SOM)以编程方式创建架构

## 为 XML 文档提供结构

如前所述，XML 模式定义了 XML 文档的结构。换句话说，它提供了一个由元数据组成的模板，用于创建和验证 XML 文档。然而，模式并不是为 XML 文档提供结构的唯一方式。那个。NET Framework 支持三种定义 XML 结构的方式:

*   文档类型定义(DTD)
*   XML 数据简化(XDR)架构
*   XML 架构定义(XSD)架构

### 文档类型定义(DTD)

dtd 是表示 XML 结构的一种较老的方法，但是它们仍然在使用。它们是 W3C 标准，旧的应用程序依赖它们进行验证。DTD 从可接受的标记名、可接受的属性名等方面定义了 XML 文档的整体结构。XML 文档作者在创建文档时使用 DTD。验证文档时也可以使用相同的 DTD。您应该避免在现代应用程序中使用 dtd，因为它们有很多缺点:

*   它们使用非 XML 语法。
*   它们很难创造，也很难理解。
*   您需要专门学习 DTD 语法。
*   它们是不可扩展的。
*   它们不支持数据类型。
*   它们不支持名称空间。

### XML 数据简化(XDR)架构

当 XSD 模式提案(接下来讨论)正在考虑中时，微软继续前进并创建了它的实现，称为 XML 数据简化，或 XDR，模式规范。但是，XDR 架构规范和 XSD 架构规范并不相同。为了向后兼容，微软在。NET 框架。如果要为 XML 文档创建新的模式，应该使用 XSD 模式规范，而不是 XDR。

### XML 架构定义(XSD)架构

XSD 模式规范或 XML 模式是为定义 XML 结构提供标准化的努力的结果。XSD 规范是 W3C 的推荐标准。XSD 的主要优点之一是它支持数据类型。XSD 本身就是一个 XML 文档，克服了 DTD 的大部分限制。如果要为 XML 文档构建新的模式，应该使用 XSD 而不是 DTD 或 XDR 标准来创建它们。XSD 在很大程度上取代了 DTD 和其他定义 XML 文档元数据的方法。

## 为 XML 文档创建结构

现在您已经知道了定义 XML 结构的可能方法，让我们来看看每种方法的用法。在本节中，您将使用 DTD 和 XSD 标准为同一个`Employees.xml`文档创建一个正式的结构。因为 XDR 现在被认为是一个过时的标准，所以我在这里就不涉及 XDR 了。

### 雇员. xml 的结构

您已经知道了`Employees.xml`文件的样子。我们的目的是通过使用 DTD 和 XSD 标准来定义文档的结构，以便您可以在以后验证文档。`Employees.xml`的结构如下:

*   根元素必须是`<employees>`。
*   根元素可以包含零个或多个`<employee>`元素。
*   元素必须有一个名为`employeeid`的属性。
*   `<employee>`元素必须包含`<firstname>`、`<lastname>`、`<homephone>`和`<notes>`子元素。
*   `<firstname>`、`<lastname>`和`<homephone>`元素包含纯文本值。
*   `<notes>`元素包含字符数据(`CDATA`)。
*   `<firstname>`、`<lastname>`、`<homephone>`和`<notes>`子元素必须以相同的顺序出现。

记住前面的要求，让我们首先创建 DTD，然后创建 XSD。

### 创建 DTD

在本节中，您将学习如何创建一个 DTD 来表示`Employees.xml`文件的结构。清单 [5-1](#Par36) 显示了文档的完整 DTD。

```cs
<!ELEMENT employees (employee*)>
<!ELEMENT employee (firstname,lastname,homephone,notes)>
<!ELEMENT firstname (#PCDATA)>
<!ELEMENT lastname (#PCDATA)>
<!ELEMENT homephone (#PCDATA)>
<!ELEMENT notes (#PCDATA)>
<!ATTLIST employee employeeid CDATA #REQUIRED>
Listing 5-1.DTD for Employees.xml

```

DTD 将 XML 文档的根元素定义为`<employees>`。这是通过使用`<!ELEMENT>`声明来完成的，它指定了元素的名称(在我们的例子中是`employees`)和可以放入其中的内容。在我们的例子中，`<employees>`元素可以接受零个或多个`<employee>`元素，而不能接受任何其他元素或文本。这个约束是通过将可接受的元素名(在我们的例子中是`employee`)放在括号中来实现的。星号(`*`)表示零个或多个`<employee>`元素可以放在一个`<employees>`元素中。和`*`类似，也可以用加号(`+`)和问号(`?`)。`+`操作符表示该元素可以出现一次或多次，而`?`表示该元素是可选的。

接下来，我们通过使用相同的`<!ELEMENT>`声明来定义`<employee>`元素。因为`<employee>`元素必须包含`<firstname>`、`<lastname>`、`<homephone>`和`<notes>`子元素，所以它们被指定为逗号分隔的列表。逗号分隔的元素列表必须按指定的顺序出现。如果希望元素以任意顺序出现，可以使用竖线(`|`)字符代替逗号。

然后，文档定义了`<employee>`元素的每个子元素。为了表明这些元素包含普通字符数据而没有其他子元素，我们使用了`#PCDATA`，它代表普通字符数据。因此，DTD 强制要求`<firstname>`、`<lastname>`、`<homephone>`和`<notes>`元素只能包含普通字符数据，不能包含标记或子元素。如果我们的元素包含字符数据和子元素，我们可以使用`ANY`而不是`#PCDATA`。同样，如果我们的元素是空的(也就是说，它们既不包含字符数据也不包含子元素)，我们可以使用`EMPTY`。

最后，DTD 通过使用`<!ATTLIST>`声明为`<employee>`元素定义了`employeeid`属性。`<!ATTLIST>`声明接受属性被定义的元素，后面是属性列表。标记中的`CDATA`表示属性值包含字符数据。通过将属性的类型指定为`ID`，可以将属性标记为唯一标识符。声明中的`#REQUIRED`表示该属性是强制的，必须在文档中提供。

Note

回想一下，在第 [2](02.html) 章中，我们使用了`XmlDocument`类的`GetElementById()`方法。这个方法要求要搜索的元素应该有一个类型为`ID`的属性。

要创建 DTD，可以使用 Visual Studio IDE。添加一个新的文本文件，但将其命名为`Employees.dtd`。键入清单 [5-1](#Par36) 中所示的全部标记并保存文件。在 Visual Studio IDE 中打开`Employees.xml`，并在顶部添加一个`DOCTYPE`声明，如清单 [5-2](#Par43) 所示。

```cs
<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE employees SYSTEM "employees.dtd">

<employees>
  <employee employeeid="1">
    <firstname>Nancy</firstname>
    ...
Listing 5-2.Attaching the DTD to an XML Document

```

如您所见，在 XML 文件的顶部，我们放入了`<!DOCTYPE>`声明。`<!DOCTYPE>`声明用于将 DTD 附加到 XML 文件中。`<!DOCTYPE>`声明后面紧跟着`<employees>`——文档的根元素。`SYSTEM`标识符指定了为这个 XML 文档提供结构的 DTD 文件的 URI。在我们的例子中，它是`employees.dtd`(假设 XML 文档和 DTD 在同一个文件夹中)。

Note

就像`SYSTEM`标识符一样，还有一个`PUBLIC`标识符，用于指定一个众所周知的公共模式，可以被许多应用程序使用。另一方面，`SYSTEM`标识符用于指定特定于应用程序的模式(例如，在我们的例子中是`employees.dtd`)。

您可能想知道为什么我们在 Visual Studio 中创建 DTD。除了提供 IntelliSense，帮助不大吧？但是在你下结论之前先等一下，因为它还能提供更多的东西。现在在您的项目中添加一个新的 XML 文件，然后添加清单 [5-2](#Par43) 中所示的`<!DOCTYPE>`声明。当您开始创建文档时，您会发现 IDE 在 IntelliSense 中显示了各种元素和属性。图 [5-1](#Fig1) 显示了智能感知的样子。

IDE 还会在您键入时验证您的文档。如果您输入违反 DTD 规则的标记或属性，它会显示错误消息。

![A160895_2_En_5_Fig1_HTML.jpg](img/.jpg)

图 5-1。

Visual Studio IntelliSense for DTDs

### 创建 XML 模式

在本节中，您将学习如何通过三种方式创建 XSD 模式:

*   使用 Visual Studio IDE 创建 XML 架构
*   使用 Visual Studio IDE 从现有 XML 文档创建 XML 架构
*   使用`xsd.exe`命令行工具(通常称为 XML 模式定义工具)创建 XML 模式

XML 模式通常存储在扩展名为`.xsd`的文件中。一个模式由不同的部分组成，其中一些在表 [5-1](#Tab1) 中列出。

表 5-1。

Parts of an XSD Schema

<colgroup><col> <col></colgroup> 
| 零件名称 | 描述 |
| --- | --- |
| 元素 | 表示单个元素。 |
| 属性 | 表示元素的单个属性。 |
| 属性组 | 表示可以在复杂类型中进一步使用的一组属性。 |
| 单纯型精神分裂症 | 简单类型只包含文本值，不包含子元素，例如字符串、数字、日期等。元素和属性都可以是简单类型。 |
| 复数型 | 复杂类型由一个或多个简单类型组成。只有元素可以是复杂类型。 |

与 dtd 相比，XSD 模式的一个关键优势是它们支持数据类型。这些数据类型与。NET 框架的数据类型；因此，XSD 数据类型可以由它们在。NET 框架。表 [5-2](#Tab2) 列出了一些常见的 XSD 数据类型及其。净对应。

表 5-2。

XSD Data Types

<colgroup><col> <col> <col></colgroup> 
| XSD 数据类型 | 。网络数据类型 | 描述 |
| --- | --- | --- |
| `Boolean` | `System.Boolean` | 表示布尔值(`true`或`false`) |
| `Byte` | `System.SByte` | 表示 8 位有符号整数(字节) |
| `dateTime` | `System.DateTime` | 表示日期和时间 |
| `decimal` | `System.Decimal` | 表示十进制数 |
| `Double` | `System.Double` | 表示双精度数 |
| `Float` | `System.Single` | 表示单精度浮点数 |
| `Int` | `System.Int32` | 表示 4 字节有符号整数 |
| `Long` | `System.Int64` | 表示 8 字节有符号整数 |
| `String` | `System.String` | 表示字符串数据 |

现在，您已经对 XSD 模式、其组成部分和数据类型有了一个简单的了解，我们将通过使用所描述的各种方法来创建 XSD 模式。

#### 员工的 XSD . XML

要创建任何 XML 模式，首先需要考虑其中的简单类型、复杂类型、元素和属性。让我们为`Employees.xml`文件做这个练习。

我们将为`Employees.xml`创建三个简单的类型:

*   `NameSimpleType`:这个简单类型表示我们的 XML 文档中使用的名字(名和姓)。它对名称进行了限制:最小长度必须是 3，最大长度必须小于 255。
*   `PhoneSimpleType`:这个简单的类型表示电话号码(我们的 XML 文档的`<homephone>`元素)。它限制电话号码不超过 20 个字符。
*   `NotesSimpleType`:这个简单的类型表示 notes(我们文档中的`<notes>`元素)。它限制输入的注释长度不超过 500 个字符。

这三个简单类型将组成一个名为`EmployeeType`的复杂类型。`EmployeeType`复杂类型包括以下内容:

*   名为`<firstname>`的元素，属于简单类型`NameSimpleType`
*   名为`<lastname>`的元素，它是简单类型`NameSimpleType`
*   名为`<homephone>`的元素，它是简单类型`PhoneSimpleType`
*   名为`<notes>`的元素，它是简单类型`NotesSimpleType`
*   名为`employeeid`的必需属性，其类型为`int`

最后，我们将有一个名为`<employees>`的元素，它将包含零个或多个名为`<employee>`的子元素。`<employee>`子元素将是复杂类型`EmployeeType`。

#### 在 Visual Studio 设计器中创建 XSD

在 Visual Studio 中创建 XML 架构很容易，因为 IDE 提供了创建、编辑和浏览 XML 架构的可视化工具。若要创建新的 XML 架构，需要使用“添加新项”对话框向项目中添加一个。将新的模式文件命名为`Employees.xsd`。图 [5-2](#Fig2) 显示了带有相关选择的添加新项目对话框。

![A160895_2_En_5_Fig2_HTML.jpg](img/.jpg)

图 5-2。

Adding a new XML Schema to your project

添加 XML 架构后，您将看到 XML 架构设计器或 XSD 设计器。XSD 设计器如图 [5-3](#Fig3) 所示。

![A160895_2_En_5_Fig3_HTML.jpg](img/.jpg)

图 5-3。

The XSD Designer of Visual Studio

如图 [5-3](#Fig3) 所示，XSD 设计器由 XML Schema Explorer 和一些视图组成。为了编辑模式，它还链接到 XML 编辑器。让我们快速了解一下每种方法的用途:

*   XML Schema Explorer:XML Schema Explorer 呈现了模式的树结构。然后，您可以浏览、导航和查找节点。
*   XML 编辑器:XML 编辑器是创建和编辑 XSD 的地方。因为 XSD 本身就是一个 XML 文档，所以您用来创建 XML 文档的那个 XML 编辑器也可以用来创建 XSD。
*   开始视图:开始视图就像一个主页，只允许您切换到其他视图或模式浏览器。
*   内容模型视图:内容模型视图允许您以图形方式查看模式节点及其部分，例如简单类型、复杂类型、元素和属性。
*   图形视图:图形视图允许您以图形方式查看模式节点及其关系，以便于可视化和理解。

Note

对 XSD 设计师的详细介绍超出了本书的范围。MSDN 文档包含这里提到的每个部分的详细解释。对于我们的目的，XML 编辑器就足够了。

现在您已经添加了`Employees.xsd`，在 XSD 设计器的开始视图中点击 XML 编辑器选项。这将打开 XML 编辑器，如图 [5-4](#Fig4) 所示。

![A160895_2_En_5_Fig4_HTML.jpg](img/.jpg)

图 5-4。

XML Editor ready for creating an XSD

现在，在 XML 编辑器中编写清单 [5-3](#Par78) 中的标记。

```cs
<?xml version="1.0" encoding="utf-8"?>
<xs:schema attributeFormDefault="unqualified"
elementFormDefault="qualified"
xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="employees">
  <xs:complexType>
    <xs:sequence>
      <xs:element name="employee" type="EmployeeType" minOccurs="0"
                  maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>
  </xs:element>
  <xs:complexType name="EmployeeType">

    <xs:all>
      <xs:element name="firstname" type="NameSimpleType" />
      <xs:element name="notes" type="NotesSimpleType" />
      <xs:element name="lastname" type="NameSimpleType" />
      <xs:element name="homephone" type="PhoneSimpleType" />
    </xs:all>
    <xs:attribute name="employeeid" type="xs:int" use="required" />
  </xs:complexType>
  <xs:simpleType name="NameSimpleType">

    <xs:restriction base="xs:string">
      <xs:minLength value="3" />
      <xs:maxLength value="255" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="PhoneSimpleType">
    <xs:restriction base="xs:string">
      <xs:maxLength value="20" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="NotesSimpleType">

    <xs:restriction base="xs:string">
      <xs:maxLength value="500" />
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
Listing 5-3.XML Schema for Employees.xml

```

模式声明以`<schema>`标签开始。XML 名称空间`http://` [`www.w3.org/2001/XMLSchema`](http://www.w3.org/2001/XMLSchema) 是必需的，表示这是一个 XML 模式。属性`xmlns`指定这个模式的所有标签的名称空间前缀将是`xs`。

然后模式通过使用`<element>`标签声明`<employees>`元素。`<employees>`元素包含名为`<employee>`的子元素，它们属于复杂类型`EmployeeType`。复杂类型由`<complexType>`元素表示。分别由`minOccurs`和`maxOccurs`属性定义的`<employee>`子元素可以出现零个或多个。注意使用了`unbounded`关键字来表示可以存在任意数量的元素。

接下来，该模式通过使用`<complexType>`元素定义了一个名为`EmployeeType`的复杂类型。`<complexType>`的`name`属性表示正在定义的复杂类型的名称。`EmployeeType`复杂类型由四个子元素和一个属性组成。元素是通过使用`<element>`标签及其两个属性`name`和`type`来声明的。`name`属性指定元素的名称，而`type`属性指示元素的数据类型。

属性是通过使用`<attribute>`标签来声明的。`<attribute>`元素的`name`属性指定属性的名称，`type`属性表示属性的数据类型。在我们的例子中，`employeeid`属性的类型是`int`，并且是必需的，如`use`属性所示。

然后模式通过使用`<simpleType>`元素定义了`NameSimpleType`简单类型。因为我们希望`NameSimpleType`的数据类型是`string`，所以我们在`<restriction>`元素中指出了这一点。元素的最小和最大长度分别由`minLength`和`maxLength`属性决定。在我们的例子中，名称长度必须超过 3 个字符，并且不能超过 255 个字符。

接下来定义简单类型。它是一个不超过 20 个字符的字符串。最后，定义了`NotesSimpleType`简单类型。它也是一个字符串，但不得超过 500 个字符。

就这样！在 XML 编辑器中键入前面的标记后，保存`Employees.xsd`文件。

在我们继续之前，让我们快速地看看`Employees.xsd`的节点在 XML Schema Explorer、内容模型视图和图表视图中的样子。

点击开始视图中的 XML 模式浏览器链接，打开 XML 模式浏览器(见图 [5-5](#Fig5) )。

![A160895_2_En_5_Fig5_HTML.jpg](img/.jpg)

图 5-5。

Employees.xsd in XML Schema Explorer

请注意`EmployeeType`复杂类型和`NameSimpleType`、`NotesSimpleType`和`PhoneSimpleType`简单类型是如何显示的。还显示了`employees`根元素和零个或多个出现的`employee`元素。

如果您单击内容模型视图，然后从 XML Schema Explorer 中拖放`employees.xsd`节点，您将看到类似于图 [5-6](#Fig6) 的内容。

![A160895_2_En_5_Fig6_HTML.jpg](img/.jpg)

图 5-6。

Viewing employees element in the Content Model View

注意`employees`元素、`employee`元素和其他子元素是如何图形化显示的。当然，如果您想编辑某些内容，您需要再次切换到 XML 编辑器并进行所需的更改。

图 [5-7](#Fig7) 显示了图形视图中的各种类型和元素。

![A160895_2_En_5_Fig7_HTML.jpg](img/.jpg)

图 5-7。

Various types and elements in the Graph View

最后，看看开始视图的底部。它列出了模式的摘要。图 [5-8](#Fig8) 显示了`employees.xsd`的这些细节。

![A160895_2_En_5_Fig8_HTML.jpg](img/.jpg)

图 5-8。

Summary of the schema as shown in the Start View

至此你创造了 XSD——`employees.xsd`。但它还没有附着在`employees.xml`上。您将在后面的章节中学习如何做到这一点。

#### 使用 Visual Studio IDE 从 XML 文档创建架构

在前面的小节中，您通过手动编辑`employees.xsd`文件创建了模式。这种方法可以让你完全控制 XSD。但是，有时您已经准备好了 XML 文档，并希望快速为它们创建一个 XSD。幸运的是，Visual Studio IDE 提供了一种简单的方法来做到这一点。

要了解 Visual Studio 如何为您做到这一点，请在 Visual Studio XML 编辑器中打开`employees.xml`文件。您会注意到菜单栏现在有了一个额外的菜单——XML。图 [5-9](#Fig9) 显示了该菜单。

![A160895_2_En_5_Fig9_HTML.jpg](img/.jpg)

图 5-9。

XML menu of Visual Studio

注意，XML 菜单有一个选项——Create Schema——为打开的 XML 文档创建模式。如果您在`employees.xml`打开时选择此选项，Visual Studio 将为您生成一个模式。图 [5-10](#Fig10) 显示了 XML Schema Explorer 中的模式。

![A160895_2_En_5_Fig10_HTML.jpg](img/.jpg)

图 5-10。

XML Schema Explorer showing the newly generated schema

如果您观察模式的完整标记，它将类似于清单 [5-4](#Par98) 。

```cs
<?xml version="1.0" encoding="utf-8"?>
<xs:schema attributeFormDefault="unqualified"
elementFormDefault="qualified"
xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="employees">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" name="employee">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="firstname" type="xs:string" />
              <xs:element name="lastname" type="xs:string" />
              <xs:element name="homephone" type="xs:string" />
              <xs:element name="notes" type="xs:string" />
            </xs:sequence>
            <xs:attribute name="employeeid" type="xs:unsignedByte" use="required" />
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>

Listing 5-4.Markup of the Newly Generated Schema

```

您会注意到清单 [5-4](#Par98) 中显示的模式负责基本的元数据，比如元素名称、属性及其类型。如果需要定制，您需要根据自己的需要修改 XSD。

#### 使用 XML 架构定义工具创建架构

在上一节中，您使用 XML 架构设计器创建了一个架构。您还从现有的 XML 文档中创建了一个模式。还有另一种创建模式的方法——使用 XML 模式定义工具。XML 模式定义工具(`xsd.exe`)允许您从以下内容创建 XSD 模式:

*   现有的 XML 文档
*   现有的 XDR 架构
*   组件中定义的类型(`.exe`或`.dll`)

XML 模式定义工具以`xsd.exe`的形式提供，可以从 Visual Studio 命令提示符调用。在下面几节中，您将学习如何使用该工具从 XML 文档和程序集创建模式。

#### 从 XML 文档创建模式

让我们假设您有一个`Employees.xml`文件，并想通过使用`xsd.exe`命令行工具为它创建 XSD。为此，请打开 Visual Studio 命令提示符。然后在命令提示符下输入以下命令:

```cs
xsd.exe "C:\Test\Employees.xml" /outputdir:"C:\Test"

```

第一个参数是要为其生成模式的 XML 文件的路径和文件名。假设`Employees.xml`文件存在于`C:\Test`文件夹中。`/outputdir`开关指定生成的 XSD 文件应该被创建的文件夹。

调用该命令后，您将在指定的文件夹中找到一个`.xsd`文件。默认情况下，模式文件的名称与 XML 文件名相同。清单 [5-5](#Par109) 显示了工具生成的模式。

```cs
<?xml version="1.0" encoding="utf-8"?>
<xs:schema id="employees" http://www.w3.org/2001/XMLSchema" ➥
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="employees" msdata:IsDataSet="true" ➥
msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="employee">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="firstname" type="xs:string" minOccurs="0" ➥
msdata:Ordinal="0" />
              <xs:element name="lastname" type="xs:string" minOccurs="0" ➥
msdata:Ordinal="1" />
              <xs:element name="homephone" type="xs:string" minOccurs="0" ➥
msdata:Ordinal="2" />
              <xs:element name="notes" type="xs:string" minOccurs="0" ➥
msdata:Ordinal="3" />
            </xs:sequence>
            <xs:attribute name="employeeid" type="xs:string" />
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>

  </xs:element>
</xs:schema>
Listing 5-5.Schema Generated by the xsd.exe Tool

```

如您所见，结果模式定义了一个名为`<employees>`的根元素。`<employees>`元素可以出现零次或多次`<employee>`元素。`<employee>`元素被定义为复杂类型，包含四个子元素:`<firstname>`、`<lastname>`、`<homephone>`和`<notes>`。该模式还规定元素必须以相同的顺序出现(如`<sequence>`标记所示)。还定义了`employeeid`属性。您可以定制生成的模式以满足您的需要。

Note

您也可以在标准命令提示符下调用`xsd.exe`工具。然而，您需要在调用时指定`xsd.exe`工具的完整路径。或者，您可以导航到的安装文件夹。NET，然后调用它。你甚至可以把它添加到`PATH`变量中。

#### 从程序集创建架构

您可能想知道为什么需要从程序集创建模式。但是，这个工具在 XML 序列化过程中很方便，在这个过程中，您经常以 XML 格式在线序列化您的类。因此，从程序集中提取的 XSD 模式表示这个序列化 XML 的元数据。

Note

在第 8 章中，你会学到更多关于 XML 序列化的知识。

为了了解`xsd.exe`工具如何从程序集生成模式，我们将创建一个类库项目。类库将有一个名为`Employee`的类。清单 [5-6](#Par115) 中显示了`Employee`类的源代码。

```cs
namespace ClassLibrary1
{
    public class Employee
    {
      public int EmployeeID { get; set; }
      public string FirstName { get; set; }
      public string LastName { get; set; }
      public string HomePhone { get; set; }
      public string Notes { get; set; }
}
Listing 5-6.The Employee Class

```

`Employee`类非常简单，包含五个公共属性— `EmployeeID`、`FirstName`、`LastName`、`HomePhone`和`Notes`。

创建类之后，确保编译它，以便输出它的程序集— `ClassLibrary1.dll`。现在调用`xsd.exe`工具，如下所示:

```cs
xsd.exe "C:\ ClassLibrary1\bin\Debug\classlibrary1.dll"
/outputdir:"C:\ClassLibrary1"

```

`xsd.exe`的第一个参数指定程序集的路径和文件名，而`/outputdir`开关指定应该创建 XSD 的目标文件夹。清单 [5-7](#Par120) 显示了基于我们的`Employee`类的 XSD。

```cs
<?xml version="1.0" encoding="utf-8"?>
<xs:schema elementFormDefault="qualified" ➥
xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="Employee" nillable="true" type="Employee" />
  <xs:complexType name="Employee">
    <xs:sequence>
      <xs:element minOccurs="1" maxOccurs="1" name="EmployeeID" type="xs:int" />
      <xs:element minOccurs="0" maxOccurs="1" name="FirstName" type="xs:string" />
      <xs:element minOccurs="0" maxOccurs="1" name="LastName" type="xs:string" />
      <xs:element minOccurs="0" maxOccurs="1" name="HomePhone" type="xs:string" />
      <xs:element minOccurs="0" maxOccurs="1" name="Notes" type="xs:string" />
    </xs:sequence>
  </xs:complexType>
</xs:schema>
Listing 5-7.Schema Generated for the Employee Class

```

正如您在清单 [5-7](#Par120) 中看到的，模式定义了一个名为`<Employee>`的复杂类型`Employee`的元素。复杂类型`Employee`包含五个子元素:`<EmployeeID>`、`<FirstName>`、`<LastName>`、`<HomePhone>`和`<Notes>`。您一定已经猜到了，这些元素的名称是从类属性的名称中提取出来的。这些元素必须按顺序出现，如`<sequence>`标签所示。和前面的例子一样，您可以定制这个模式来满足您的需求。

Note

使用上述命令时，该工具会为程序集中的所有类生成一个架构。您可以使用`/type`开关仅指定某些类别。`xsd.exe`工具也可以从模式中创建类。这有助于在. NET 应用程序中反序列化 XML 数据。

## 使用架构对象模型(SOM)创建架构

到目前为止，我们通过使用各种技术来创建模式，所有这些技术都是设计时技术。这意味着我们自己通过使用文本编辑器、Visual Studio 或`xsd.exe`工具来创建模式。然而，这个节目还有更多的内容。那个。NET Framework 还允许您以编程方式创建架构。

您可以加载现有的模式，也可以从头创建一个新的模式。然后，您可以通过添加或删除各种部分(如元素、属性、简单类型和复杂类型)来操作模式。按照您的要求操作模式后，您就可以编译它了。编译模式可以确保模式结构中没有错误。

为了执行架构操作。NET Framework 提供了一组称为架构对象模型(简称 SOM)的类。SOM 类驻留在`System.Xml.Schema`名称空间中。SOM 用于模式，就像 DOM 用于 XML 文档一样:SOM 类代表模式的各个部分。例如，为了表示一个简单的类型，SOM 提供了一个名为`XmlSchemaSimpleType`的类，为了表示一个元素，SOM 提供了一个名为`XmlSchemaElement`的类。还有许多其他类表示属性、方面、组、复杂类型等等。

在下一节中，您将了解一些核心 SOM 类。请注意，SOM 非常广泛，我不会在这里讨论每个可用的类。

### 核心 SOM 类

图 [5-11](#Fig11) 显示了核心 SOM 类的对象层次。如您所见，所有 SOM 类都继承自一个名为`XmlSchemaObject`的抽象基类。该类为所有子类提供通用的基本功能。

![A160895_2_En_5_Fig11_HTML.jpg](img/.jpg)

图 5-11。

The SOM object hierarchy

`XmlSchemaAnnotated`类表示可以包含注释元素的任何元素的基类。诸如`XmlSchema`、`XmlSchemaType`、`XmlSchemaAttribute`、`XmlSchemaParticle`和`XmlSchemaFacet`之类的类继承自`XmlSchemaAnnotated`类。

Note

您可以使用注释元素来提供关于 XML 模式的信息。注释可以出现在模式中的任何地方，用来解释任何元素、属性或类型定义。

`XmlSchema`类表示 XML 模式的内存表示。这个类允许您读取、写入和编译 XML 模式。

`XmlSchemaType`表示 XML 模式中的一种类型，并作为所有简单和复杂类型的基类。`XmlSchemaSimpleType`和`XmlSchemaComplexType`类从这个类继承而来，允许你分别定义新的简单和复杂类型。

`XmlSchemaAttribute`代表一个元素的属性。最后，`XmlSchemaParticle`类为所有粒子类型提供基本功能，如`XmlSchemaElement`。

### 使用 SOM 创建 XML 模式

现在您知道了 SOM 是什么，让我们用它来为我们的`Employees.xml`文件创建一个模式。该模式有三种简单类型:

*   `name`的简单类型:这个简单类型表示我们的 XML 文档中使用的名字(名和姓)。它限制了名称长度；最小长度为 3，最大长度小于 255。
*   `phone`的简单类型:这个简单类型表示电话号码(我们的 XML 文档的`<homephone>`元素)。它强制要求电话号码不得超过 20 个字符。
*   `notes`的简单类型:这个简单类型表示注释(我们文档中的`<notes>`元素)。它强制要求输入的注释不能超过 500 个字符。

这三个简单类型将构成一个代表雇员的复杂类型。复杂类型由以下内容组成:

*   一个名为`<firstname>`的元素，它是一个名字简单的类型
*   一个名为`<lastname>`的元素，它是一个名字简单的类型
*   一个叫做`<homephone>`的元素，它是一个电话简单类型
*   一个名为`<notes>`的元素，它是一个 notes 简单类型
*   名为`employeeid`的必需属性，其类型为`int`

最后，我们将有一个名为`<employees>`的元素，它将包含零个或多个名为`<employee>`的子元素。`<employee>`子元素将是我刚刚提到的复杂类型。

要使用 SOM 创建模式，您需要创建一个如图 [5-12](#Fig12) 所示的 Windows 应用程序。

![A160895_2_En_5_Fig12_HTML.jpg](img/.jpg)

图 5-12。

Application for creating a schema by using the SOM

该应用程序由一个文本框组成，您可以在其中指定目标模式文件的完整路径和名称。单击“创建模式”按钮可以生成、编译模式，并将其保存到指定位置。

创建模式按钮的`Click`事件处理程序如清单 [5-8](#Par147) 所示。

```cs
private void button1_Click(object sender, EventArgs e)
{
  XmlSchema schema = new XmlSchema();

  //define NameSimpleType
  XmlSchemaSimpleType nametype = new XmlSchemaSimpleType();
  XmlSchemaSimpleTypeRestriction nameRes = new XmlSchemaSimpleTypeRestriction();
  nameRes.BaseTypeName =
    new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
  XmlSchemaMinLengthFacet nameFacet1 = new XmlSchemaMinLengthFacet();
  nameFacet1.Value = "3";
  XmlSchemaMaxLengthFacet nameFacet2 = new XmlSchemaMaxLengthFacet();

  nameFacet2.Value = "255";
  nameRes.Facets.Add(nameFacet1);
  nameRes.Facets.Add(nameFacet2);
  nametype.Content = nameRes;

  //define PhoneSimpleType
  XmlSchemaSimpleType phonetype = new XmlSchemaSimpleType();
  XmlSchemaSimpleTypeRestriction phoneRes = new XmlSchemaSimpleTypeRestriction();
  phoneRes.BaseTypeName =
    new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
  XmlSchemaMaxLengthFacet phoneFacet1 = new XmlSchemaMaxLengthFacet();
  phoneFacet1.Value = "20";
  phoneRes.Facets.Add(phoneFacet1); 

  phonetype.Content = phoneRes;

  //define NotesSimpleType
  XmlSchemaSimpleType notestype = new XmlSchemaSimpleType();
  XmlSchemaSimpleTypeRestriction notesRes = new XmlSchemaSimpleTypeRestriction();
  notesRes.BaseTypeName =
    new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
  XmlSchemaMaxLengthFacet notesFacet1 = new XmlSchemaMaxLengthFacet();
  notesFacet1.Value = "500";
  notesRes.Facets.Add(notesFacet1); 

  notestype.Content = notesRes;

  //define EmployeeType complex type
  XmlSchemaComplexType employeetype = new XmlSchemaComplexType();
  XmlSchemaSequence sequence = new XmlSchemaSequence();
  XmlSchemaElement firstname = new XmlSchemaElement();
  firstname.Name = "firstname";
  firstname.SchemaType = nametype;
  XmlSchemaElement lastname = new XmlSchemaElement();
  lastname.Name = "lastname";
  lastname.SchemaType = nametype;
  XmlSchemaElement homephone = new XmlSchemaElement();
  homephone.Name = "homephone";
  homephone.SchemaType = phonetype;
  XmlSchemaElement notes = new XmlSchemaElement();
  notes.Name = "notes";
  notes.SchemaType = notestype;

  sequence.Items.Add(firstname);
  sequence.Items.Add(lastname);
  sequence.Items.Add(homephone); 

  sequence.Items.Add(notes);
  employeetype.Particle = sequence;

  //define employeeid attribute
  XmlSchemaAttribute employeeid = new XmlSchemaAttribute();
  employeeid.Name = "employeeid";
  employeeid.SchemaTypeName =
    new XmlQualifiedName("int", "http://www.w3.org/2001/XMLSchema");
  employeeid.Use = XmlSchemaUse.Required;
  employeetype.Attributes.Add(employeeid);

  //define top complex type
  XmlSchemaComplexType complextype = new XmlSchemaComplexType();
  XmlSchemaSequence sq = new XmlSchemaSequence();
  XmlSchemaElement employee = new XmlSchemaElement();
  employee.Name = "employee";
  employee.SchemaType = employeetype;
  employee.MinOccurs = 0;
  employee.MaxOccursString = "unbounded";
  sq.Items.Add(employee);
  complextype.Particle = sq;

  //define <employees> element
  XmlSchemaElement employees = new XmlSchemaElement();
  employees.Name = "employees";
  employees.SchemaType = complextype; 

  schema.Items.Add(employees);
  //compile the schema
  XmlSchemaSet set = new XmlSchemaSet();
  set.Add(schema);
  set.Compile();
  //save the schema
  XmlTextWriter writer = new XmlTextWriter(textBox1.Text,null);
  schema.Write(writer);
  writer.Close();
  MessageBox.Show("Schema Created Successfully!"); 

}

Listing 5-8.Creating a Schema

by Using the SOM

```

代码有点长，因此我们将把它分成几部分。

#### 创建模式

内存模式由`XmlSchema`类表示。代码在顶部声明了一个`XmlSchema`的实例:

```cs
XmlSchema schema = new XmlSchema();

```

#### 为名称创建简单类型

模式需要为名称定义一个简单的类型。接下来定义如下:

```cs
XmlSchemaSimpleType nametype = new XmlSchemaSimpleType();
XmlSchemaSimpleTypeRestriction nameRes = new XmlSchemaSimpleTypeRestriction();
nameRes.BaseTypeName =
  new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
XmlSchemaMinLengthFacet nameFacet1 = new XmlSchemaMinLengthFacet();
nameFacet1.Value = "3";
XmlSchemaMaxLengthFacet nameFacet2 = new XmlSchemaMaxLengthFacet();
nameFacet2.Value = "255";
nameRes.Facets.Add(nameFacet1);
nameRes.Facets.Add(nameFacet2);
nametype.Content = nameRes;

```

简单类型由`XmlSchemaSimpleType`类表示。名称的简单类型有某些限制:

*   数据类型必须是字符串。
*   最小长度必须为 3。
*   长度不得超过 255。

为了表示这些限制，创建了一个`XmlSchemaSimpleTypeRestriction`类的实例。类型为`XmlQualifiedName`的`XmlSchemaSimpleTypeRestriction`类的`BaseTypeName`属性指定了该限制使用的基本数据类型。`XmlQualifiedName`类可以用来表示内置的 XSD 数据类型，比如`string`和`int`。在我们的例子中，我们需要`string`，因此我们将它作为构造函数的第一个参数传递。第二个参数指示数据类型所属的命名空间。最小和最大长度限制可以由 facet 类强制实施。

我们需要的两个 facet 类是`XmlSchemaMinLengthFacet`和`XmlSchemaMaxLengthFacet`。这些 facet 类继承自`XmlSchemaFacet`基类，分别代表简单类型的最小长度和最大长度，由每个类的`Value`属性表示。然后通过使用`Add()`方法将这些方面添加到`XmlSchemaSimpleTypeRestriction`实例中。最后，`XmlSchemaSimpleType`对象的`Content`属性被设置为我们创建的限制。

#### 为电话号码创建简单类型

创建电话号码的简单类型遵循前面讨论的相同过程。但是，限制要求略有不同。相关代码如下所示:

```cs
XmlSchemaSimpleType phonetype = new XmlSchemaSimpleType();
XmlSchemaSimpleTypeRestriction phoneRes = new XmlSchemaSimpleTypeRestriction();
phoneRes.BaseTypeName =
  new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
XmlSchemaMaxLengthFacet phoneFacet1 = new XmlSchemaMaxLengthFacet();
phoneFacet1.Value = "20";
phoneRes.Facets.Add(phoneFacet1); 

phonetype.Content = phoneRes;

```

如前所述，创建了`XmlSchemaSimpleType`和`XmlSchemaSimpleTypeRestriction`的实例。这次我们只需要一个方面来指定电话号码的最大长度。因此，代码声明了一个`XmlSchemaMaxLengthFacet`类的实例，并将其`Value`属性设置为`20`。和前面一样，facet 被添加到限制中，`XmlSchemaSimpleType`实例的`Content`属性被设置为电话号码限制。

#### 为便笺创建简单类型

为 notes 创建一个简单类型与我前面讨论的相同。唯一的变化是最大长度值。相关代码如下所示:

```cs
XmlSchemaMaxLengthFacet notesFacet1 = new XmlSchemaMaxLengthFacet();
notesFacet1.Value = "500";

```

#### 创建表示雇员的复杂类型

复杂类型由`XmlSchemaComplexType`类表示。在我们的例子中，四个子元素(`<firstname>`、`<lastname>`、`<homephone>`和`<notes>`)必须以相同的顺序出现，这是由`XmlSchemaSequence`类定义的。定义复杂类型的代码如下所示:

```cs
XmlSchemaComplexType employeetype = new XmlSchemaComplexType();
XmlSchemaSequence sequence = new XmlSchemaSequence();
XmlSchemaElement firstname = new XmlSchemaElement();
firstname.Name = "firstname";
firstname.SchemaType = nametype;
XmlSchemaElement lastname = new XmlSchemaElement();

lastname.Name = "lastname";
lastname.SchemaType = nametype;
XmlSchemaElement homephone = new XmlSchemaElement();
homephone.Name = "homephone";
homephone.SchemaType = phonetype;
XmlSchemaElement notes = new XmlSchemaElement();

notes.Name = "notes";
notes.SchemaType = notestype;

sequence.Items.Add(firstname);
sequence.Items.Add(lastname);
sequence.Items.Add(homephone);
sequence.Items.Add(notes);
employeetype.Particle = sequence; 

//define employeeid attribute
XmlSchemaAttribute employeeid = new XmlSchemaAttribute();
employeeid.Name = "employeeid";
employeeid.SchemaTypeName =
  new XmlQualifiedName("int", "http://www.w3.org/2001/XMLSchema");
employeeid.Use = XmlSchemaUse.Required;
employeetype.Attributes.Add(employeeid); 

```

这部分代码从声明`XmlSchemaComplexType`和`XmlSchemaSequence`类的实例开始。接下来我们需要四个元素。每一个都由一个`XmlSchemaElement`类定义，并且应该采用前面定义的简单类型之一。`XmlSchemaElement`类的`Name`属性指定元素的名称；`SchemaType`属性指定元素的数据类型，可以设置为简单类型或复杂类型。定义完所有四个元素后，通过使用`Add()`方法将它们添加到`XmlSchemaSequence`对象中。

在序列实例准备好之后，您需要为它设置`XmlSchemaComplexType`对象的`Particle`属性。`Particle`属性指定复杂类型的合成器类型，复杂类型的属性由`XmlSchemaAttribute`类表示。`XmlSchemaAttribute`的`Name`属性指定了属性的名称。属性的数据类型通过使用类型为`XmlQualifiedName`的`SchemaTypeName`属性来指定。在我们的例子中，`employeeid`属性是一个整数，因此`XmlQualifiedName`使用`int`作为数据类型。`XmlSchemaAttribute`类的`Use`属性指出了如何在 XML 文档中使用该属性。该属性是类型`XmlSchemaUse`的枚举。在我们的例子中，`employeeid`属性是强制的，因此我们将`Use`属性设置为`Required`。

#### 创建顶级复杂类型

我们的 XML 文档的根元素需要有零个或多个`<employee>`元素的实例，这是我们在上一节中定义的复杂类型。为了表示`<employee>`元素，我们将其定义为另一个复杂类型，如下所示:

```cs
XmlSchemaComplexType complextype = new XmlSchemaComplexType();
XmlSchemaSequence sq = new XmlSchemaSequence();
XmlSchemaElement employee = new XmlSchemaElement();
employee.Name = "employee";
employee.SchemaType = employeetype;
employee.MinOccurs = 0;
employee.MaxOccursString = "unbounded";
sq.Items.Add(employee);
complextype.Particle = sq; 

```

代码像以前一样创建了一个`XmlSchemaComplexType`和`XmlSchemaSequence`类的实例。这一次，它创建了一个单独的`XmlSchemaElement`来表示一个`<employee>`元素。这个元素的类型是`employeetype`(我们在上一节中定义的复杂类型)。

`XmlSchemaElement`类的`MinOccurs`属性表示元素必须在文档中出现的最小次数。同样，`MaxOccursString`属性表示元素的最大允许实例。请注意，该属性接受数字作为字符串。如果对数量没有限制，可以设置为`unbounded`。创建元素后，它被添加到序列中，序列被分配给`XmlSchemaComplexType`类的`Particle`属性。

#### 创建根元素

模式需要包含一个或多个`<employee>`元素的`<employees>`根元素。根元素定义如下:

```cs
//define <employees> element
XmlSchemaElement employees = new XmlSchemaElement();
employees.Name = "employees";
employees.SchemaType = complextype; 

```

和前面一样，创建了一个`XmlSchemaElement`的实例。它的`Name`属性被设置为`employees`，它的`SchemaType`属性被设置为我们在上一节创建的顶级复杂类型。

#### 编译模式

现在我们已经完成了所有的简单类型、复杂类型和属性。我们现在可以将根元素添加到模式中。这是通过使用`XmlSchema`类的`Items`集合的`Add()`方法来完成的:

```cs
schema.Items.Add(employees);

```

模式准备好之后，就可以编译它了。编译模式可以确保模式语法正确且格式良好。`XmlSchemaSet`类表示一组模式，并允许您编译它们。相关代码如下所示:

```cs
//compile the schema
try
{
  XmlSchemaSet set = new XmlSchemaSet();
  set.Add(schema);
  set.Compile();
}
catch (Exception ex)
{
  MessageBox.Show("Schema compilation failed");
  return;
}

```

`XmlSchemaSet`类的`Add()`方法接受将要添加到模式集中的`XmlSchema`对象。`XmlSchemaSet`类的`Compile()`方法编译给定集合中的所有模式。

#### 保存模式

现在我们已经创建并编译了模式，可以写入磁盘了:

```cs
XmlTextWriter writer = new XmlTextWriter(textBox1.Text,null);
schema.Write(writer);
writer.Close();

```

`XmlSchema`类的`Write()`方法将模式写到流中，并且有许多重载。我们使用了一个接受指向所需文件的`XmlWriter`的接口。写操作结束后，`XmlWriter`关闭。

就这样！您刚刚使用 SOM 创建了一个完整的模式。您可以运行应用程序并查看模式是如何生成的。图 [5-13](#Fig13) 显示了结果模式。

![A160895_2_En_5_Fig13_HTML.jpg](img/.jpg)

图 5-13。

Schema generated by using the SOM

## 将 DTD 和 XML 模式附加到 XML 文档

到目前为止，您已经了解了什么是 DTD 和 XML 模式。您还学习了如何创建 DTD 和 XML 模式。现在是时候学习如何根据 DTD 和 XML 模式来验证 XML 文档了。

在验证 XML 文档之前，必须将 DTD 或 XML 模式附加到该文档。可以通过两种技术附加 DTD 或 XML 模式:

*   内联 DTD 或 XML 模式:在这种技术中，DTD 或模式在 XML 文档的顶部指定。
*   外部 DTD 或 XML 模式:在这种技术中，DTD 或模式驻留在自己的文件中——也就是说，它在 XML 文档之外。然后将 DTD 或模式附加到 XML 文档中。

### 内嵌 dtd

为了以内联方式指定 DTD，您需要在 XML 文档的顶部添加一个`<!DOCTYPE>`声明。清单 [5-9](#Par189) 显示了这是如何为`Employees.xml`完成的。

```cs
<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE employees [

<!ELEMENT employees (employee*)>

<!ELEMENT employee (firstname,lastname,homephone,notes)>

<!ELEMENT firstname (#PCDATA)>

<!ELEMENT lastname (#PCDATA)>

<!ELEMENT homephone (#PCDATA)>

<!ELEMENT notes (#PCDATA)>

<!ATTLIST employee employeeid CDATA #REQUIRED>

]>

<employees>
  <employee employeeid="1">
    <firstname>Nancy</firstname>
    <lastname>Davolio</lastname>
...

Listing 5-9.
Inline DTD

```

注意粗体的标记:它与我们之前创建的 DTD 相同。然而，这一次它被放在了 XML 文档内的`<!DOCTYPE>`声明中。注意，`<!DOCTYPE>`声明必须在 XML 标记的根元素之前。当 XML 文档很小，并且不想维护单独的 DTD 文件时，使用内联 DTD 会很方便。

### 外部 dtd

外部 dtd 存储在单独的文件中，通常带有`.dtd`扩展名。然后使用一个`<!DOCTYPE>`声明将 DTD 链接到 XML 文档。清单 [5-10](#Par192) 展示了这是如何完成的。

```cs
<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE employees SYSTEM "employees.dtd">

<employees>
  <employee employeeid="1">
    <firstname>Nancy</firstname>
    <lastname>Davolio</lastname>
...
Listing 5-10.External DTD

```

当附加一个外部 DTD 时，`<!DOCTYPE>`声明后面紧跟着 XML 文档根元素的名称(在我们的例子中是`employees`)。`SYSTEM`声明后面是 DTD 文件的 URL。在前面的例子中，假设 DTD 驻留在名为`employees.dtd`的文件中。

### 内联 XML 模式

通过将模式嵌入 XML 标记本身，可以以内联方式指定模式。如清单 [5-11](#Par195) 所示，完整的模式(从`<xs:schema>`到`<xs:/schema>`)被直接放在根元素`<employees>`中。模式必须放在这里，因为 XML 文档不能有两个根元素。

```cs
<?xml version="1.0" encoding="utf-8" ?>
<employees>
  <xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified"
             xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="employees">
      <xs:complexType>
...
Listing 5-11.Inline XML Schema

```

尽管 Visual Studio 的 XML 编辑器支持内联架构，但作为编程建议，您应该避免使用它们。W3C 推荐标准允许内联模式，但是这种支持并不是一个强制性的特性。这意味着并非所有供应商都支持内联模式。此外，因为它们包含在 XML 文档中，所以每次通过网络传输时会消耗更多的网络带宽。

### 外部 XML 模式

外部模式驻留在一个物理文件中，通常带有`.xsd`扩展名。要将外部模式附加到 XML 文档，需要修改 XML 文档的根元素，如清单 [5-12](#Par198) 所示。

```cs
<?xml version="1.0" encoding="utf-8" ?>

<employees xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

           xsi:noNamespaceSchemaLocation="employees.xsd">

  <employee employeeid="1">
    <firstname>Nancy</firstname>
    <lastname>Davolio</lastname>
...
Listing 5-12.External XML Schema

```

正如您所看到的，`<employees>`根元素现在有了一个`xmlns:xsi`属性，它为 XML 文档指定了 W3C 名称空间，这被称为 XML 模式实例。`xsi:noNamespaceSchemaLocation`属性指定了模式文件的 URL(在我们的例子中是`employees.xsd`)。

在前面的例子中，我们的 XML 文档没有使用名称空间。如果是这样，我们必须对我们的模式和 XML 文档做两处修改:

*   将`targetNamespace`属性添加到模式声明。
*   使用`xsi:schemaLocation`属性代替`xsi:noNamespaceSchemaLocation`属性。

清单 [5-13](#Par204) 显示了修改后的模式，清单 [5-14](#Par206) 显示了修改后的 XML 文档。

```cs
<xs:schema
  attributeFormDefault="qualified"
  elementFormDefault="qualified"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  targetNamespace="myns"
  >
...
Listing 5-13.Schema with Target Namespace

```

如您所见，模式现在有一个`targetNamespace`属性，它将目标名称空间指定为`myns`。XML 文档必须使用这个名称空间，如清单 [5-14](#Par206) 所示。

```cs
<myns:employees
  xmlns:myns="myns"

  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="myns employeesns.xsd">

<myns:employee myns:employeeid="1">
<myns:firstname>Nancy</myns:firstname>
...
Listing 5-14.XML Document with Namespace

```

请注意粗体的标记。根元素现在声明了一个名为`myns`的名称空间，并使用了一个`xsi:schemaLocation`属性来代替`xsi:noNamespaceSchemaLocation`。仔细观察属性值是如何指定的:它必须包含名称空间名称、一个空格，然后是 XSD 文件的 URL。

### 将常用模式添加到模式缓存中

如果您发现自己反复使用相同的模式文件，您可以考虑将您的模式添加到模式缓存中。一旦将架构存储在架构缓存中，就可以在 Visual Studio 的 XML 编辑器中方便地访问它。架构缓存可以从 Visual Studio 的 XML ➤架构菜单选项中看到。请注意，只有在 Visual Studio 编辑器中打开 XML 文件时，XML 菜单选项才可见。图 [5-14](#Fig14) 显示了默认可用的模式。

![A160895_2_En_5_Fig14_HTML.jpg](img/.jpg)

图 5-14。

Schema set of Visual Studio

通过分别单击添加或删除按钮，可以在缓存中添加或删除模式。一旦你添加了一个特定的模式，你可以在编写 XML 文档时使用它，方法是选择模式设置对话框的使用这个模式选项(见图 [5-15](#Fig15) )。

![A160895_2_En_5_Fig15_HTML.jpg](img/.jpg)

图 5-15。

Using a schema from the schema set

## 使用 XmlReader 验证 XML 文档

`XmlReader`类通过使用它的`Create()`方法为您提供了一种验证 XML 文档的方法，该方法接受 XML 文档的 URL 和`XmlReaderSettings`类的一个实例。`XmlReaderSettings`类配置了`XmlReader`类，可以用来表明验证 XML 文档的意图。您还可以连接一个事件处理程序来接收关于验证错误的通知。由`Create()`方法返回的`XmlReader`实例可以用来读取 XML 文档，就像你在第 [3](03.html) 章中所学的一样。

为了说明如何使用`XmlReader`来验证 XML 文档，您将开发一个如图 [5-16](#Fig16) 所示的应用程序。

![A160895_2_En_5_Fig16_HTML.jpg](img/.jpg)

图 5-16。

Application for validating an XML document by using the XmlReader class

该应用程序由一个文本框组成，用于接受 XML 文档文件名。假设这个 XML 文档附加了一个外部 DTD 或一个外部 XML 模式(XSD )(如前几节所述)。单选按钮指示您是根据 DTD 还是 XSD 进行验证。单击 Validate 按钮验证文档。验证过程中遇到的任何错误都会通过消息框显示出来。清单 [5-15](#Par213) 显示了应用程序的完整代码。

```cs
private void button1_Click(object sender, EventArgs e)
{
  XmlReaderSettings settings = new XmlReaderSettings();
  settings.XmlResolver = new XmlUrlResolver();

  if (radioButton1.Checked)
  {
    settings.DtdProcessing = DtdProcessing.Parse;
    settings.ValidationType = ValidationType.DTD;
  }
  else
  {
    settings.ValidationFlags = XmlSchemaValidationFlags.ProcessSchemaLocation;
    settings.ValidationType=ValidationType.Schema;
  }
  settings.ValidationEventHandler += new ValidationEventHandler(OnValidationError);
  XmlReader reader = XmlReader.Create(textBox1.Text, settings);

  while (reader.Read())
  {
    //you can put code here
    //that reads and processes

    //the document
  }

  reader.Close();
  MessageBox.Show("Validation over");
}

Listing 5-15.Validating an XML Document by Using XmlReader

```

代码从创建一个`XmlReaderSettings`对象开始。`XmlReaderSettings`的`XmlResolver`属性被设置为一个新的`XmlUrlResolver`对象，以便在验证期间可以定位外部 DTD 或 XSD。

如果 XML 文档要根据 DTD 进行验证(如单选按钮所示)，那么`XmlReaderSettings`类的`DtdProcessing`属性被设置为`DtdProcessing.Parse`。`DtdProcessing`属性决定是否允许对 DTD 进行验证。默认情况下，该属性为`Prohibit`。

如果要根据 XML 模式(XSD)对文档进行验证，`ValidationFlags`属性被设置为`ProcessSchemaLocation` ( `XmlSchemaValidationFlags`枚举)，以便`XmlResolver`和`XmlReaderSettings`可以处理模式位置。

`ValidationType`属性指示`XmlReader`是否应该执行验证，以及是使用 DTD 还是模式。`ValidationType`属性是`ValidationType`类型的枚举，有五个可能的值，如表 [5-3](#Tab3) 中所列。

表 5-3。

Possible Values of ValidationType

<colgroup><col> <col></colgroup> 
| 价值 | 描述 |
| --- | --- |
| `None` | 将不执行任何验证。这是默认设置。 |
| `Auto` | 通过观察 XML 文档，自动决定是否根据 DTD 或模式进行验证。 |
| `DTD` | 将根据 DTD 执行验证。 |
| `Schema` | 将根据 XML 模式(XSD)执行验证。 |
| `XDR` | 将根据 XDR 架构执行验证。 |

为了捕获验证错误，`XmlReaderSettings`类引发了一个`ValidationEventHandler`事件。只有当`ValidationType`属性不是`None`时，才会引发该事件。事件处理函数的签名(在我们的例子中是`OnValidationError()`)必须与这里显示的相匹配:

```cs
void OnValidationError(object sender, ValidationEventArgs e)
{
  MessageBox.Show(e.Message);
}

```

事件处理程序接收一个`ValidationEventArgs`对象作为事件参数，这允许您检查底层异常。您可以通过使用`Message`属性获得描述性的错误消息，就像我们在示例中所做的那样。在这种情况下，我们只显示一个消息框，其中包含验证错误消息。

清单 [5-15](#Par213) 中的代码通过调用`Create()`静态方法创建了一个`XmlReader`类的实例。XML 文档的 URL 或路径和`XmlReaderSettings`的实例是参数。然后一个`while`循环读取 XML 文档。如果在这个读取操作中检测到任何验证错误，就会引发`ValidationEventHandler`事件。如果需要，我们可以在`while`循环中放置代码来读取元素和属性值(关于使用`XmlReader`类读取 XML 文档的信息，请参考第 [3](03.html) 章)。最后关闭阅读器。

要测试前面的代码，您需要运行应用程序，提供 XML 文档的完整路径和文件名，并从 DTD 或 XSD 单选按钮中进行选择。您可以使用我们在本章中使用的同一个`Employees.xml`文件。我们之前还为`Employees.xml`创建了一个 DTD 和一个 XML 模式。单击 Validate 按钮后，`XmlReader`将尝试验证 XML 文档，并通知您任何验证错误。图 [5-17](#Fig17) 显示了故意删除所需属性`employeeid`后生成的消息框。

![A160895_2_En_5_Fig17_HTML.jpg](img/.jpg)

图 5-17。

Detecting a validation error

## 使用 XmlDocument 验证 XML 文档

您不局限于使用`XmlReader`方法来验证 XML 文档；您也可以使用`XmlDocument`来验证它们。当您修改文档并希望确保新数据与底层模式或 DTD 一致时，这很有用。`XmlDocument`类允许您以两种方式验证 XML 文档:

*   您可以在文档被`XmlDocument`类加载时验证文档。
*   当您对文档执行任何修改(如添加或删除节点)时，您可以显式地验证文档。

在下面的示例中，您将了解如何使用上述两种方法。我们将修改我们在第 [2](02.html) 章的“修改 XML 文档”一节中开发的同一个例子。图 [5-18](#Fig18) 显示了该应用的用户界面。

![A160895_2_En_5_Fig18_HTML.jpg](img/.jpg)

图 5-18。

Application for validating XML documents by using XmlDocument

因为我们已经在第 [2](02.html) 章解剖了完整的代码，所以这里不再讨论。我只讨论验证 XML 文档所必需的修改。

在本节前面，我们提到过`XmlDocument`允许您在加载 XML 文档时对其进行验证。这是通过将验证读取器传递给`XmlDocument`类的`Load()`方法来实现的。清单 [5-16](#Par229) 显示了`Form_Load`事件处理程序的修改版本。

```cs
private void Form1_Load(object sender, EventArgs e)
{
  XmlReaderSettings settings = new XmlReaderSettings();

  settings.XmlResolver = new XmlUrlResolver();

  settings.ValidationFlags = XmlSchemaValidationFlags.ProcessSchemaLocation;

  settings.ValidationType = ValidationType.Schema;

  settings.ValidationEventHandler += new

           ValidationEventHandler(OnValidationError);

  XmlReader reader =

    XmlReader.Create($"{Application.StartupPath}\\employees.xml", settings);

  doc.Load(reader);

  reader.Close();

  foreach (XmlNode node in doc.DocumentElement.ChildNodes)
  {
    comboBox1.Items.Add(node.Attributes["employeeid"].Value);
  }
  FillControls();
}

Listing 5-16.Validating an XML Document

When It Is Being Loaded

```

注意用粗体标记的代码。这段代码对你来说应该很熟悉，因为我们在本章的前面部分讨论过它。它实际上创建了一个`XmlReaderSettings`对象，并将其配置为根据`Employees.xsd`来验证`Employees.xml`。`ValidationEventHandler`事件由`OnValidationError()`方法处理。然后将`XmlReaderSettings`对象传递给`XmlReader`类的`Create()`方法，以获得一个`XmlReader`对象。

`XmlDocument`的`Load()`方法接受新创建的`XmlReader`对象作为参数，在内部遍历`XmlReader`，然后进行验证。如果有任何验证错误，就会调用`OnValidationError()`方法。

现在到了棘手的部分。`XmlDocument`类允许你修改文档。因此，文档在加载时可能是有效的，但在修改后可能会变得无效。例如，按照我们的模式，电话号码不能超过 20 个字符。但是，表单用户可以忽略这一限制，加载的文档现在可能包含无效数据。这使得有必要重新验证对文档所做的更改。幸运的是，`XmlDocument`类提供了一个叫做`Validate()`的方法来完成这项工作。清单 [5-17](#Par233) 显示了在更新操作中`Validate()`的使用。

```cs
private void button2_Click(object sender, EventArgs e)
{
  XmlNode node =
    doc.SelectSingleNode($"//employee[@employeeid='                          {comboBox1.SelectedItem}']");
  if (node != null)
  {
    node.ChildNodes[0].InnerText = textBox1.Text;
    node.ChildNodes[1].InnerText = textBox2.Text;
    node.ChildNodes[2].InnerText = textBox3.Text;
    XmlCDataSection notes = doc.CreateCDataSection(textBox4.Text);
    node.ChildNodes[3].ReplaceChild(notes, node.ChildNodes[3].ChildNodes[0]);
  }

  doc.Validate(OnValidationError,node);

  if (!isError)

  {

    doc.Save($"{Application.StartupPath}\\employees.xml");

  }

}

Listing 5-17.Validating a Node Explicitly

```

请注意用粗体标记的代码。`XmlDocument`的`Validate()`方法可以根据先前指定的模式或 DTD 验证整个文档或仅仅一个节点。`Validate()`方法接受两个参数:匹配`ValidationEventHandler`委托签名的函数名和要验证的`XmlNode`。还有一个`Validate()`重载，它只接受一个与`ValidationEventHandler`委托签名匹配的函数，并验证整个文档。`OnValidationError`功能如清单 [5-18](#Par235) 所示。

```cs
void OnValidationError(object sender, ValidationEventArgs e)
{
  MessageBox.Show(e.Message);
  isError = true;
}
Listing 5-18.The OnValidationError Function

```

该函数只是在消息框中显示错误消息，并将类级别的布尔变量`isError`设置为 true。检查该变量以决定是否保存文档。要测试应用程序，请将任何员工的电话号码修改为 20 个字符以上，然后单击 Update 按钮。您应该会看到一个类似于图 [5-19](#Fig19) 所示的消息框。

![A160895_2_En_5_Fig19_HTML.jpg](img/.jpg)

图 5-19。

Validation error during saving changes

## 使用 XPathNavigator 验证 XML 文档

您可能正在使用`XPathNavigator`来读取 XML 文档，并且可能想要对这些文档执行验证。从第 4 章[回忆起`XPathNavigator`可以通过使用`XmlDocument`或`XPathDocument`类获得。使用`XmlDocument`得到的`XPathNavigator`是可编辑的，而使用`XPathDocument`得到的是只读的。`XPathNavigator`类本身不允许您验证数据，但是您可以使用底层的`XmlDocument`或`XPathDocument`类来执行验证。](04.html)

我们已经看到了使用`XmlDocument`执行的验证，但是就像`XmlDocument`一样，`XPathDocument`类允许您在加载期间根据模式或 DTD 验证 XML 文档。在这种情况下，`XPathDocument`的构造函数可以接受一个验证`XmlReader`来执行验证。因为通过使用`XPathDocument`获得的`XPathNavigator`是只读的，所以没有办法在 XML 文档被加载后重新验证它。清单 [5-19](#Par239) 显示了通过使用`XPathDocument`获得的`XPathNavigator`如何执行验证。

```cs
XmlReaderSettings settings = new XmlReaderSettings();
settings.XmlResolver = new XmlUrlResolver();
settings.ValidationFlags = XmlSchemaValidationFlags.ProcessSchemaLocation;
settings.ValidationType = ValidationType.Schema;
settings.ValidationEventHandler += new ValidationEventHandler(OnValidationError);
XmlReader reader = XmlReader.Create(@"C:\Demos\employees.xml", settings);

XPathDocument doc = new XPathDocument(reader);

XPathNavigator navigator = doc.CreateNavigator();

Listing 5-19.Validating by Using XPathNavigator

```

代码像以前一样创建一个`XmlReaderSettings`对象。`XmlReader`的`Create()`方法接受这个`XmlReaderSettings`对象并返回一个`XmlReader`实例。然后将`XmlReader`实例提供给`XPathDocument`类的构造函数。`XPathDocument`的`CreateNavigator()`方法最终创建了可用于浏览 XML 文档的`XPathNavigator`。

## 通过代码指定 XML 模式

在前面的例子中，`Employees.xml`文件有一个关联的 DTD 或 XML 模式。设想这样一种情况，您有一个 XML 文件，没有任何与之相关联的模式，但是您希望使用某种模式来验证该 XML 文件。

假设您有一个允许以 XML 格式导出数据的应用程序。导出的 XML 文件没有任何关联的模式(内联或外部模式文件)，因为它只是应用程序导出功能的结果。

进一步假设需要将这些先前导出的文件导入到一些其他应用程序中。作为一种安全措施，您希望确保导入的文件符合特定的模式。但是由于导出的 XML 文件没有任何关联的模式，除非打开每个文件并向其中添加模式信息，否则无法验证它们。

幸运的是，有一种编程方式可以完成这项任务。您可以通过代码指定一个模式来验证这样的 XML 文件(没有任何与之相关联的模式)。因此，XML 文件没有提到模式信息，而是以编程方式指定模式。为了完成这个任务，您需要在`XmlReaderSettings`的 Schemas 集合中添加一个模式。Schemas 集合是一个代表 XSD 模式缓存的`XmlSchemaSet`对象。您可以使用它的`Add()`方法向它添加一个模式。

为了理解如何做到这一点，你将开发一个 Windows 窗体应用程序，如图 [5-20](#Fig20) 所示。

![A160895_2_En_5_Fig20_HTML.jpg](img/.jpg)

图 5-20。

Application that attaches a schema via code

该应用程序由两个文本框和一个按钮组成。第一个文本框用于指定 XML 文档的路径，而第二个文本框用于指定 XML 模式(XSD)文件的路径。单击 Validate 按钮根据指定的 XML 模式验证 XML 文件。验证错误(如果有)像以前一样使用消息框显示。

清单 [5-20](#Par248) 显示了 Validate 按钮的`Click`事件处理程序。

```cs
private void button1_Click(object sender, EventArgs e)
{
    XmlReaderSettings settings = new XmlReaderSettings();
    settings.ValidationType=ValidationType.Schema;

    settings.Schemas.Add("", textBox2.Text);

    settings.ValidationEventHandler += new ValidationEventHandler(OnValidationError);

    XmlReader reader=XmlReader.Create(textBox1.Text, settings);
    while (reader.Read())
    {
        //you can put code here
        //that reads and processes
        //the document
    }
    reader.Close();
    MessageBox.Show("Validation over");

}

Listing 5-20.Adding a Schema in XmlSchemaSet

```

请注意用粗体字母标记的代码。将`validationType`设置为`Schema`。这种验证 XML 文档的技术只适用于 XML 模式。此外，代码向`XmlReaderSettings`的 Schemas 集合添加了一个 XML 模式。这样，`textBox2`中指定的 XML 模式可用于验证`textBox1`中指定的 XML 文档。

代码的其余部分您应该很熟悉，因为它已经在前面的例子中讨论过了。`");`

为了测试这个应用程序，从`Employees.xml`文件中删除模式信息，然后运行这个应用程序。在相应的文本框中指定`Employees.xml`文件的路径和`Employees.xsd`模式文件的路径。单击 Validate 按钮将验证 XML 文档。图 [5-21](#Fig21) 显示了当第一个`<employee>`元素中的`employeeid`属性被故意删除时的错误消息示例。

![A160895_2_En_5_Fig21_HTML.jpg](img/.jpg)

图 5-21。

Document validated against schema added programmatically

## 摘要

本章向您介绍了 dtd 和模式。您学习了如何创建 DTD 和 XML 模式。您还学习了使用 Visual Studio 工具创建架构。那个。NET Framework 的架构对象模型(SOM)是一个广泛的对象集合，允许您以编程方式创建架构。您从 SOM 层次结构中学习了一些重要且常用的类。

创建模式或 DTD 只是故事的一半。另一半涉及根据指定的模式或 DTD 实际验证 XML 文档。为了根据模式或 DTD 验证 XML 文档，可以使用几种方法——也就是说，使用`XmlReader`、`XmlDocument`和`XPathNavigator`类。所有的方法本质上都依赖于两个类:`XmlReaderSettings`和`XmlReader`。前一个类配置`XmlReader`来执行验证。它还附加了一个用于处理验证事件的事件处理程序。后一个类实际上读取文档并通知您验证错误。