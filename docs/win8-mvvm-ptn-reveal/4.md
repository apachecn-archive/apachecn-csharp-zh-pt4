第四章

![image](img/.jpg)

实现视图模型

您已经进入了遵循 MVVM 设计模式开发您的第一个 Windows 8 XAML 应用程序的最后一步——实现 FinanceHub 应用程序的视图模型！

作为实现视图模型的一部分，本章将

*   首先构建 MVVM 框架，该框架需要创建表示(视图)和数据源(模型)分离的基础。
*   然后实现 FinanceHub 应用程序的视图模型，该应用程序将创建一个属性集合并将它们与构建的视图绑定在一起。

这个实现最终将引导我们连接到已经实现的数据源(模型),并按照 MVVM 设计模式在我们的应用程序中填充股票和股票详细信息(视图)。为此，我们还将在当前视图定义中做一些小的改动，在第 2 章中，出于演示目的，我们硬编码了一些值。

为金融中心应用程序构建 MVVM 框架

随着 XAML 的引入以及在 XAML 内为 Windows 8、WPF 和 Silverlight 应用程序绑定数据的能力，一种新的设计模式——模型-视图-视图模型(MVVM)出现了。有了这些，许多定制的 MVVM 框架，如 MVVM 之光( *[、http://mvvmlight.codeplex.com/](http://mvvmlight.codeplex.com/)*)、卡利本。开发了 Micro ( *[、http://caliburnmicro.codeplex.com/](http://caliburnmicro.codeplex.com/)*)和 Cinch(*[http://cinch.codeplex.com/](http://cinch.codeplex.com/)*)，它们提供了预构建的助手类，允许快速构建可伸缩的基于 MVVM 模式的应用程序。如果你访问这些网站，你会注意到这些框架正在更新以支持 Windows 8 WinRT。你应该关注这些框架，关注它们在支持 Windows 8 WinRT 开发方面取得的进展。随着这些框架的成熟，我建议在您的基于 LoB WinRT 的 Windows 8 应用程序开发中探索使用这些框架之一。然而，为了在本书中学习 Windows 8 应用程序的 MVVM 实现，我们将实现核心服务的最小足迹，这将需要使用 XAML 构建任何基于 MVVM 的 Windows 8 应用程序。

在本节中，我们将实现(或作为依赖项添加)以下五个核心服务 来为我们的应用程序构建 MVVM 框架:

*   **IoC 容器作为依赖**–控制反转(IoC)容器用于实现依赖注入。
*   **EventAggregator 类**–是注册事件/消息的中央容器，支持发布/订阅模型，提供发布者和订阅者对象之间的解耦。
*   **导航服务**–通过将导航从视图中分离出来并在视图模型中启用它来提供抽象导航。
*   **ViewModel 定位器类**–基于服务定位器模式，它支持一种干净的方式来分配和初始化 ViewModel，并在上下文中设置控件的 DataContext，遵循 IoC 和依赖注入实现方法。
*   **委托命令类**–允许在视图模型中创建类型安全且可绑定的可重用命令(使用 *ICommand* 接口)。

如果您再次访问第 1 章的[的“在金融中心项目中设置 MVVM 架构”一节，您会注意到我们创建了依赖项和基础设施文件夹](1.html)，我们将填充这些文件夹作为本节的一部分，以构建所需的 MVVM 框架。让我们在下面的小节中逐一实现每个服务。

打开最新的 FinanceHub 项目(您上次在[第 3 章](3.html)中更新的项目)来实现本章中的 ViewModel。

IoC 容器依赖关系

构建面向服务的松耦合服务的一个关键概念是将应用程序组件从它们的依赖关系中分离出来。控制反转(IoC)是面向对象的设计实践 ，允许对象在运行时耦合。您可以在实现依赖注入时使用 IoC，以便视图在运行时找到所需的视图模型。

对于微软来说。许多 IoC 容器可用于 WPF 和 Silverlight 应用程序，最终也将可用于 WinRT 。在本书中，我们将使用一个本地 WinRT IoC 容器，该容器可从名为 metro IoC()的 codeplex 网站上获得，可用于基于 Windows 8 WinRT 的应用程序。

![image](img/.jpg) **注**获取可用 IoC 资源和依赖注入容器的详细信息。NET，可以在 *[访问 Scot Hanselman 的博客 http://www . Hansel man . com/blog/listofnetdependencyinijectioncontainersioc . aspx](http://www.hanselman.com/blog/ListOfNETDependencyInjectionContainersIOC.aspx)*。

将*MetroIoc.dll*文件T3】添加到*依赖关系*文件夹中

为了将 metroioc 容器作为一个依赖项添加到这个项目中，首先访问*[【http://metroioc.codeplex.com/】](http://metroioc.codeplex.com/)*，并将*MetroIoc.dll*文件下载到您的本地机器上(在任何位置)。浏览该文件夹，选择*MetroIoc.dll*文件，将其拖放到 Visual Studio 解决方案资源管理器中 FinanceHub 项目的*依赖关系*文件夹中。你会注意到*MetroIoc.dll*文件现在被添加到你的*依赖关系*文件夹中。

将*MetroIoc.dll*文件作为引用添加到*引用*文件夹中

现在进入*引用*文件夹，选择添加引用选项，添加 MetroIoc.dll 的*作为引用。您将打开一个引用管理器窗口——选择浏览选项，点击浏览按钮，浏览到您在依赖文件夹下添加了*MetroIoc.dll*文件的项目路径。选择参照管理器窗口中显示的*MetroIoc.dll*文件，点击确定，将其作为参照添加到*参照*文件夹下。*

![image](img/.jpg) **注意**添加为引用时，一定要从项目的*依赖*文件夹中选择*MetroIoc.dll*文件，不要选择其他位置。这将使用相对路径而不是绝对路径添加该文件作为引用。因此，它应该适用于任何项目结构。

现在，您已经准备好使用 MetroIoC 容器来实现依赖注入，这将在创建 *ViewModelLocator* 类的过程中实现。

EventAggregator 类

如[图 4-1](#Fig1) 所示，事件聚合器服务是一个注册事件/消息的中心容器，它支持发布/订阅模型以提供发布者(作为方法的事件/消息)和订阅者(用于消费的事件/消息)对象之间的解耦。

![9781430249085_Fig04-01.jpg](img/-01.jpg)

[图 4-1。](#_Fig1)支持事件/消息发布/订阅模型的事件聚合器服务

将空白的 *EventAggregator.cs* 类添加到*基础设施*文件夹中

在我们进一步详细讨论如何实现事件聚合器类之前；首先选择*基础设施*文件夹，添加一个新的名为 *EventAggregator.cs* 的空白类。

现在删除以下两个本课程不需要的引用。

```cs
using System.Text;
using System.Threading.Task;
```

接下来添加实现 EventAggregator 类所需的以下引用。

```cs
using System.Reflection;
```

最后，删除下面几行定义空白 *EventAggregator* 类的代码，因为我们将利用来自 Caliburn 的代码。微观框架在下一节。

```cs
class EventAggregator
{
}
```

利用卡利伯恩。微观框架

微软提供了一个 *EventAggregator* 类，它实现了一个用于获取事件类型实例的 *IEventAggregator* 接口。您可以选择使用 Prism 的 EventAggregator 实现；然而，它的依赖性跨越了 Prism 框架的几个类，因此实现起来很复杂。相反，我们将利用现有 Caliburn 的 EventAggregator 实现。codeplex 上可用的微框架(*[【http://caliburnmicro.codeplex.com/】](http://caliburnmicro.codeplex.com/)*)，它遵循观察者模式来实现发布-订阅模型。您需要向聚合器注册一个消息处理程序，它将发送您订阅的消息。它将 WeakReference 用于发布和订阅模型，从而克服了使用事件时的内存泄漏等问题。

访问*[【http://caliburnmicro.codeplex.com/】](http://caliburnmicro.codeplex.com/)*站点，点击*源代码*标签。您应该会在左侧看到一个源代码树，以及右上角菜单上的*下载*链接。只需点击页面右侧的*下载*链接，即可将完整的源代码下载到您的本地机器。

下一步是提取源代码，并在 Caliburn 中找到与 EventAggregator 相关的类。微框架,然后对其应用单例模式，使其在我们的应用中简单易用。您可以通过以下步骤实现这一点:

1.  将下载的*caliburnmicro-40cc 11e 10 a6c . zip*文件解压到你机器上的任意位置。你会注意到源代码会被提取到*caliburnmicro-40cc 11 e 10 a6 c*文件夹下。请注意，下载时文件名(以及文件夹名)可能不同，这取决于 codeplex 网站上的最新更新。
2.  打开*卡利本。Micro.Silverlight* 文件夹位于 *src* 文件夹内。请注意，WinRT 版本的更新是在撰写本书时在该文件夹下进行的；这可能会在 Caliburn 的未来版本中有所改变。微观框架。您应该继续访问 codeplex 网站以接收最新的更改。
3.  找到两个与事件聚合器相关的类，名为 *EventAggregator.cs* 和 *ExtensionMethods.cs* ，名为*。Micro.Silverlight* 文件夹。
4.  打开 *ExtensionMethods.cs* (在记事本或 Visual Studio 中)，定位并复制一个适用于*IEnumerable<T>T6】的静态扩展方法 *Apply < T >* ，粘贴到 *FinanceHub 下的空白 *EventAggregator.cs* 。基础结构*命名空间作为名为 *ExtensionMethods* 的静态类。

    ```cs
    /// <summary>
    /// Generic extension methods used by the framework.
        ///Copied from Caliburn.Micro Framework
    /// </summary>
    public static class ExtensionMethods
    {
        /// <summary>
        /// Applies the action to each element in the list.
        /// </summary>
        /// <typeparam name="T">The enumerable item's type.        /// </typeparam>
        /// <param name="enumerable">The elements to enumerate.        /// </param>
        /// <param name="action">The action to apply to each item         /// in the list.</param>
        public static void Apply<T>        (this IEnumerable<T> enumerable, Action<T> action)
        {
            foreach (var item in enumerable)
            {
                action(item);
            }
        }
    }
    ```* 
5.  接下来从框架中打开 *EventAggregator.cs* (在记事本或 Visual Studio 中)，并将该类复制并粘贴到 finance hub*event aggregator . cs*。请注意，我们利用了整个类，所以没有解释完整的代码，而只是关注于我们为了简化实现所做的修改。您可以访问 codeplex 网站上的文档，以获得对 Caliburn 的更多了解。微观框架实现。
6.  我们要做的第一个修改是删除支持超越 WinRT 的额外代码，这不是我们的目的所要求的。定位预处理指令 *#If WinRT，*我们将保留该指令下的代码，但删除 *#If WinRT* 指令语句，因为我们只需要支持 WinRT 选项。接下来找到预处理指令 *#else* ，这是针对 Silverlight 特定实现的。选择 *#else* 指令及其下的代码，并将其移除。最后，还要删除不需要的 *#if* 和 *#end if* 指令。现在是时候应用我们的定制代码了，它将为 *EventAggregator* 类实现一个 singleton 模式，并将公开一个类型为 *IEventAggregator* 的静态属性*实例*。我们将使用这个*实例*来发布和订阅来自我们的*视图模型*的事件，我们将在本章的后面开发这些事件。在 *EventAggregator* 类实现的*开头的 *EventAggregator* 类中添加以下代码:

    ```cs
    /// <s*ummary* >
    private static IEventAggregator instance;

    /// <summary>
    /// Gets the singleton instance.
    /// *</summ* ary>
    public static IEventAggregator Instance
    {
        get
        {
            if (instance == null)
                *{*
                    instance = new EventAggregator();
                }
            re
    *turn instance;*
        }
    }

    ```* 

 *我们完成了 *EventAggregator* 类的实现；是时候保存你的项目并编译它以确保没有编译错误存在 *ts。*

导航服务

当遵循 MVVM 模式时，我们需要实现一个抽象的导航服务,它将允许从视图模型导航到给定的页面，而不是在视图中实现。由于导航方法在视图中可以使用帧控制，这些方法需要被抽象并以这样的方式公开，即导航也可以从视图模型中实现。好消息是，如果您有使用遵循 MVVM 模式的 Silverlight 导航应用程序或 Windows Phone 7 应用程序的经验，您必须使用 NavigationService 来提供来自 ViewModel 类的视图导航。Windows 8 应用程序在实现*导航服务*T5】接口时，遵循了类似的实现方法，但稍有改动。我们开始吧！

添加*导航服务*界面

导航服务是视图相关的，因为它使用了*页面*基类的*框架*对象。有一些实现将*框架*对象传递给 ViewModel，从而让 ViewModel 知道视图！然而，这违反了关注点分离。这也限制了在同一个项目中拥有 View 和 ViewModel 类，并且您不能将它们开发为不同的库。为了克服这些问题，NavigationService 有各种实现，遵循抽象的*in navigation service*接口，定义了基本的导航方法。这个服务然后被注入到 ViewModel 中，从而允许在 ViewModel 的视图之间导航。

在*基础设施*文件夹下，添加一个名为*in navigation service . cs*的新的空白接口。首先，您需要添加以下附加引用，这些引用将支持由*页面*和*框架*类发起的导航事件:

```cs
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Navigation;
```

在最简单的场景中，您可以实现支持以下导航功能的导航服务接口:

*   导航到给定页面
*   使用导航历史访问上一页
*   当导航正在进行时被通知，并且如果需要的话被允许取消导航

通常，您可能已经为您的 WPF/Silverlight 或 Windows Phone 应用程序实现了以下*in navigation service*接口，这些应用程序可以支持上述导航功能:

```cs
public interface INavigationService
{
    void InitializeFrame(Frame frame);
    event NavigatingCancelEventHandler Navigating;
    bool Navigate(Uri pageUri);
    bool Navigate(Uri pageUri, object parameter);
    void GoBack();
}
```

然而，当您为 Windows 8 应用程序编写导航服务时，在为 *Navigate* 方法传递参数时会有细微的差别。WinRT 不使用 *uri* 进行导航，而是使用一个实际的*类型*对象，支持强类型导航。例如，您定义了如下所示的*导航*方法(至少):

```cs
bool Navigate(Type type);
bool Navigate(Type type, object parameter);
```

遵循最佳实践并构建您的项目，以便它能够在不同的程序集中拥有 XAML 页面(视图)和视图模型，通过将类型作为*字符串*传递来扩展上面提到的*导航*方法的定义。

添加以下代码，为我们的项目定义*导航*方法:

```cs
bool Navigate(string type);
bool Navigate(string type, object parameter);
```

添加*导航服务*类

为了实现在导航服务接口中定义的实际方法，选择*基础设施*文件夹，添加一个名为*导航服务. cs* 的新的空白类，并添加以下附加引用，这些引用将支持由*页面*和*框架*类发起的导航事件:

```cs
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Navigation;
```

下面的代码片段展示了这个类的实现，它非常简单明了。如果您快速查看它，您会看到它实现了以下内容:

*   为*导航*事件注册一个处理程序，并将该事件转发给监听视图模型(如果有的话)。
*   实现使用*框架的*导航*方法。导航*方法以加载由数据类型指定的内容
*   实现使用*框架的 *GoBack* 方法。GoBack* 方法导航到后退导航历史中最近的项目

```cs
namespace FinanceHub.Infrastructure
{
    public class NavigationService : INavigationService
    {
        private Frame _mainFrame;
        public event NavigatingCancelEventHandler Navigating;

        public void InitializeFrame(Frame frame)
        {
            _mainFrame = frame;
        }

        public bool Navigate(string type, object parameter)
        {
            return _mainFrame.Navigate                (Type.GetType(type), parameter);
        }

        public bool Navigate(string type)
        {
            return _mainFrame.Navigate(Type.GetType(type));
        }

        public void GoBack()
        {
            if (_mainFrame.CanGoBack)
            {
                _mainFrame.GoBack();
            }
        }
     }
}

```

我们完成了导航服务的实现；是时候保存您的项目并编译它，以确保没有编译错误存在。注意，这一次您可能会得到一个关于没有使用*导航*事件的警告，这是显而易见的，因为我们还没有使用它。所以不用担心！

![image](img/.jpg) **注意**使用*字符串*版本的*导航*方法时一定要小心；您必须指定完全限定名，如下所示:

navigationService.Navigate("FinanceHub.StockDetails");

实现 ViewModelLocator 类

实现 viewmodelLocator 类的主要好处之一是，您不仅可以通过利用 IoC 和依赖注入实现方法来分配和初始化 ViewModel 并在上下文中设置控件的 DataContext，还可以为 visual studio 甚至 expression blend 提供设计时数据或设计时 ViewModel 实例！

要创建 ViewModel locator 类，首先选择 *Infrastructure* 文件夹，添加一个名为 *ViewModelLocator.cs* 的新的空白类，并添加以下附加引用，这些引用将支持不同视图的数据绑定的视图模型的实现，使用 MetroIoc 作为类型容器。

```cs
using FinanceHub.Model;
using FinanceHub.Infrastructure;
using FinanceHub.ViewModel;
using MetroIoc;
```

首先，我们需要创建一个容器，并向 IoC 注册它，以便以后可以使用它来注册和解析视图模型的其他类型和实例。为此，定义一个类型为 *IContainer* 的私有 *Lazy* 类实例。注意，惰性初始化发生在第一次*惰性<图标容器>的时候。值*属性被访问。 *CreateContainer* 方法使用 MetroIoC 提供的本机 *MetroContainer* 类对此进行初始化。最后，我们在类的构造函数中初始化容器的私有实例。

```cs
private Lazy<IContainer> container;
public IContainer Container
{
    get { return container.Value; }
}

public ViewModelLocator()
{
    container = new Lazy<IContainer>(CreateContainer);
}

private IContainer CreateContainer()
{
    var container = new MetroContainer();

    container.RegisterInstance(container);
    container.RegisterInstance<IContainer>(container);
    container.Register<INavigationService, NavigationService>
        (lifecycle: new SingletonLifecycle());
    return container;
}

```

注意，这里我们使用 *MetroIoc* 的*register instance*方法注册了 *MetroContainer* 的实例。我们还将 *NavigationService* 注册为 singleton，使用 *MetroIoc* 的 *Register* 方法，并将 lifecycle 指定为 *SingletonLifecycle* 。

我们完成了 *ViewModelLocator* 类的实现；是时候保存您的项目并编译它，以确保没有编译错误存在。在 ViewModel 类的实现过程中，我们将重新访问这个类来定义与 ViewModel 类相关的属性，该属性将用于与相关视图的绑定。

实现 *DelegateCommand* 类

作为一名 XAML 开发人员，您可能知道并且可能已经实现了 delegate command 类，该类允许您在不同的视图模型中使用 ICommand 接口创建类型安全且可绑定的可重用命令。

要创建委托命令类，首先选择*基础结构*文件夹，添加一个名为 *DelegateCommand.cs* 的新的空白类，并添加以下附加引用来支持所需的实现。

```cs
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Windows.Input;
using Windows.UI.Xaml.Input;
```

现在使用 *ICommand* 接口实现一个可重用的命令，它主要接受两个委托:

*   当 *ICommand 时调用第一个委托。执行【对象参数】*被调用。
*   当 *ICommand 时，第二个代表评估命令的状态。CanExecute(Object param)* 被调用。

您还必须实现一个方法，在我们的例子中命名为 *RaiseCanExecuteChanged()* ，它触发 *CanExecuteChanged* 事件。这导致 UI 元素重新评估命令的 *CanExecute()* 。

以下代码片段演示了上述 *DelegateCommand* 类的实现:

```cs
public class DelegateCommand : ICommand
{
    private readonly Action<object> _execute;

    private readonly Func<bool> _canExecute;

    /// <summary>
    /// Initializes a new instance of the DelegateCommand class that
    /// can always execute.
    /// </summary>
    /// <param name="execute">The execution logic.</param>
    /// <exception cref="ArgumentNullException">
         ///If the execute argument is null.</exception>
    public DelegateCommand(Action<object> execute)
        : this(execute, null)
    {
    }

    /// <summary>
    /// Initializes a new instance of the DelegateCommand class.
    /// </summary>
    /// <param name="execute">The execution logic.</param>
    /// <param name="canExecute">The execution status logic.</param>
    /// <exception cref="ArgumentNullException">
        ///If the execute argument is null.</exception>
    public DelegateCommand(Action<object> execute, Func<bool> canExecute)
    {
        if (execute == null)
        {
            throw new ArgumentNullException("execute");
        }

        _execute = execute;
        _canExecute = canExecute;
    }

    /// <summary>
    /// Defines the method that determines whether the command can execute
        ///in its current state.
    /// </summary>
    /// <param name="parameter">
        ///This parameter to be passed as command argument</param>
    /// <returns>true if this command can be executed; otherwise, false.        ///</returns>
    [DebuggerStepThrough]
    public bool CanExecute(object parameter)
    {
        return _canExecute == null ? true : _canExecute();
    }

    /// <summary>
    /// Defines the method to be called when the command is invoked.
    /// </summary>
    /// <param name="parameter">
        ///This parameter to be passed as command argument</param>
    public void Execute(object parameter)
    {
        if (CanExecute(parameter))
        {
            _execute(parameter);
        }
    }
    /// <summary>
    /// Occurs when changes occur that affect whether         ///the command should execute.
    /// </summary>
    public event EventHandler CanExecuteChanged;

    /// <summary>
    /// Raises the <see cref="CanExecuteChanged" /> event.
    /// </summary>
    public void RaiseCanExecuteChanged()
    {
        var handler = CanExecuteChanged;
        if (handler != null)
        {
            handler(this, EventArgs.Empty);
        }
    }
}
```

我们完成了 *DelegateCommand* 类的实现；是时候保存您的项目并编译它，以确保没有编译错误存在。

实现视图模型类

到目前为止，我们已经完成了 MVVM 框架的实现，这是构建表示(视图)和数据源(模型)分离的基础。下一步也是最后一步是在 FinanceHub 应用程序的 *ViewModel* 文件夹下实现以下视图模型，这将创建一个属性集合并将它们与构建的视图绑定在一起。

*   **StocksPageViewModel—** 是一个主视图模型类，它主要绑定所有与股票相关的视图— *股票页面*视图、*股票信息视图*视图和*股票详细信息*视图—以显示股票和相关信息。
*   **stock ViewModel**—是一个简单的 ViewModel 类，它将绑定股票以确定股票是否被选择用于 *RemoveStock* 视图。
*   **AddRemoveStockModel**—ViewModel 类将绑定 *AddStock* 和 *RemoveStock* 视图来实现股票的添加和删除。

让我们实现上面的 ViewModel 类，并更改各自的视图，将视图与 ViewModel 绑定起来。

stockspageviewmodel view 模型

股票页面视图模型类是一个关键的视图模型类，它主要绑定所有与股票相关的视图— *股票页面*视图、*股票信息视图*视图和*股票详细信息*视图—以显示股票和相关信息。

添加 *StocksPageViewModel* 类

要创建股票页面视图模型类，首先选择 *ViewModel* 文件夹，添加一个名为*stockspageviewmodel . cs*的新空白类，并添加以下附加引用来支持所需的实现:

```cs
using System.Windows.Input;
using System.Collections.ObjectModel;
using Windows.UI.Xaml.Controls.Primitives;
using System.Runtime.Serialization;
using FinanceHub.Common;
using FinanceHub.Model;
using FinanceHub.Infrastructure;
```

从 *BindableBase* 基类中派生出 *StocksPageViewModel* 类，通过实现 *INotifyPropertyChanged* 接口提供变更通知的实现。Visual Studio 在*公共*文件夹中自动添加了 *BindableBase* 类。

```cs
public class StocksPageViewModel: BindableBase
```

接下来定义一个类型为*股票*的 *ObservableCollection* ，支持属性如下。

```cs
private ObservableCollection<Stock> stocks;

public ObservableCollection<Stock> Stocks
{
    get
    {
        return this.stocks;
    }
    internal set
    {
        this.stocks = value;
        this.OnPropertyChanged("Stocks");
    }
}
```

最后，定义如下所示的 *StocksPageViewModel* 构造函数，它将初始化*股票*集合和*导航服务*。

```cs
private INavigationService navigationService;

public StocksPageViewModel(INavigationService navigationService)
{
    this.Stocks = new ObservableCollection<Stock>();
    this.navigationService = navigationService;
}
```

更新*视图模型定位器*类

重新访问*基础设施*文件夹，打开现有的*视图模型定位器*类。在进行其他更改之前，首先添加对 ViewModel 的引用。

```cs
using FinanceHub.ViewModel;
```

当我们在 xaml 中将 *ViewModelLocator* 定义为资源时，定义的属性将提供到相应视图/页面的 *DataContext* 属性的绑定。所以我们需要通过添加属性 *StocksPageViewModel* 来更新 *ViewModelSelector* 类。请注意，IoC 将负责传递该类所需的依赖项，即 *StocksPageViewModel* 类的构造函数的 *NavigationService* 参数。我们只需要向 IoC 注册依赖关系，这样 IoC 就知道这个依赖关系，并且可以将它们作为构造器注入注入到 *StocksPageViewModel* 中。在创建 ViewModelLocator 类时，我们已经向 IoC 注册了 INavigationService 类型。稍后我们将从 *App.xaml.cs* 中为这个 *NavigationService* 类分配 Frame 属性。注意，这里我们使用 *MetroIoc* 的 *RegisterInstance* 方法将 *Stocks* 集合的一个实例注册为 *IList < Stock >* ，以便稍后我们使用相同的注册类型从 Ioc 中检索到 *RemoveStock* 视图。我们使用 *MetroIoc* 的 *Resolve* 方法来解析导航服务接口类型。

```cs
public StocksPageViewModel StocksPageViewModel
{
    get
    {
        var VM = Container.Resolve<StocksPageViewModel>();
        Container.RegisterInstance<IList<Stock>>(VM.Stocks);
        return VM;
    }
}

public INavigationService NavigationService
{
    get { return Container.Resolve<INavigationService>(); }
}
```

注意，在这里，*容器。导航服务*中*的 Resolve* 将返回*导航服务*类的 singleton 实例，它在前面的 *ViewModelLocator* 类中定义，而我们实现了基本的 *ViewModelLocator* 类。

更新 *App.xaml* 文件以添加 ViewModelLocator 作为键控资源

最后，打开项目的 *App.xaml* 文件，将 ViewModelLocator 添加为一个键控资源，使其在应用程序级别可用，以设置数据上下文并绑定到所需的 ViewModel 类。

为此，首先我们必须将 xml 名称空间 *infra* 定义如下，指向项目的 *Infrastructure* 文件夹中可用的 *ViewModelLocator* 类:

```cs
<Application
    x:Class="FinanceHub.App"
    FontName3">http://schemas.microsoft.com/winfx/2006/xaml/presentation  "
    xmlns:x=" http://schemas.microsoft.com/winfx/2006/xaml  "
    xmlns:infra="using:FinanceHub.Infrastructure"
    xmlns:local="using:FinanceHub">
```

接下来，在现有的 *AppName* 键控资源之后添加键控资源 *ViewModelLocator* ，如下所示:

```cs
<infra:ViewModelLocator x:Key="ViewModelLocator"/>
```

在应用程序级别设置*数据上下文*

如果您还记得，我们有 *MainPage.xaml* ，它充当应用程序的母版页。我们将使用 *ViewModelLocator* 设置它的 *DataContext* 属性。因此，在 *AppFrame* 中加载的所有页面(在 *MainPage.xaml* 中定义为 *Frame1* 的 *AppFrame* ，在[第 2 章](2.html)中实现视图期间讨论)将继承该值，因此可以绑定到 *StocksPageViewModel* 类的单个实例。

访问项目的*视图*文件夹，打开已有的 *MainPage.xaml* 页面，添加下面高亮显示的 DataContext 。

```cs
<Page
    x:Class="FinanceHub.View.MainPage"
    IsTabStop="false"
    DataContext="{Binding StocksPageViewModel,
        Source={StaticResource ViewModelLocator}}"
    FontName3">http://schemas.microsoft.com/winfx/2006/xaml/presentation  "
    xmlns:x=" http://schemas.microsoft.com/winfx/2006/xaml  "
    xmlns:local="using:FinanceHub.View"
    xmlns:d=" http://schemas.microsoft.com/expression/blend/2008  "
    xmlns:mc=" http://schemas.openxmlformats.org/markup-compatibility/2006  "
    mc:Ignorable="d" Margin="-1,0,1,0">
```

从 *StocksPage.xaml* 和 *StockDetails.xaml* 视图中删除默认绑定和资源

当我们为 Windows 8 应用程序创建 ItemsPage 或 SplitPage 类型的页面时，此类页面的模板已经为我们提供了绑定，以便开始使用示例数据。是时候移除这些默认绑定了，这样它就可以绑定到创建的股票绑定了。

访问项目的*视图*文件夹，打开现有的 *StocksPage.xaml* 页面，移除高亮显示的默认绑定 DataContext。

```cs
<common:LayoutAwarePage
    x:Name="pageRoot"
    x:Class="FinanceHub.View.StocksPage"
    DataContext="{Binding DefaultViewModel,
        RelativeSource={RelativeSource Self}}"
    IsTabStop="false"
    ---
    --->
```

现在打开 *StockDetails.xaml* 页面，删除类似的默认绑定 DataContext。

接下来重新访问 *StocksPage.xaml* 页面，定位*页面。资源*，并将资源 *itemsViewSource* 的绑定改为从 *Items* 指向*股票*集合，如下所示:

```cs
<Page.Resources>
    <!-- Collection of items displayed by this page -->
    <CollectionViewSource
        x:Name="itemsViewSource"
        Source="{Binding Stocks}" />
</Page.Resources>
```

同样对 *StockDetails.xaml* 页面进行同样的修改。

清除 StocksPage 视图的代码隐藏

让我们对代码隐藏进行一些清理，删除视图中早期的硬编码内容。

访问项目的*视图*文件夹，打开现有的 *StocksPage.xaml.cs* 代码隐藏

*   首先找到并删除本地的 *Stock* 类，因为我们不再需要它。
*   接下来，找到 LoadState 方法并删除该方法的所有现有代码。

现在打开 *StockDetails.xaml.cs* 代码隐藏页面，找到 *LoadState* 方法，删除下面一行代码:

```cs

var collection = new ObservableCollection<Stock>();
collection.Add(new Stock
    { Symbol = "MSFT",        

    OpenPrice = 30.05M,        
    Change = 0.25M,        
    CurrentPrice = 30.30M });
this.DefaultViewModel["Items"] = collection;
```

我们完成了清理工作；是时候保存您的项目并编译它，以确保没有编译错误存在。此时，如果您运行该应用程序，您应该会看到一个空白的应用程序，如图[图 4-2](#Fig2) 所示，没有股票瓷砖。

![9781430249085_Fig04-02.jpg](img/-02.jpg)

[图 4-2。](#_Fig2)无库存磁贴的绑定 FinanceHub 应用

通过 ViewModel 使用股票集合显示股票

此时，我们已经将视图与 *股票*集合绑定，因此，如果您在*股票*集合中添加一只或多只样本股票，您将能够在视图中以平铺方式看到它！

解析 SimulatedRandomStocksDetail.csv 文件

首先，让我们编写代码来解析一个样本股票数据文件——*simulatedrandomstocksdail . CSV*文件——这是我们在前一章中添加到 *Model* 文件夹下的。该文件为用户输入的符号提供随机股票值。与任何 csv 文件解析器一样，这里我们将创建一个新的异步函数 *GetRandomStockData* ，它将在现有的 *LocalStorageHelper* 类中异步地将 csv 文件解析为类型为 *Stock* 的集合，该类位于 *Common* 文件夹中。

访问*公共*文件夹，打开 *LocalStorageHelper* 类，首先添加以下引用，这样我们就可以访问*股票*类:

```cs
using FinanceHub.Model;
```

接下来添加以下代码来演示 *GetRandomStockData* 和 *GetRandomStockDataAsync* 函数:

```cs
public async static Task<IEnumerable<Stock>> GetRandomStockData()
{
    return await GetRandomStockDataAsync();
}

static async private Task<IEnumerable<Stock>> GetRandomStockDataAsync()
{
    var stocks = new List<Stock>();
    var data = new List<string[]>();
    var result = await Windows.Storage.PathIO.
        ReadTextAsync("ms-appx:///Model/SimulatedRandomStocksDetail.csv ");
    var stringdata = result.Replace("\r", string.Empty);
    foreach (var line in stringdata.Split('\n'))
    {
        data.Add(line.Split(','));
    }

    foreach (var item in data)
    {
        stocks.Add(new Stock
        {
            CurrentPrice = Decimal.Parse(item[0]),
            OpenPrice = Decimal.Parse(item[1]),
            Change = Double.Parse(item[2]),
            DaysRange = item[3],
            Range52Week = item[4]
            });
        }
        return stocks.AsEnumerable();
    }
}
```

新推出的*窗口。类提供了使用文件的绝对路径或 URI 来读写文件的帮助方法。如上图所示，我们使用了*窗口。storage . pathio . readtext async*方法读取*simulatedrandomstoksdetail . CSV*文件，然后将每个记录作为新的*股票*实例存储在*股票*集合中。*

在 Visual Studio 构建项目时，添加的*simulatedrandomstoksdetail . CSV*文件的行为取决于相应文件的 *BuildAction* 属性的值。当您添加*simulatedrandomstocksdail . CSV*文件时，其 *BuildAction* 属性将被设置为 *None* ，因此该文件将不会在构建过程中被编译，也不会包含在项目输出中。我们需要将这个文件作为已构建项目的输出的一部分，但它不需要编译。选择该文件并在 Visual Studio 中打开属性窗口。您应该看到 *BuildAction* 属性被设置为*None*；选择下拉菜单并将属性值更改为 *Content* ，这将包括项目输出的文件，但不会作为构建过程的一部分进行编译。

显示默认股票

现在我们需要设置可以调用 *GetRandomStockData* 函数的代码，随机映射可用的股票，并通过更新现有的 *StocksPageViewModel* 类将它们与视图绑定。我们开始吧！

访问 *ViewModel* 文件夹，打开 *StocksPageViewModel* 类，添加一个新的异步 *LoadData* 方法，该方法将调用 *GetRandomStockData* 并将检索到的股票数据存储到一个集合中，并添加 MSFT 股票和相关的随机信息作为默认的样本股票。以下是相关代码:

```cs
private IEnumerable<Stock> randomStockData;

private async void LoadData()
{
    this.randomStockData = new ObservableCollection<Stock>
        (await LocalStorageHelper.GetRandomStockData());
    this.Stocks.Add(this.GetNewStock("MSFT"));
}
```

如果你注意到， *LoadData* 方法调用了 *GetNewStock* 方法，这将基本上初始化并返回带有随机股票数据(从 CSV 文件中检索)的股票代码。下面的代码显示了 *GetNewStock* 方法:

```cs
private Stock GetNewStock(string symbol)
{
    System.Random RndNumber = new System.Random();
    int index = RndNumber.Next(0, 4);
    var newStock = this.randomStockData.ElementAt(index);
    newStock.Symbol = symbol;
    return newStock;
}
```

注意，我们使用的是*系统。Random* 方法从 *randomStockData* 集合中随机选择股票价值。

最后一步是在初始化时调用 *LoadData* 方法来显示股票。为此，您需要在初始化*股票*集合后，从*股票视图模型*类的构造函数中调用 *LoadData* 方法(如下图所示)。

```cs
public StocksPageViewModel(INavigationService navigationService)
{
    this.Stocks = new ObservableCollection<Stock>();
    this.navigationService = navigationService;
    this.LoadData();
}
```

稍微停顿一下。我们已经完成了显示股票信息的基础视图模型的实现。保存并构建项目，现在按 F5 运行项目。你现在应该在 StocksPage 视图中看到 MSFT 股票磁贴，如图[图 4-3](#Fig3) 所示，它是由 CSV 文件中的随机值填充的。请注意，在运行项目时，您可能会得到不同的值，因为它会从 CSV 文件中随机选择一个股票记录。

![9781430249085_Fig04-03.jpg](img/-03.jpg)

[图 4-3。](#_Fig3)显示在纸张页面视图中的装订纸张

现在，如果您单击 MSFT 股票板块，您应该得到 StockDetails 视图，显示从 CSV 文件中检索到的 MSFT 股票的详细信息。请注意，在运行项目时，您可能会得到不同的值，因为它会从 CSV 文件中随机选择一个股票记录。此外，请记住，目前我们只绑定了图块，而没有绑定库存信息，库存信息仍然是硬编码的(根据[第 2 章](2.html))，将在本章稍后进行更改。

持续库存状态

但是，如果你访问添加和删除股票应用栏，你会注意到

*   由于我们尚未实现与“移除库存”相关的 ViewModel，因此 MSFT 库存不会显示在“移除库存”弹出按钮中
*   不能使用“添加股票”弹出按钮添加和保存股票

在本节中，我们将实现将应用程序状态保存到本地存储所需的代码，以便下次启动应用程序时，它会向您显示以前添加的股票符号，并从 CSV 文件中分配随机值。为此，我们将异步调用我们在[第三章](3.html)中开发的 *LocalStorageHelper* 类的 *Save* 和 *Restore* 函数。

首先打开 *App.xaml.cs* 文件，让我们添加代码来保存应用程序暂停或终止时的*股票*收藏。为此，我们需要添加/更新下面突出显示的代码，将集合保存在 *App.xaml.cs* 文件中定义的现有 *OnSuspending* 事件中。该代码将*股票*集合序列化到本地存储中。

```cs
using FinanceHub.Model;
using FinanceHub.Infrastructure;
using FinanceHub.Common;

public static ViewModelLocator ViewModelLocator
{
    get { return (ViewModelLocator)Current.Resources["ViewModelLocator"]; }
}

private
async void OnSuspending(object sender, SuspendingEventArgs e)
{
    var deferral = e.SuspendingOperation.GetDeferral();
    //TODO: Save application state and stop any background activity

    var stocks = ViewModelLocator.Container.Resolve<IList<Stock>>();
    LocalStorageHelper.Data.Clear();
    foreach (var item in stocks)
    {
        LocalStorageHelper.Data.Add(item);
     }
     await LocalStorageHelper.Save<Stock>();

     deferral.Complete();
}
```

重新访问位于 *ViewModel* 文件夹下的 *StocksPageViewModel* 类的 *LoadData* 方法，并更新它(高亮显示的字体),以便它可以恢复应用程序的先前状态并填充股票，如果存在一个或多个股票的话；否则，将 MSFT 股票显示为默认股票。

```cs
private async void LoadData()
{
    this.randomStockData = new ObservableCollection<Stock>
        (await LocalStorageHelper.GetRandomStockData());

    await LocalStorageHelper.Restore<Stock>();

    if (LocalStorageHelper.Data.Count > 0)
    {
        foreach (Stock item in LocalStorageHelper.Data)
        {
            this.Stocks.Add(item);
         }
     }
     else
     {
         this.Stocks.Add(this.GetNewStock("MSFT"));
     }
 }
```

目前，由于我们还没有实现添加和删除股票的视图模型，当我们开发添加/删除股票的视图模型时，我们将再次访问状态持久性。

编译并运行项目，以确保不会出现任何错误。您应该仍然会得到如图[图 4-3](#Fig3) 和 [4-4](#Fig4) 所示的相同输出。

![9781430249085_Fig04-04.jpg](img/-04.jpg)

[图 4-4。](#_Fig4)库存详细信息视图中显示的绑定库存详细信息

![image](img/.jpg) **注意**此时，当您第一次编译和运行项目时，您可能会在 *Restore* 方法上得到一个错误，我们在 *StocksPageViewModel* 类的 *LoadData* 方法中使用了该方法。这是当前 WinRT RC 版本的一个潜在缺陷。我发现的解决方案是首先注释掉 *await LocalStorageHelper。恢复<股票>()；*行并运行项目。此时，您应该不会得到任何错误。现在，从调试控制菜单中选择*暂停和关闭*选项(仅在运行项目时出现)，这将暂停然后关闭应用程序。重新访问该类，取消对 *Restore* 方法的注释，从现在开始，您应该不会再收到任何错误。

库存详情页面中的布线库存信息

到目前为止，我们绑定了一些基本的东西，将股票显示为启动页面，并将数据保存到本地存储中。现在我们将导航连接到 StockDetails 页面，以显示所选股票的详细股票信息。为此，我们需要为名为 *itemGridView* 的 *GridView* 控件的 *ItemClick* 事件设置绑定。由于 Windows 8 Release Preview 和 Blend 5 Release Preview edition 尚不支持 EventToCommand 行为，并且 Blend 行为和触发器还不能绑定到 Command 以外的事件，因此我们将创建一个附加的属性帮助器类来克服这一限制，并允许将 *ItemClick* 事件绑定到我们的 ViewModel StocksPageViewModel 的 *ICommand* 实现。

首先在*公共*文件夹中创建一个新的*公共*类，名为*itemclichkhelper*，并添加以下引用来支持我们的需求:

```cs
using System.Windows.Input;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
```

您可能知道，Visual Studio 提供了几组代码片段，其中之一是为依赖项/附加属性创建。因此，我们将使用这个特性，而不是从头开始编写，这有点复杂。您需要按照以下步骤更新*itemclichelper*类，以创建一个附加属性，名称为*命令*:

*   在 *ItemClickHelper* 类中，键入 *propa* (用于定义附加属性的代码片段)并按 TAB 键两次。它将创建完整的代码来定义一个附加的属性！现在，您还会注意到，自动添加的代码的某些部分以黄色背景突出显示。我们需要提供适当的细节，以根据我们的需要完成附加属性的定义。
*   首先你会注意到 *GetMyProperty* 方法的 *int* 部分被选中；键入 *ICommand* 并按 TAB 键。您会注意到在整个代码中进行了适当的更改。
*   接下来它将选择 *GetMyProperty* 方法类型*命令*的 *MyProperty* 部分来创建属性名 *GetCommand* 。在整个代码中进行了适当的更改。
*   接下来，选择将转移到*所有者类别*；键入 *ItemClickHelper* 并按 TAB 键。
*   接下来，选择将转移到*属性元数据*标签内的 *0* 。类型*为空，命令属性改变*。

您会注意到 *CommandPropertyChanged* 方法没有定义，所以我们现在就这么做。该方法是一个回调，每次当*命令*属性的值发生变化时，依赖属性系统都会引发该回调。我们将连接 *ListViewBase* 控件的 *ItemClick* 事件处理程序，它将支持普通视图的 *GridView* 控件和快照视图的 *ListViewControl* ，如下所示。

```cs
private static void CommandPropertyChanged
    (DependencyObject d, DependencyPropertyChangedEventArgs e)
{
    // Attach click handler
    (d as ListViewBase).ItemClick += ItemClickHelper_ItemClick;
}
```

为了实现如下所示的*itemclichkhelper _ ItemClick*事件处理程序，我们将执行带有*命令*附加属性的绑定命令。当 *ItemClick* 事件发生时，这将向 *StocksPageViewModel* 类中的 *ICommand* 实现发送一个触发器。

```cs
private static void ItemClickHelper_ItemClick    (object sender, ItemClickEventArgs e)
{
    // Get ItemView
    var itemView = (sender as ListViewBase);

    // Get command
    ICommand command = GetCommand(itemView);

    // Execute command
    command.Execute(e.ClickedItem);
}
```

接下来访问并打开 *StocksPageViewModel* 类，创建类型为 *ICommand，*的属性 *StockSelectedCommand* ，如下所示:

```cs
private ICommand stockSelectedCommand;

public ICommand StockSelectedCommand
{
    get { return stockSelectedCommand; }
}
```

接下来，我们需要定义一个名为 *CurrentStock* 的附加属性，类型为 *Stock* ，如下所示，我们将使用该属性绑定到显示股票的 *StockDetails* 页面中的 *itemListView* 控件的 *SelectedItem* 属性:

```cs
private Stock currentStock;

public Stock CurrentStock
{
    get { return currentStock; }

    set
    {
        this.currentStock = value;
        this.OnPropertyChanged("CurrentStock");
     }
}
```

如果您还记得，我们的*导航*服务实现将需要*字符串*来导航到提供完全限定路径的页面。因此，访问并打开*基础设施*文件夹下的 *ViewModelLocator.cs* 类，并将 *StockDetails* 页面类型定义为全限定字符串，如下所示:

```cs
public const string StockDetailsViewType = "FinanceHub.View.StockDetails";
```

现在重新访问 *StocksPageViewModel* 类，并在构造函数中初始化 *StockSelectedCommand* ，如下所示:

```cs
public StocksPageViewModel(INavigationService navigationService)
{
    this.Stocks = new ObservableCollection<Stock>();
    this.navigationService = navigationService;
    this.stockSelectedCommand = new DelegateCommand(ExecuteStockSelected);
    this.LoadData();
}
```

新的 *ExecuteStockSelected* 方法的实现如下所示，其中您将把*当前股票*设置为 *GridView* 控件的 *ClickedItem* 参数，然后导航到*股票详情*视图。

```cs
private void ExecuteStockSelected(object param)
{
    if (param != null)
    {
        this.CurrentStock = param as Stock;
    }
    navigationService.Navigate(ViewModelLocator.StockDetailsViewType);
}
```

最后，打开 *App.xaml.cs* 文件，将主页面的 *AppFrame* 传递给现有 *OnLaunched* 方法中导航服务的 *InitializeFrame* 方法，如下图所示:

```cs
protected override void OnLaunched(LaunchActivatedEventArgs args)
{
    ---

    ViewModelLocator.NavigationService.InitializeFrame
        ((rootFrame.Content as MainPage).AppFrame);

    // Place the frame in the current Window and ensure that it is active
    Window.Current.Content = rootFrame;
    Window.Current.Activate();
}
```

在这一点上，重新构建项目，并确保您没有得到任何错误。

仅存的物品是装订视图的剩余部分。

为此，首先将 *GridView* 和 *ListView* 的 *Command* attached 属性绑定到我们的 *ItemClickHelper* 类，打开 *StocksPage.xaml* 页面，对 *itemGridView* GridView 和 *itemListView* ListView 控件进行更新，如下所示:

```cs
<GridView
    x:Name="itemGridView"
    common:ItemClickHelper.Command="{Binding StockSelectedCommand}"
    ---
    ItemTemplate="{StaticResource StockTilesTemplate}"/>

<ListView
    x:Name="itemListView"
    common:ItemClickHelper.Command="{Binding StockSelectedCommand}"
    ---
    ItemTemplate="{StaticResource StockTilesTemplate}"/>
```

现在需要移除 *itemGridView* 和 *itemListView* 的 *ItemClicked* 事件实现。为此，在 *itemGridView* GridView 控件和*item ListView*ListView 控件中找到 *ItemClick="ClickedStock"* ，并移除它们。然后转到代码隐藏页面，找到 *ClickedStock* 事件的实现(参见下面的代码)，并删除该代码。

```cs
void ClickedStock(object sender, ItemClickEventArgs e)
{
    this.Frame.Navigate(typeof(StockDetails));
}
```

接下来打开 *StockDetails.xaml* 页面，将 *itemListView ListView* 控件的 *SelectedItem* 属性绑定到 *CurrentStock* ，如下图所示:

```cs
<ListView
    x:Name="itemListView"
    ...
    SelectionChanged="ItemListView_SelectionChanged"
    SelectedItem="{Binding CurrentStock, Mode=TwoWay}"
    ItemTemplate="{StaticResource StockListTemplate}"/>
```

并添加在 *itemDetailGrid* 中创建的 *StockInfoView* 的 *DataContext* 属性，如下图所示:

```cs
<control:StockInfoView Grid.Row="1"
    DataContext="{Binding ElementName=itemListView, Path=SelectedItem}">
</control:StockInfoView>
```

最后一步是打开 *StockInfoView.xaml* 页面，将每个 *TextBlock* 控件的 *Text* 属性绑定到相关的 *Stock* 属性，并删除硬编码值，如下所示:

```cs
<StackPanel>
    <TextBlock Text="Stock Details"         Style="{StaticResource HeaderTextStyle}"
        Margin="5" />
    <TextBlock Text="Current Price"         Style="{StaticResource CaptionTextStyle}"
        Margin="5"/>
    <TextBlock Style="{StaticResource DetailTextStyle}"
        Text="{Binding CurrentPrice}" />
    <TextBlock Text="Open Price"         Style="{StaticResource CaptionTextStyle}"        Margin="5"/>
    <TextBlock Style="{StaticResource DetailTextStyle}"         Text="{Binding OpenPrice}" />
    <TextBlock Text="Today High and Low Range"
        Style="{StaticResource CaptionTextStyle}" Margin="5"/>
    <TextBlock Style="{StaticResource DetailTextStyle}"
        Text="{Binding DaysRange}" />
    <TextBlock Text="52 Weeks High and Low Range"
        Style="{StaticResource CaptionTextStyle}" Margin="5"/>
    <TextBlock Style="{StaticResource DetailTextStyle}"
        Text="{Binding Range52Week}" />
</StackPanel>
```

我们完成了实现，并使用 ViewModel 将所有视图与数据源绑定在一起。保存并编译，然后运行项目。您应该会看到与图 4-3 类似的屏幕，屏幕上显示的是默认的 MSFT 股票(不过，根据生成的随机数，这一次您可能会看到不同的股票信息值)。现在点击 MSFT 股票板块；您应该会看到带有 MSFT 磁贴的 StockDetails 页面，这一次，更新后的股票详细信息如图[图 4-5](#Fig5) 所示。注意显示的股票值；与我们上次从数据源收到的内容相比，这次有所不同(由于随机选择)。

![9781430249085_Fig04-05.jpg](img/-05.jpg)

[图 4-5。](#_Fig5)库存详细信息视图中显示的绑定库存信息

你可能知道，这是同一个操作系统，微软 Windows 8，你将用于你的普通台式机/笔记本电脑以及平板电脑(如微软 Surface)和 Windows phone。模拟器为您提供模拟功能，以展示您的应用程序与平板设备的兼容性，您可以水平(如图 4-5 中的[所示)或垂直(当您将设备旋转 90 度时)手持平板设备。当您水平握住设备时，应用程序将显示在“普通视图”中(在这种情况下，视图将使用 GridView)，当您垂直握住设备并将其旋转 90 度时，应用程序将更改为“快照视图”(在这种情况下，视图将使用 ListView)。正如你可能注意到的，我们之前已经通过实现适当的*itemclichkhelper*类以及从 GridView(普通视图)和 ListView(快照视图)调用 ItemClick 命令解决了这个问题。所以现在让我们试试。编译并重新运行这个项目，在模拟器上你会注意到第六和第七个命令是模拟将设备顺时针或逆时针旋转 90 度。如图](#Fig5) [图 4-6](#Fig6) 所示，你会得到 StocksPage 页面，然后当你点击股票磁贴，你会得到 StockDetails 视图。首先，您将只看到 stock info 视图的显示，当您单击 Back 按钮时，它将显示 StockDetails 视图的股票标题。如果您再次单击 back，您应该会返回到主 StocksPage 视图。

![9781430249085_Fig04-06a.jpg](img/-06a.jpg)

![9781430249085_Fig04-06b.jpg](img/-06b.jpg)

![9781430249085_Fig04-06c.jpg](img/-06c.jpg)

[图 4-6。](#_Fig6)快照视图中运行的 FinanceHub 应用程序

AddRemoveStockViewModel 视图模型

到目前为止，我们已经连接了应用程序导航，允许您导航应用程序视图(StocksPage 和 StockDetails 视图)，在这些视图中显示有限的股票信息。在本节中，我们将创建 ViewModel，它将允许用户使用 AddStockView 和 RemoveStockView 视图添加和删除股票。我们开始吧！

添加 *AddRemoveStockViewModel* 类

要创建一个添加删除股票视图模型类，首先选择 *ViewModel* 文件夹，添加一个新的空白 *public* 类，名为*addremovestockviewmodel . cs*。然后添加以下附加参考来支持所需的实现:

```cs
using System.Windows.Input;
using FinanceHub.Common;
using FinanceHub.Model;
using FinanceHub.Infrastructure;
```

像 *StocksPageViewModel* 类一样，从 *BindableBase* 基类派生出 *AddRemoveStockViewModel* 类，通过实现 *INotifyPropertyChanged* 接口提供变更通知的实现。Visual Studio 在*公共*文件夹中自动添加了 *BindableBase* 类。

```cs
public class AddRemoveStockViewModel: BindableBase
```

添加新股票

首先，我们将添加逻辑，以便在我们在 *StocksPageViewModel* 中创建的*股票*集合中添加新股票文件。我们将利用事件聚合器通知 *StocksPageViewModel* 关于新增加的股票代码。

为了将用户输入捕捉为股票符号，我们在“添加股票”弹出按钮中有一个文本框和一个按钮控件。添加一个名为 *Symbol* 的属性，类型为 *string* ，用于存储用户输入的股票代码；添加一个名为 *addCommand* 的 *ICommand* ，用于绑定到按钮的 *Command* 属性，如下图所示:

```cs
private string symbol;

public string Symbol
{
    get { return symbol; }

    set
    {
        symbol = value;
        this.OnPropertyChanged("Symbol");
     }
}

private ICommand addCommand;

public ICommand AddCommand
{
    get { return addCommand; }
}
```

现在添加 *AddRemoveStockViewModel* 构造函数并初始化*add command*T4 如下:

```cs
public AddRemoveStockViewModel()
{
    this.addCommand = new DelegateCommand(ExecuteAdd);
}
```

新的 *ExecuteAdd* 方法的实现如下所示，在这里您将传递一个消息(引发事件)，其中 *ActionEventArgs* 被设置为适当的动作( *StockAction.add* )以及我们想要传递给接收器组件的数据(*符号*值)。

```cs
private void ExecuteAdd(object param)
{
    // Notify Subscribers
    if (this.Symbol != null)
    {
        EventAggregator.Instance.Publish
            (new ActionEventArgs                 
      { Action = StockAction.Add, Data = this.Symbol });
        this.Symbol = null;
    }
}
```

我们案例中的接收器组件是*StocksPageViewMode*ViewModel，因此访问并打开 *StocksPageViewModel* 类，并为 *ActionEventArgs* 类型实现一个 *IHandle* 接口，如下所示:

```cs
public class StocksPageViewModel : BindableBase, IHandle<ActionEventArgs>
```

现在来看一下 *IHandle* 接口的实现，我们将在添加股票代码之前检查它是否重复。

```cs
public void Handle(ActionEventArgs e)
{
    if (e.Action == StockAction.Add)
    {
        if (this.Stocks.Count > 0 && !(this.Stocks.Where
            (c => c.Symbol.ToUpper() ==                  
     e.Data.ToString().ToUpper()).Count() > 0))
        {
            this.Stocks.Add(this.GetNewStock(e.Data.ToString().ToUpper()));
        }
    }
}
```

最后，在我们跳转到更改 XAML 页面之前，我们需要通过在现有的 *StocksPageViewModel* 的构造函数中添加以下代码来订阅 *EventAggregator* ，如下所示。

```cs
public StocksPageViewModel(INavigationService navigationService)
{
    this.Stocks = new ObservableCollection<Stock>();
    this.navigationService = navigationService;
    this.stockSelectedCommand = new DelegateCommand(ExecuteStockSelected);
    EventAggregator.Instance.Subscribe(this);
    this.LoadData();
}
```

现在让我们绑定 *AddNewStock.xaml* 视图。打开 XAML 页面，并对现有属性应用绑定

*   相关文本框控件的*文本*属性到*符号*属性
*   按钮控件的*命令*属性到*添加命令*属性

以下高度受限的代码演示了上述实现:

```cs
<TextBox x:Name="txtSymbol"Text="{Binding Symbol, Mode=TwoWay}"
    HorizontalAlignment="Left" TextWrapping="Wrap"
    VerticalAlignment="Top" Margin="5" Width="380"/>

<Button Content="Add"
Command="{Binding AddCommand}"
    HorizontalAlignment="Left"  VerticalAlignment="Top" Margin="5"/>
```

在用户控制级别将 *AddNewStockView* 视图的 *DataContext* 属性设置为 *AddRemoveStockViewModel* ，如下图所示:

```cs
<UserControl
    x:Class="FinanceHub.View.AddStockView"
    DataContext="{Binding AddRemoveStockViewModel,
        Source={StaticResource ViewModelLocator}}"
    FontName3">http://schemas.microsoft.com/winfx/2006/xaml/presentation  "
    xmlns:x=" http://schemas.microsoft.com/winfx/2006/xaml  "
    xmlns:local="using:FinanceHub.View"
    xmlns:d=" http://schemas.microsoft.com/expression/blend/2008  "
    xmlns:mc=" http://schemas.openxmlformats.org/markup-compatibility/2006  "
    mc:Ignorable="d" Width="400" Height="130"
    d:DesignHeight="300"
    d:DesignWidth="400">
```

最后一步是通过添加属性 *AddRemoveStockViewModel* 来更新 *ViewModelSelector* 类。我们将再次使用 *MetroIoc* 的 *Resolve* 方法来解析*AddRemoveStockViewModel*ViewModel 类型。打开 *ViewModelLocator* 类并添加以下代码:

```cs
public AddRemoveStockViewModel AddRemoveStockViewModel
{
    get { return Container.Resolve<AddRemoveStockViewModel>(); }
}
```

是时候检查添加股票的实现代码是否工作了。在调试模式下编译并运行项目。通过右键单击或从屏幕底部向上或从屏幕顶部向下滑动手指，调出应用程序栏菜单，然后单击添加按钮。您应该看到 Add Stock 弹出按钮并输入股票符号(它可以是任何文本，因为我们没有根据实时服务进行验证)，一旦您单击 Add 按钮，股票应该出现在 StocksPage 视图中，并带有从 CSV 文件分配的随机值。再添加几只股票，你可能会在股票页面视图中看到如图[图 4-7](#Fig7) 所示的股票板块。

![9781430249085_Fig04-07.jpg](img/-07.jpg)

[图 4-7。](#_Fig7)股票使用添加股票命令添加多种股票的页面视图

如果你点击其中一只股票(在[图 4-8](#Fig8) 中，是 Stock1)，那么你应该会看到 StockDetails 视图，该视图会显示与所选股票相关的股票信息，如图[图 4-8](#Fig8) 所示。

![9781430249085_Fig04-08.jpg](img/-08.jpg)

[图 4-8。](#_Fig8)多种股票的股票详细信息视图，显示所选股票的信息

请注意，在 StockDetails 视图中，您可以从一种股票切换到另一种股票以获得详细信息，甚至可以通过 Add stock 命令添加新股票。添加的股票将显示在股票列表末尾的股票详细信息视图中，显示在左侧。

现在是测试本地存储是否工作的时候了。从 Visual Studio 中挂起并关闭正在运行的项目，然后重新运行 FinanceHub 应用程序。您会看到所有添加的库存都被恢复，并以与添加到*库存页面*视图中相同的顺序显示。输出应该类似于您在[图 4-7](#Fig7) 和[图 4-8](#Fig8) 中看到的内容。

移除库存

如果您偶然点击了应用程序栏中的移除按钮，您会注意到移除库存弹出按钮仍然不包含任何库存。

要删除一个或多个股票，我们将显示一个当前股票代码列表和相关的复选框，允许用户检查一个或多个股票代码，并从应用程序中删除选定的股票代码。为此，我们需要扩展现有的*股票*类，使其具有额外的布尔类型 *IsSelected* 属性，该属性将指示是否移除股票。要添加该属性，请选择 *ViewModel* 文件夹并创建一个新的 *public StockViewModel* 类，添加所需的额外引用，然后从 *BindableBase、*派生该类，就像我们对前面的那些所做的那样。以下是相关代码:

```cs
using FinanceHub.Common;
using FinanceHub.Infrastructure;
using FinanceHub.Model;

namespace FinanceHub.ViewModel
{
    public class StockViewModel : BindableBase
    {
    }
}
```

接下来要更新该类，添加 *IsSelected* 布尔属性，如下所示:

```cs
public class StockViewModel : BindableBase
{
    public Stock Stock { get; set; }
    private bool isSelected;

    public bool IsSelected
    {
        get { return isSelected; }
        set
        {
            isSelected = value;
            this.OnPropertyChanged("IsSelected");
        }
    }
}
```

现在重新打开 *AddRemoveStockViewModel* 类，首先添加以下附加引用:

```cs
using System.Collections.ObjetModel;
```

接下来创建一个类型为 *StockViewModel* 和 *ICommand RemoveCommand* 的集合，如下所示:

```cs
private ObservableCollection<StockViewModel> stocks;
public ObservableCollection<StockViewModel> Stocks
{
    get
    {
        return this.stocks;
    }
    internal set
    {
        this.stocks = value;
        this.OnPropertyChanged("Stocks");
    }
}

private ICommand removeStockCommand;
public ICommand RemoveStockCommand
{
    get { return removeStockCommand; }
}
```

现在添加一个新的 *AddRemoveStockViewModel* 构造函数并初始化 *removeStockCommand* 如下:

```cs
public AddRemoveStockViewModel(IList<Stock> stocks) : this()
{
    this.Stocks = new ObservableCollection<StockViewModel>
        (stocks.Select(c => new StockViewModel { Stock = c }).ToList());
    this.removeStockCommand = new DelegateCommand(ExecuteRemove);
}
```

下面显示了新的 *ExecuteRemove* 方法的实现，其中您将传递一条消息(引发事件)，并将 *ActionEventArgs* 设置为适当的操作( *StockAction)。删除*)和数据(*股票*)，我们希望将这些数据传递给所选的要删除的每只股票的接收组件。

```cs
private void ExecuteRemove(object param)
{
    var stockToRemove = this.Stocks.        
       Where(c => c.IsSelected).Select(c => c.Stock);
    if (stockToRemove.Count() > 0)
    {
         foreach (var item in stockToRemove)
         {
             EventAggregator.Instance.Publish
                (new ActionEventArgs                     
       { Action = StockAction.Remove, Data = item });
          }
     }
}
```

现在返回到 *StocksPageViewModel* 类的 *Handle* 方法，并对其进行修改以添加对移除股票的支持，如下所示(突出显示的项目):

```cs
public void Handle(ActionEventArgs e)
{
    if (e.Action == StockAction.Add)
    {
        if (this.Stocks.Count > 0 && !(this.Stocks.Where
            (c => c.Symbol.ToUpper() ==                 
       e.Data.ToString().ToUpper()).Count() > 0))
        {
            this.Stocks.Add(this.GetNewStock(e.Data.ToString().ToUpper()));
        }
    }
    else
    {
        this.Stocks.Remove(e.Data as Stock);
    }
}
```

最后一步是设置所需的 DataContext 并设置到 *RemoveStockView* 视图的绑定。要实现这一点，选择视图文件夹并打开 *RemoveStockView.xaml* 文件。现在定位 *ListView* 并绑定到*股票*集合，并将 *SelectedItem* 属性绑定到*符号*。将*复选框*控件绑定到*库存。符号*并将*按钮*控件的*命令*属性绑定到 *RemoveStockCommand* 。下面突出显示的代码演示了这一点。

```cs
<ListView
    ItemsSource="{Binding Stocks}"
    SelectedItem="{Binding Symbol, Mode=TwoWay}"
    Background="{StaticResource AppBarBackgroundThemeBrush}">
    <ListView.ItemTemplate>
        <DataTemplate>
            <CheckBox
                Content="{Binding Stock.Symbol}"
                 IsChecked="{Binding IsSelected,Mode=TwoWay}" />
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>

<Button Content="Remove Selected"  HorizontalAlignment="Stretch"
    Command="{Binding RemoveStockCommand}" Grid.Row="1"  ></Button>
```

最后，在用户控件级别将 *RemoveStockView* 视图的 *DataContext* 属性设置为 *AddRemoveStockViewModel* ，如下图所示:

```cs
<UserControl
    x:Class="FinanceHub.View.RemoveStockView"
    DataContext="{Binding AddRemoveStockViewModel,
        Source={StaticResource ViewModelLocator}}"
    FontName3">http://schemas.microsoft.com/winfx/2006/xaml/presentation  "
    xmlns:x=" http://schemas.microsoft.com/winfx/2006/xaml  "
    xmlns:local="using:FinanceHub.View"
    xmlns:d=" http://schemas.microsoft.com/expression/blend/2008  "
    xmlns:mc=" http://schemas.openxmlformats.org/markup-compatibility/2006  "
    mc:Ignorable="d"
    Height="300" Width="250"
    Background="{StaticResource AppBarBackgroundThemeBrush}"
    d:DesignHeight="300"
    d:DesignWidth="400">
```

通过以上更新，我们已经完成了 ViewModel 的实施，从而也完成了遵循 MVVM 模式的 XAML Windows 8 finance hub 应用程序的实施。在调试模式下编译并运行项目。您应该仍然具有类似的功能，但是现在，如果您打开应用程序栏并单击 Remove 按钮，您应该会看到 Remove Stock 弹出按钮，其中所有当前股票符号都填充了相关的复选框。您可以选择多种要移除的纸张。[图 4-9](#Fig9) 展示了移除库存弹出按钮显示四种库存，我选择了两种要移除的库存。

![9781430249085_Fig04-09.jpg](img/-09.jpg)

[图 4-9。](#_Fig9)移除纸张弹出按钮可选择多种纸张以移除选定的纸张

现在，如果您点击移除所选按钮，您将看到所选的股票将从股票页面视图中移除，如图[图 4-10](#Fig10) 所示。

![9781430249085_Fig04-10.jpg](img/-10.jpg)

[图 4-10。](#_Fig10)更新的库存页面视图，不包括移除的库存

您应该看到 StockDetails 视图也反映了您通过添加和删除股票所做的更改；您还可以通过 StockDetails 视图执行添加和删除股票操作。

同样，让我们测试一下本地存储是否正常工作。从 Visual Studio 中挂起并关闭正在运行的项目，然后重新运行 FinanceHub 应用程序。您会看到移除的库存已从本地存储器中移除，只有剩余的库存被恢复并显示在*库存页面*视图中。

摘要

MVVM 模式中的视图模型封装了视图的表示逻辑和数据。它管理视图与所需模型类的交互，通过在视图模型中实现所需的属性和命令来支持数据绑定和变更通知事件。

这是使用 XAML 和 C#为 Windows 8 应用程序实现 MVVM 模式的最后一章。本章主要实现了 ViewModel，它包括 MVVM 核心框架，然后需要 ViewModel 类来支持股票信息绑定到股票页面、股票详细信息和删除股票视图，以及应用程序导航。它还实现了动作命令来支持股票选择以及添加和删除股票动作。我们还回顾了该项目的早期实现，删除了硬编码信息，并将其绑定到 ViewModel 属性和命令。

在下一章中，我们将稍微改变一下方式，但仍将专注于实现相同的目标。接下来的两章将按照 MVVM 设计模式重复开发相同的 Windows 8 FinanceHub 应用程序，但这次使用 HTML5 和 JavaScript。

不要忘记下载源代码。访问 [Chapter4](4.html) 文件夹，查看我们在本章开发的源代码。*