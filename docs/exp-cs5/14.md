# 十四、异步

C# 语言 5.0 中为异步编程添加了一个强大的新功能。这个新特性以两个新关键字的形式出现——`async`和`await`——这两个关键字用于使同步方法异步。当您在方法中使用这两个关键字时，C# 编译器会对您的方法代码执行转换，以生成适当的代码，如存根方法和状态机，从而在后台执行异步操作。这个新特性使得异步编程比. NET 中使用的现有异步模式容易得多。

这一章将定义同步和异步编程的基础，然后用中介绍的`Task`类解释异步编程 .NET 框架 4.0。它将解释如何在`Task`类中添加一个延续块，并使用不同的选项，如`TaskStatus`和`TaskContinuationOptions`。讨论了`Task`类中的异常处理，以展示这是如何变得更容易的。本章还将详细解释`async`和`await`，如何使用它们，以及 C# 编译器如何处理这两个关键字以在幕后实现必要的代码。最后，本章将展示如何使用关键字`async`和`await`来使用基于`Task`的异步模式。

### 同步和异步编程

同步操作在完成其作业之前不会返回给其调用者。例如，在同步上下文中，如果 Method1 调用 Method2，则在 CLR 完成 Method2 之前，程序控制不会返回 Method1，这使得同步操作成为阻塞操作。在同步上下文中，程序一次只允许做一件事。

[图 14-1](#fig_14_1) 演示了一个程序同步运行的行为，其中 Method1、Method2、Method3、Method4、Method5 是从一个程序中一个接一个调用的。每个方法大约需要 10 毫秒来完成它的操作，所以程序将被阻塞大约 50 毫秒来完成五个方法的执行。

![images](img/-01.jpg)

***图 14-1。**同步方法调用*

清单 14-1 展示了一个在程序中调用同步方法的例子，展示了同步操作需要大约 50 毫秒来完成它的执行。

***清单 14-1。**同步方法调用的例子*

`using System;
using System.Diagnostics;
using System.Threading;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            Method1();
            Method2();
            Method3();
            Method4();
            Method5();
            stopwatch.Stop();
            Console.WriteLine("Elapsed time: {0}ms",
                              stopwatch.ElapsedMilliseconds);
            Console.ReadKey();
        }
        static void Method1() { Thread.Sleep(10); }
        static void Method2() { Thread.Sleep(10); }
        static void Method3() { Thread.Sleep(10); }
        static void Method4() { Thread.Sleep(10); }
        static void Method5() { Thread.Sleep(10); }
    }
}`

该程序将产生输出(在本地运行时，输出可能会有所不同):

`Elapsed time: 50ms`

异步编程与同步编程相反:异步而不是同步地编写长时间运行的函数。异步方法的不同之处在于，并发是在长时间运行的函数内部发起的，而不是从函数外部发起的。异步编程在许多程序中使用，尤其是编写(通常是服务器端)应用，这些应用可以有效地处理大量的并发输入/输出(I/O)。第二个用途是使富客户端应用中的线程安全更容易。

[图 14-2](#fig_14_2) 展示了异步编程的行为，从中可以看出，如果 Method1 异步启动，那么它会立即将程序控制返回到它离开的地方继续其他操作。当 Method1 稍后完成它的执行时，它返回(或执行回调，如果有的话)给调用者。当执行方法 1 时，程序可以处理方法 2、方法 3、方法 4 和方法 5，如图[图 14-2](#fig_14_2) 所示。

![images](img/-02.jpg)

***图 14-2。**异步方法调用*

因此，虽然您需要等待大约 50 毫秒来完成使用同步编程的五个方法的执行，但是在异步编程中，您不需要阻塞程序那么长时间来继续一些其他操作。

那个 .NET Framework 允许您在不阻塞调用程序的情况下异步执行一些方法，并且这些异步方法可能在不同的线程上执行，从而允许调用程序在其他方法被调用后完成自己的工作。

在这些类型的异步编程场景中，通常希望实现以下特性:

> *   Allow certain tasks (methods) to be executed in different threads without blocking the calling thread.
> *   Allow the asynchronous method to be called back or continue to execute another method when it is finished.
> *   Allow the status of the task to be checked to determine whether the task is ready to run, whether it is completed, or if something goes wrong during execution.
> *   Allow information about the status of task progress.
> *   Allow to cancel a running task
> *   Allow handling asynchronous operations.
> 
> 过程中出现的异常

使用实现异步方法 .NET Framework，您可以使用以下技术:

> *   Asynchronous programming model [APM]
> *   Event-based asynchronous mode
> *   Task-based asynchronous programming
> *   Asynchronous programming based on asynchronous waiting

本章将探索使用基于`async`和`await`技术的异步编程 .NET 框架 4.5。基于`async`的异步编程基于基于`Task`的异步模式，使用`async`和`await`关键字。本章将探索基于`Task`的编程，帮助你理解基于`async`和`await`的异步编程的美妙之处。

### 异步编程使用任务

`Task`类用于表示 .NET，是在 .NET Framework 4.0 作为并行编程库的一部分。`Task`类具有更高的抽象级别，用于异步操作。这些任务是组合的，并使用线程池来管理正在分配的任务。

当实例化`Task`类时，将作业作为`Action`块传递，并从其中调用`Start`方法，根据可用线程调度任务的执行。或者，您可以将`Task`类的实例作为参数传递给其他一些方法(它接受 Task ),以便从那里执行。

通过为新操作启动新线程，可以使用`Thread`类来执行异步操作，但是它有一些限制，例如，很难从您正在等待的线程中获取数据到`Join`，除非您配置一个共享字段来传递数据。当您将要启动的线程完成其任务后，它不能自己启动新的线程。此外，最重要的是，在使用线程的并发编程中，异常处理并不容易。因此，使用线程编写异步操作变得非常繁琐和复杂，同步也成为另一个问题。由于线程间的上下文切换，`Thread`的使用也会降低性能。

`Task`类消除了大部分这些问题。当你实例化`Task`类时，`Task`的实例将被`TaskScheduler`调度执行(本章稍后讨论)，因此，你不需要维护`Thread`的创建。

#### 任务类在。网

在`mscorlib.dll`组件的`System.Threading.Tasks`命名空间中定义了`Task`类，如图 14-3 中的[所示。](#fig_14_3)

![images](img/-03.jpg)

***图 14-3。**系统中的任务类。来自 mscorlib.dll 程序集的 Threading.Tasks 名称空间*

[清单 14-2](#list_14_2) 展示了`Task`类的方法和属性。

***清单 14-2。**任务类的定义*

`public class Task : IThreadPoolWorkItem, IAsyncResult, IDisposable
{` `    **/* 8 overloaded */**
    public Task(Action action)                                    {}
    **/* 21 overloaded */**
    public ConfiguredTaskAwaitable ConfigureAwait(

             bool continueOnCapturedContext)                      {}
**    /* 4 overloaded */**
    public static Task Delay(int millisecondsDelay)               {}
    public void Dispose()                                         {}
    public static Task<TResult> FromResult<TResult>
                                (TResult result)                  {}
    public TaskAwaiter GetAwaiter()                               {}
    **/* 8 overloaded */**
    public static Task Run(Action action)                         {}
    **/* 2 overloaded */**
    public void RunSynchronously()                                {}
    **/* 2 overloaded */**
    public void Start()                                           {}

    **/* 5 overloaded */**
    public void Wait()                                            {}
    **/* 5 overloaded */**
    public static void WaitAll(params Task[] tasks)               {}
    **/* 5 overloaded */**
    public static int WaitAny(params Task[] tasks)                {}
    **/* 4 overloaded */**
    public static Task WhenAll(IEnumerable<Task> tasks)           {}
    **/* 4 overloaded */**
    public static Task<Task> WhenAny(IEnumerable<Task> tasks)     {}
    public static YieldAwaitable Yield()                          {}
    public object AsyncState                                      {}
    public TaskCreationOptions CreationOptions                    {}
    public static int? CurrentId                                  {}
    public AggregateException Exception                           {}
    public static TaskFactory Factory                             {}
    public int Id                                                 {}
    public bool IsCanceled                                        {}
    public bool IsCompleted                                       {}
    public bool IsFaulted                                         {}
    public TaskStatus Status                                      {}
}`

#### 任务的创建/等待

要创建一个任务，你可以使用来自`Task`类的`Run`方法，如[清单 14-3](#list_14_3) 所示。

***清单 14-3。**使用运行方法创建任务*

`using System;
using System.Threading.Tasks;`  `namespace Ch14
{
    class Program
    {
        static void Main()
        {
**            /* A task will be instantiated and scheduled to run sometime**
**             * later on and**
**             * return the instance of the Task to displayTask variable. */**
            Task displayTask = Task.Run(() =>
                                    Console.WriteLine("async in C# 5.0"));

**            /* Continue until the task completes */**
            while (true)
            {
**                /* To check whether the task has completed or not */**
                if (displayTask.IsCompleted)
                {
                    Console.WriteLine("Task completed!");
                    break;
                }
            }
            Console.ReadLine();
        }
    }
}`

该程序将产生输出:

`async in C# 5.0
Task completed!`

您也可以使用`Task`类中的`Start`方法来启动一个任务，如[清单 14-4](#list_14_4) 所示。

***清单 14-4。**使用任务构造器创建任务*

`using System;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
**             /* An instance of the Task will be instantiated. */**
            Task displayTask = new Task(
**                /* The Task will execute the Action block */**
                () => Console.WriteLine("async in C# 5.0"),
**                /* Task creation options */**
                TaskCreationOptions.None` `                );

            displayTask.Start();
            **/* The Task will execute sometimes later */**
            displayTask.Wait();
            **/* Explicitly wait for the task to finish */**
            Console.ReadLine();
        }
    }
}`

这将产生输出:

`async in C# 5.0`

#### 任务中任务创建选项的详细信息

在[清单 14-4](#list_14_4) 中，`Task`类`displayTask`的实例是使用`Task`类的构造函数实例化的，该构造函数接受一个`Action`块(`Action`块包含`Task`类将执行的操作的代码)和一个`TaskCreationOptions`枚举值，后者控制任务创建和执行的行为。当实例化一个任务时，您可以使用不同的`TaskCreationOptions`枚举值，正如在`mscorlib.dll`程序集的`System.Threading.Tasks`名称空间中定义的那样。[清单 14-5](#list_14_5) 显示了可以使用的`TaskCreationOptions`枚举的不同值。

***清单 14-5。**任务状态枚举*

`public enum TaskCreationOptions
{
**    /* It indicates that the created Task will be attached to the**
**     * parent in the Task hierarchy */**
    AttachedToParent              = 4,

**    /* It indicates to throw an InvalidOperationException when a**
**     * child task try to attach */**
    DenyChildAttach               = 8,

**    /* It prevents the immediate scheduler from being seen as the**
**     * current scheduler in the created task.*/**
    HideScheduler                 = 0x10,

**   /* It indicates that the newly created Task will be long running task. */**
    LongRunning                   = 2,

**   /* It indicates to use the default behavior when the Task will created.*/**
    None                     = 0,

**    /* It indicates that the Task scheduled to run sooner will run sooner**
**     * and the Task scheduled to run later will run later. */**
    PreferFairness                = 1
}`

清单 14-6 展示了`TaskCreationOptions`枚举的使用。

***清单 14-6。**任务返回值*

`using System;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task<string> displayTask = new Task<string>(
                         () => "async in C# 5.0", TaskCreationOptions.None);
            displayTask.Start();
            Console.WriteLine("Result from the Task : {0}",
                              displayTask.Result);
            Console.ReadLine();
        }
    }
}`

该程序将产生以下输出:

`Result from the Task : async in C# 5.0`

#### 关于任务状态的详细信息

在[清单 14-6](#list_14_6) 中，我们实例化了`Task`，它被 CLR 调度为稍后执行。`Task`启动器需要知道`Task`在执行时是已经完成、被取消还是出错。为了确定这一点，`TaskStatus` enum 跟踪您发起的`Task`的状态。在`mscorlib.dll`程序集的`System.Threading.Tasks`名称空间中定义了`TaskStatus`枚举。[清单 14-7](#list_14_7) 显示了您可以使用的`TaskStatus`枚举的不同值。

***清单 14-7。**任务状态枚举*

`public enum TaskStatus
{
**    /* It indicates that the task has been canceled.*/**
    Canceled                    = 6,

**    /* It indicates that the CLR sets this status when the task has been**
**     * initialized but has not been scheduled yet. */**
    Created                     = 0,

**    /* It indicates that the CLR sets Faulted status if there is any**
**     * unhandled exception.*/**
    Faulted                     = 7,

**    /* It indicates that the task completed successfully.*/**
    RanToCompletion             = 5,

**    /* It indicates that the Task is Running but has not completed yet.*/**` `    Running                     = 3,

**    /* It indicates that the CLR scheduled the Task internally but waiting**
**     * to be activated.*/**
    WaitingForActivation        = 1,

**    /* It indicates that the CLR finished executing the Task but waiting**
**     * for the attached child tasks to finish (if there is any).*/**
    WaitingForChildrenToComplete = 4,

**    /* It indicates that the CLR scheduled the task for execution still**
**     * waiting to execute.*/**
    WaitingToRun                = 2
}`

当您第一次实例化一个任务时，`Created`状态由 CLR 设置，任务一启动，它就将状态更改为`WaitingToRun`。已启动的任务将根据分配给该任务的调度在稍后的某个时间执行，当它开始运行时，CLR 将其状态更改为`Running`。如果它停止运行或正在等待任何子任务，它将获得`WaitingForChildrenToComplete`状态。当 CLR 完全完成任务的操作时，它将分配三种状态之一:

> *   `RanToCompletion`
> *   `Canceled`
> *   `Faulted`

`RanToCompletion`表示任务已经成功完成，`Canceled`表示任务已经取消，`Faulted`表示任务执行过程中出现异常。[清单 14-2](#list_14_2) 显示了`Task`类有三个属性:

> *   `IsCompleted`
> *   `IsCanceled`
> *   `IsFaulted`

它分别使用这些来确定来自`Task`类的`RanToCompletion`、`Canceled`或`Faulted`属性的状态。[清单 14-8](#list_14_8) 显示了使用`Task`类的`IsCompleted`、`IsCanceled`和`IsFaulted`属性来确定任务完成状态。

***清单 14-8。**is completed、IsCanceled 和 IsFaulted 的例子*

`using System;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task<string> displayTask = Task.Run(() =>
            {
**                /* To simulate as doing something.*/**` `                for (int i = 0; i <= Int16.MaxValue; ++i) ;
                return "async in C# 5.0";
            });
            Console.WriteLine("Result from the Task : {0}",
                              displayTask.Result);

            if (displayTask.IsCompleted)
               Console.Write(TaskStatus.RanToCompletion.ToString());
            if (displayTask.IsCanceled)
               Console.Write(TaskStatus.Canceled.ToString());
            if (displayTask.IsFaulted)
               Console.Write(TaskStatus.Faulted.ToString());
            Console.ReadLine();
        }
    }
}`

该程序将产生以下输出:

`Result from the Task : async in C# 5.0
RanToCompletion`

如果使用`ContinueWith`、`ContinueWhenAll`、`ContinueWhenAny`或`FromAsync`方法实例化一个任务，CLR 将使用`WaitingForActivation`作为这个任务实例的状态。或者，如果使用`TaskCompletionSource<TResult>`对象实例化一个任务，CLR 也会设置`WaitingForActivation`状态。清单 14-9 展示了任务不同状态的使用。

***清单 14-9。**任务状态的例子*

`using System;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task displayTask = Task.Run(() =>
            {
                Task.Delay(500000);
                for (int i = 0; i < byte.MaxValue; ++i) ;
                Console.WriteLine("async in C# 5.0");
            });

            while (true)
            {
                Console.WriteLine(displayTask.Status.ToString());
                if (displayTask.IsCompleted)
                    break;
            }
            Console.WriteLine(displayTask.Status.ToString());` `            Console.ReadLine();
        }
    }
}`

该程序将产生以下输出:

`WaitingToRun
Running
Running
Running
async in C# 5.0
Running
RanToCompletion`

您已经看到了如何启动一个`Task`类的实例，并将任务的实例留给调度程序在它被调度后执行。计划任务时，您可以继续其他操作，甚至不必等待任务完成。否则，您可以使用`Task`类的`Wait`方法显式地等待预定任务完成。清单 14-10 展示了来自`Task`类的`Wait`方法的使用。

***清单 14-10。**等待`the`任务完成*

`using System;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task displayTask = Task.Run(
                 () => Console.WriteLine("async in C# 5.0"));

            Console.WriteLine(
                   "Task completion status : {0}, waiting to finish....",
                   displayTask.IsCompleted);
            displayTask.Wait();
            Console.ReadLine();
        }
    }
}`

该程序将产生以下输出:

`Task completion status : False, waiting to finish....
async in C# 5.0`

#### 任务的继续

在异步编程中，延续代码块指的是那些将在完成异步操作后执行的语句。[图 14-4](#fig_14_4) 是指报表 5 中的图；程序控制移动到另一个位置异步执行一些操作。当这个异步操作完成它的操作时，程序控制将返回到语句 6 以完成语句 6 到 10。这可以通过将语句 6 到 10 记为将在异步操作完成其操作后执行的延续代码块来实现。

![images](img/-04.jpg)

***图 14-4。**异步方法中的延续*

语句 6 到 10 将被设置为一个延续代码块，当程序完成了 MethodA 中定义的异步操作时将被执行，如图[图 14-4](#fig_14_4) 所示。您可以使用以下方法设置任务的延续:

> *   Use the `OnCompleted` method
> *   Use the `ContinueWith` method
> *   Use the `await` statement

在下一节中，我们将探讨除了`await`语句之外的这些选项，我们将在本章的后面探讨。

##### 使用 OnCompleted 方法

在使用`Task`类的异步编程中，您可以在任务中定义延续代码块，以便在原始任务完成执行时执行。continuation 是一个回调函数，它在`Task`类中定义的操作完成后执行。通过在`OnCompleted`方法中设置延续的`Action`块，可以使用`TaskAwaiter`的`OnCompleted`方法定义延续。[清单 14-11](#list_14_11) 展示了使用`OnCompleted`方法继续一个任务。

***清单 14-11。**使用任务*的延续示例

`using System;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

namespace Ch14
{` `    class Program
    {
        static void Main()
        {
            ShowEvenNumbers();
            Console.WriteLine("Waiting.....");
            for (int i = 0; i <= Int16.MaxValue * 100; ++i) ;
            Console.ReadLine();
        }

        static void ShowEvenNumbers()
        {
**            /* A Task is instantiated*/**
            Task<int> evenNumbersTask = Task.Run(
                      () => Enumerable.Range(1,
                      new Random().Next(Int16.MaxValue)).Count(
                      item => item % 2 == 0));

**            /* Retrieved the awaiter from the Task instantiated earlier */**
            TaskAwaiter<int> awaiter = evenNumbersTask.GetAwaiter();

**            /* Setup the continuation block in the awaiter of the Task**
**             * evenNumbersTask */**
            awaiter.OnCompleted(() =>
            {
**                 /* Continuation code block */**
                Console.WriteLine("Complete, Total no of even : {0}",
                                  awaiter.GetResult());
            });

**            /* Following line or lines is not part of the continuation**
**             * code block in relation to the Task  evenNumbersTask */**
            Console.WriteLine("Schedule to complete...");
        }
    }
}`

该程序将产生以下输出:

`Schedule to complete...
Waiting.....
Complete, Total no of even : 10652`

当 CLR 执行从[清单 14-11](#list_14_11) 产生的可执行文件时，它的工作方式如图[图 14-5](#fig_14_5) 所示。

图 14-5 中的[显示:](#fig_14_5)

![images](img/-05.jpg)

***图 14-5。**延续和任务*

> 1.  The program moves to the `ShowEvenNumbers` method.
> 2.  Instantiate the task, and get the awaiter type `TaskAwaiter<int>` from the task by calling the `GetAwaiter` method of `task`. The `OnCompleted` method in `TaskAwaiter<TResult> (the awaiter for the evenNumbersTask Task) is` is used to set the continuation code block of the task, which will be executed after the job assigned to the task is finished. The `TaskAwaiter` or `TaskAwaiter<TResult>` structure is defined in the `System.Runtime.CompilerServices` namespace of the `mscorlib.dll` assembly.

清单 14-12 显示了`TaskAwaiter<TResult>`结构的定义。

***清单 14-12。**TaskAwaiter 结构*

`public struct TaskAwaiter<TResult> :
                         ICriticalNotifyCompletion, INotifyCompletion
{
    public bool         IsCompleted                              {}
    public void         OnCompleted(Action continuation)         {}
    public void         UnsafeOnCompleted(Action continuation)   {}
    public TResult      GetResult()                              {}
}`

来自`TaskAwaiter<TResult>`结构的`OnCompleted`方法用于设置当任务应该完成其执行时，任务的继续执行。`OnCompleted`方法从`TaskAwaiter<TResult>`结构内部调用`OnCompletedInternal`方法，如[清单 14-13](#list_14_13) 所示。

***清单 14-13。**on completed internal Method*

`internal static void OnCompletedInternal(
    Task task,  Action continuation,  bool continueOnCapturedContext,
    bool flowExecutionContext)
{
    if (continuation == null)` `    {
        throw new ArgumentNullException("continuation");
    }
    StackCrawlMark lookForMyCaller = StackCrawlMark.LookForMyCaller;
    if (TplEtwProvider.Log.IsEnabled(EventLevel.Verbose, ~EventKeywords.None))
    {
        continuation = OutputWaitEtwEvents(task, continuation);
    }

**   /* Setup the continuation for the Task */**
    task.SetContinuationForAwait(
            continuation, **/* continuation - represents continuation code**
**                           * block which execute after finishing the Task.*/**
            continueOnCapturedContext,
            flowExecutionContext,
            ref lookForMyCaller);
}`

在延续代码块中设置了`OnCompletedInternal`方法和其他参数，例如，当前捕获的任务执行上下文(这将在本章后面讨论)。这个延续代码块将在分配给任务的原始作业完成执行时执行。

> 3.在 CLR 为任务设置了延续之后，程序控制会立即返回到任务的发起者。

我们已经看到了如何使用`TaskAwaiter<TResult>`结构的`OnCompleted`方法来设置任务的延续。除了`OnCompleted`方法，您还可以使用`Task`类中的`ContinueWith`方法，这将在下一节中讨论。

##### 使用 ContinueWith 方法

为了设置任务的延续，您也可以使用来自`Task`类的`ContinueWith`方法。`ContinueWith`方法在内部为任务设置延续代码块。[清单 14-14](#list_14_14) 显示了一个`ContinueWith`方法的例子。

***清单 14-14。**与*连续的例子

`using System;
using System.Linq;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            ShowEvenNumbers();
            Console.WriteLine("Waiting.....");
            for (int i = 0; i <= Int16.MaxValue * 100; ++i) ;
            Console.ReadLine();` `        }

        static void ShowEvenNumbers()
        {
            Task<int> evenNumbersTask = Task.Run(
                      () => Enumerable.Range(1,
                                       new Random().Next(Int16.MaxValue)).
                                       Count(item => item % 2 == 0));

            evenNumbersTask.ContinueWith(task =>
            {
                Console.WriteLine("Complete, Total no of even : {0}",
                                                        task.Result);
            });

            Console.WriteLine("Schedule to complete...");
        }
    }
}`

该程序将产生以下输出:

`Schedule to complete...
Waiting.....
Complete, Total no of even : 12896`

我们已经看到了为任务设置延续代码块的两种不同方式。我们可以使用`TaskCreationOptions`来指定任务创建的行为；或者，当我们为任务设置延续时，我们可以使用`TaskContinuationOptions`枚举来指定任务延续的行为。

##### 关于任务继续选项的详细信息

在`mscorlib.dll`程序集的`System.Threading.Tasks`名称空间中定义了`TaskContinuationOptions`枚举，它们定义了任务的延续行为。[清单 14-15](#list_14_15) 展示了可以用来设置延续的`TaskContinuationOptions`枚举的不同值。

***清单 14-15。**任务延续选项枚举*

`public enum TaskContinuationOptions
{
    AttachedToParent               = 4,
    DenyChildAttach                = 8,
    ExecuteSynchronously           = 0x80000,
    HideScheduler                  = 0x10,
    LazyCancellation               = 0x20,
    LongRunning                    = 2,
    None                           = 0,
    NotOnCanceled                  = 0x40000,
    NotOnFaulted                   = 0x20000,
    NotOnRanToCompletion           = 0x10000,
    OnlyOnCanceled                 = 0x30000,
    OnlyOnFaulted                  = 0x50000,` `    OnlyOnRanToCompletion          = 0x60000,
    PreferFairness                 = 1
}`

#### 使用任务调度器调度任务

CLR 使用`TaskScheduler`来调度任务。默认任务计划程序基于 .NET Framework 4.0 `ThreadPool`。但是，如果您需要特殊功能，您可以创建自定义计划程序，并为特定任务或查询启用它。在`mscorlib.dll`程序集的`System.Threading.Tasks`名称空间中定义了`TaskScheduler`类。清单 14-16 显示了`TaskScheduler`类的定义。

***清单 14-16。**task scheduler 类的定义*

`public abstract class TaskScheduler
{
    protected TaskScheduler()                                        {}
    public static TaskScheduler FromCurrentSynchronizationContext()  {}    
    protected internal virtual bool TryDequeue(Task task)            {}
    protected bool TryExecuteTask(Task task)                         {}

    **/* abstract methods */**
    protected abstract bool TryExecuteTaskInline(Task task,
                            bool taskWasPreviouslyQueued);
    protected abstract IEnumerable<Task> GetScheduledTasks();
    protected internal abstract void QueueTask(Task task);

**    /* Properties */**
    public static TaskScheduler Current                              {}
    public static TaskScheduler Default                              {}
    public int Id                                                    {}
    public virtual int MaximumConcurrencyLevel                       {}

    **/*Event in TaskScheduler class */**
    public static event EventHandler<UnobservedTaskExceptionEventArgs>
        UnobservedTaskException                                      {}
}`

英寸 NET 中，有两种任务计划程序:

> *   Thread pool task scheduler
> *   Synchronization context task scheduler

英寸默认情况下，所有应用都使用`ThreadPool`任务调度器，它维护一个全局 FIFO(先进先出)工作队列。为每个应用域中的线程维护 FIFO。在调用`QueueUserWorkItem`(或`UnsafeQueueUserWorkItem`)方法时，CLR 会将任务保留在这个共享队列中，稍后会将其出队进行处理。

当 CLR 将任务排入队列时，它遵循两个线程:

> *   A top-level task, that is, a task that was not created in the context of another task, is placed in the global queue.
> *   A subtask or nested task created in the context of another task is placed in a local queue specific to the thread on which the parent task is executing. Local queues work in a first-in-first-out mode.

当线程准备好工作时，CLR 首先在本地队列中查找，如果有任何等待执行的工作项，CLR 将访问它们。[图 14-6](#fig_14_6) 显示了顶层任务和子任务的`TaskScheduler`队列策略，该子任务已经在另一个任务的上下文中实例化。

本地队列的使用不仅减轻了全局队列的压力，而且还利用了数据局部性。

![images](img/-06.jpg)

***图 14-6。**任务调度器*

### ExecutionContext 捕获上下文

每个线程都有一个与之关联的执行上下文数据结构，它是在`mscorlib.dll`程序集的`System.Threading`名称空间中定义的`ExecutionContext`类。`ExecutionContext`类允许用户代码跨用户定义的异步点捕获和传输执行上下文。这个捕获的上下文可以从其他地方访问，并在以后用于执行操作。清单 14-17 显示了`ExecutionContext`类的定义。

***清单 14-17。**execution context 类的定义*

`public sealed class ExecutionContext : IDisposable, ISerializable
{
    public      static ExecutionContext Capture()                            {}
    public      ExecutionContext CreateCopy()                                {}
    public      void Dispose()                                               {}
    public      void GetObjectData(SerializationInfo info,
                                StreamingContext context)                    {}
    public      static bool IsFlowSuppressed()                               {}
    public      static void RestoreFlow()                                    {}
    public      static void Run(ExecutionContext executionContext,
                     ContextCallback callback, object state)                 {}
    public      static AsyncFlowControl SuppressFlow()                       {}
}`

执行上下文包括与逻辑线程执行相关的所有信息，例如，安全设置(压缩堆栈、线程的主要属性和 Windows 标识)、主机设置和逻辑调用上下文数据。`ExecutionContext`用于捕获当前的执行上下文，并将其传递到相关的位置，从那里执行。例如，您可以将捕获的`ExecutionContext`传递给异步点，以在捕获的执行上下文上执行一些动作块。通过将执行上下文从一个线程设置到另一个线程来传输执行上下文会导致异常，除非您跨执行上下文进行复制。[清单 14-18](#list_14_18) 展示了一个状态机在捕获的执行上下文中的运行位置。

***清单 14-18。**在捕获的执行上下文上运行的状态机的例子*

`using System;
using System.Threading;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
**            /*Instantiates an instance of the State machine */**
            StateMachine sm = new StateMachine();

**            /*Initialize the State machine with it's default value*/**
            sm.State = 1;

**            /* Start the State machine */**
            sm.MoveNext();

**            /* Queue the captured execution context with the workitem in the**
**             * ThreadPool to process later. */**
            ThreadPool.QueueUserWorkItem(state =>
                RunLaterOn<object>(
**                    /* Get the current execution context */**
                    CaptureExecutionContext(),
**                    /* pass the callback code block */**
                    new Action<object>(Callback),
**                    /* The State machine which maintains the state */**
                    sm));

            **/* Do something else. */**
            for (int i = 0; i <= Int16.MaxValue; ++i)
                if (i % byte.MaxValue == 0)
                    Console.Write(".");
            Console.ReadLine();
        }

        **/* This code block capture the current execution context */**
        static ExecutionContext CaptureExecutionContext()
        {
            return ExecutionContext.Capture();
        }

        **/* This code block will run the callback code block on the**` `**         * captured execution context*/**
        static void RunLaterOn<T>(
                    ExecutionContext context, Action<T> callback, object state)
        {
            ExecutionContext.Run(context,
                                 new ContextCallback(Callback), state);
        }

        **/* This code block used as the callback */**
        static void Callback(object state)
        {
            ((StateMachine)state).MoveNext();
        }
    }

**    /* The State machine used to maintain the state of the operation */**
    public class StateMachine
    {
        public int State { get; set; }

        public void MoveNext()
        {
            switch (State)
            {
                case 0:
                    Console.Write("State 0");
                    State = 1;
                    break;
                case 1:
                    Console.Write("State 1");
                    for (int i = 0; i <= byte.MaxValue; ++i) ;
                    State = 0;
                    break;
                default:
                    Console.Write("State -1");
                    State = 10;
                    break;
            }
        }
    }
}`

该程序将产生以下输出:

`State 1.................................................................................State 0.
...............................................`

在[清单 14-18](#list_14_18) 中，一个状态机已经在`Program`类的`Main`方法中用其初始状态 1 进行了实例化。然后 CLR 从`State Machine`的实例中调用`MoveNext`方法来改变状态机的状态。当前的执行上下文是使用`CaptureExecutionContext`方法捕获的。这个被捕获的执行上下文和一个回调方法已经被传递给了`ThreadPool`，以将一个新的工作项目排队，以调度稍后运行。一旦在 `ThreadPool`中排队等待运行，程序控制将返回给调用者(即`Main`方法)来完成剩余的代码，也就是`for`循环块。

当在`ThreadPool`中排队的项目执行时，它将运行回调方法，并根据它在使用捕获的执行上下文之前所处的状态来改变状态机的状态。

#### 任务的例外

使用`Task`类的主要原因之一是使并发编程中的异常处理变得容易。当您使用`Task`类时，CLR 会将任务内部运行的代码块引发的未处理异常传播回实例化该任务的线程。如果您使用任务中的`Wait`方法或程序中的`Task<TResult>`类，CLR 将传播异常，您可以使用`try` - `catch`块来处理这些异常。任务调用代码块将在`try`块中，异常处理将在`catch`块中。

CLR 将所有异常聚集在一个`AggregateException`类中，该类是在`mscorlib.dll`程序集的`System`命名空间中定义的。[清单 14-19](#list_14_19) 显示了`AggregateException`类的定义。

***清单 14-19。**聚合异常类的定义*

`public class AggregateException : Exception
{
    **/* 7 overloaded constructors*/**
    public AggregateException()                                          {}
    public AggregateException Flatten()                                  {}
    public override Exception GetBaseException()                         {}
    public override void GetObjectData(
        SerializationInfo info, StreamingContext context)                {}
    public void Handle(Func<Exception, bool> predicate)                  {}
    public override string ToString()                                    {}
    public ReadOnlyCollection<Exception> InnerExceptions                 {}
}`

`AggregateException`类包含`InnerExceptions`属性，CLR 将所有聚集的异常放在该属性中。在从`AggregateException`类的`InnerExceptions`中枚举后，您可以获得所有原始异常。清单 14-20 展示了`AggregateException`类的用法。

***清单 14-20。**任务中的异常处理*

`using System;
using System.Linq;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            int limit = new Random().Next(Int32.MaxValue);` `            Task<int> evenNumbersTask = Task.Run(
                () => Enumerable.Range(1, limit).Count(item =>
                {
                    if (item == Int16.MaxValue)
**                        /* Out of Range will be concat with the original**
**                         * Framework given exception message */**
                        throw new ArgumentOutOfRangeException(
                                                "Out of Range....");
                    return item % 2 == 0;
                }));
            try
            {
                evenNumbersTask.Wait(); **/* Wait for the Exception to occur. */**
            }
            catch (AggregateException aggregateException)
            {
                aggregateException
                    .InnerExceptions
                    .Where(item => item is ArgumentOutOfRangeException)
                    .ToList()   **/* Contains ArgumentOutOfRangeException */**
                    .ForEach(age => Console.WriteLine(age.Message));
            }
        }
    }
}`

该程序将产生以下输出:

`Specified argument was out of the range of valid values.
Parameter name: Out of Range....`

##### 未观察到的任务任务异常

您在全局级别使用来自`TaskScheduler`类的`UnobservedTaskException`事件来订阅未观察到的异常。此事件的处理程序可用于记录错误。

##### 附属于子任务的异常

清单 14-21 显示了一个附加子任务的异常处理的例子。

***清单 14-21。**附加子任务的异常示例*

`using System;
using System.Linq;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()` `        {
            int limit = new Random().Next(Int32.MaxValue);

            var evenNumbersTask = Task.Factory.StartNew(() =>
            {
                var r = Task.Factory.StartNew(() =>
                {
                    Enumerable.Range(1, limit).Count(item =>
                    {
                        if (item == Int16.MaxValue)
                            **/* Out of Range will be concat with the original**
                             *** Framework given exception message */**
                            throw new ArgumentOutOfRangeException(
                                                  "Out of Range....");
                        return item % 2 == 0;
                    });
                }, TaskCreationOptions.AttachedToParent);
            }, TaskCreationOptions.AttachedToParent);

            try
            {
                evenNumbersTask.Wait();  **/* Wait for the Exception to occur. */**
            }
            catch (AggregateException aggregateException)
            {
                aggregateException
                    .Flatten()
                    .InnerExceptions
                    .Where(item => item is ArgumentOutOfRangeException)
                    .ToList()   **/* Contains ArgumentOutOfRangeException */**
                    .ForEach(age => Console.WriteLine(age.Message));
            }
        }
    }
}`

该程序将产生以下输出:

`Specified argument was out of the range of valid values.
Parameter name: Out of Range....`

##### 与子任务分离的任务的异常

清单 14-22 显示了一个与子任务分离的任务的异常处理的例子。

***清单 14-22。**与子任务分离的异常示例*

`using System;` `using System.Linq;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            int limit = new Random().Next(Int32.MaxValue);

            var evenNumbersTask = Task.Factory.StartNew(() =>
            {
                var r = Task.Factory.StartNew(() =>
                {
                    Enumerable.Range(1, limit).Count(item =>
                    {
                        if (item == Int16.MaxValue)
                            **/* Out of Range will be concat with the original**
**                             * Framework given exception message */**
                            throw new ArgumentOutOfRangeException(
                                                   "Out of Range....");
                        return item % 2 == 0;
                    });
                });
                r.Wait();
            });

            try
            {
                evenNumbersTask.Wait(); **/* Wait for the Exception to occur. */**
            }
            catch (AggregateException aggregateException)
            {
                aggregateException
                    .Flatten()
                    .InnerExceptions
                    .Where(item => item is ArgumentOutOfRangeException)
                    .ToList()   **/* Contains ArgumentOutOfRangeException */**
                    .ForEach(age => Console.WriteLine(age.Message));
            }
        }
    }
}`

该程序将产生以下输出:

`Specified argument was out of the range of valid values.
Parameter name: Out of Range....`

### 异步编程使用 Async 和 Await

在本章的前面，你学习了如何通过手动设置延续代码块来使用`Task`类编写异步方法。在本节中，您将探索如何使用 C# 5.0 的新特性— `async`和`await`关键字—来编写异步方法，而不必手动设置延续代码块。使用这些关键字，您将能够编写与同步代码具有相同结构和简单性的异步代码。

C# 5.0 中的异步函数很容易在应用中编写和处理，例如，I/O 绑定和 CPU 绑定的应用。如前所述，当您使用`Task`类进行异步操作时，您可以分配异步操作的延续，但是您需要手动设置。当在异步函数中使用`await`表达式时，您可以让 C# 编译器为您设置延续代码块。C# 编译器使用找到的第一个`await`语句后的剩余代码实现延续代码块。因此，为异步函数设置延续块的责任落到了 C# 编译器身上，而不是您。

因为您可以将此任务留给 C# 编译器，所以您可以编写代码来维护其逻辑结构，并消除许多在异步操作中可能出现的流程问题。异步函数使用`async`和`await`关键字，这些关键字需要包含一些元素:

> *   Asynchronous functions defined by `async` and `await` in C # must have possible return types, either `void` or one of `Task` or `Task <T>`.
> *   If you want to create a function, the asynchronous function needs to be marked with `async` modifier; Without the `async` modifier, the function will be called synchronous.
> *   The execution of asynchronous methods is different from that of synchronous methods because their execution is discontinuous. Using the `await` statement, the execution of the asynchronous method can be suspended, and the execution can be continued using continuation.

下面几节将更深入地探讨`async`和`await`关键字及其用法，稍后我们将探讨 C# 5.0 中异步实现机制的幕后操作，例如，如何使用状态机实现异步行为，以及如何将异步任务调度给`ThreadPool`。

#### 异步修改器

`async`是用于将一个方法标记为异步函数的修饰符，所以没有`async`修饰符的函数称为同步函数。`async`修饰语的语法是:

> *   When `async` modifier is used in method: `**async(optional) with method signature**`
> *   When `async` modifier is used in lambda expression: `**async (optional) with anonymous-function-signature   =>   anonymous-function-body**`
> *   When `async` modifier is used in anonymous method expression: `**async(optional)  with delegate explicit-anonymous-function-signature (optional)   block**`

清单 14-23 展示了一个使用`async`修饰符定义的异步方法的例子。

***清单 14-23。**异步的例子*

`using System;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task showNumber = ShowEvenNumbers();
            Console.ReadLine();
        }

**       /* The async modifier used to define the asynchronous method */**
        public static async Task ShowEvenNumbers()
        {
            await Task.Run(() => Console.WriteLine("Async Function"));
        }
    }
}`

该程序将产生以下输出:

`Async Function`

[清单 14-24](#list_14_24) 显示了异步方法的另一个例子，它使用了`async`修饰符来定义它并返回`Task`。

***清单 14-24。**使用不同返回语句的异步方法示例*

`using System;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task showNumber = ShowEvenNumbers();
            Console.ReadLine();
        }

        **/* The async modifier used to define the asynchronous method */**
        public static async Task<int> ShowEvenNumbers()
        {
            return await Task.Run(() =>
            {
                Console.WriteLine("Async Function");
            });
        }` `    }
}`

[清单 14-24](#list_14_24) 产生了以下编译时错误，因为`return`语句没有从`ShowEvenNumbers`方法返回任何整数值。

`Error        150        Cannot implicitly convert type 'void' to 'int'`

如果使用`Task<T>`作为异步方法的返回类型，则返回表达式必须隐式转换为类型`T`，例如，如果返回是`Task<string>`，那么异步方法的返回表达式必须是`string`。

任务返回异步方法的调用最初与同步函数相同，直到 CLR 找到第一个`await`表达式。

#### 恭候

`await`表达式用于暂停异步函数的执行，直到等待的任务完成其操作。在[清单 14-23](#list_14_23) 和[清单 14-24](#list_14_24) 中，`await`关键字用于异步方法。`await`的语法表达是:

`**unary-expression:**

        **…**
        **await-expression**
        **await-expression:**
                **await unary-expression**
        **statement-expression:**
                **…**
                **await-expression**`

当在用`async`修饰符标记的方法中使用`await`时，允许使用`await`表达式，否则编译器会生成编译时错误:

`The 'await' operator can only be used within an async method`

如果在 await 表达式(`AE`)中使用了`Task` ( `T)`)，则`await`关键字用于等待任务，例如:

`**AE = await T**`

然后，`T`必须有一个没有参数的`GetAwaiter`方法，但是它返回一个类型的`R`，它有以下可访问的成员:

`bool IsCompleted                         {get;}
void OnCompleted (Action);
void GetResult(); or
o     GetResult(); where o refers to a type`

当 C# 编译器在源代码中找到一个`await`关键字时，它会编译`await`语句，例如:

`**Get a awaiter (A) from the Task (T)**
**If A exists in T then**
**         Set the continuation using the OnCompleted method from the A.**`

C# 编译器随后对`await`表达式求值:

> 1.  类型为`TaskAwaiter`的 awaiter `A`从后面跟有`await Task T`的表达式中获得。`TaskAwaiter`用于设置异步函数的延续，并从异步函数中获取结果。`TaskAwaiter`定义为`mscorlib.dll`总成中的`struct`，定义见[清单 14-25](#list_14_25) 。
>     
>     ***清单 14-25。** `TaskAwaiter` T4 的定义】*
>     
>     `public struct TaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
>     {
>         public bool IsCompleted                                 **{}**
>         public void OnCompleted(Action continuation)            **{}**
>         public void UnsafeOnCompleted(Action continuation)      **{}**
>         public void GetResult()                                 **{}**
>     }`
> 2.  CLR then checks the status of the task by checking the `IsCompleted` attribute from awaiter `A` to see if the task has been completed.
> 3.  When the attribute `IsCompleted` returns true, the related continuation will be executed; otherwise, if it is false, the execution will be suspended, and the program control will be returned to the method calling the asynchronous method.
> 4.  When the waiting task is completed, the CLR executes the `GetResult` method from `TaskAwaiter` struct and returns the result to the caller of the asynchronous function, otherwise the result is nothing.

#### 基于 Async 和 Await 的异步程序的分析

在上一节中，我们已经探讨了 C# 中的两个关键特性`async`和`await`。本节将更详细地探讨 C # 编译器如何编译基于`async`和`await`的异步方法。

清单 14-26 展示了基于`async`和`await`的异步方法。这个程序从指定的数字范围中确定偶数的个数。当程序在`ShowEvenNumbers`方法中执行异步操作时，`Main`方法的`for loop`块会像在做其他长时间运行的操作一样让你从异步操作中得到输出。

***清单 14-26。**异步程序的例子*

`using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Console.WriteLine("{0,15}{1,46}{2,15}",
                              "Method", "Description", "Thread Id");` `Console.WriteLine("{0,15}{1,46}{2,15}",
                "Main", "Start Processing.....",
                Thread.CurrentThread.ManagedThreadId);

            **/* Call an async method */**
            Task showNumber = ShowEvenNumbers();

**            /* The for loop used to simulate as something else is executing**
**             * while the asynchronous operation is executing it's task.*/**
            for (int i = 0; i < Int64.MaxValue; ++i)
                if (i % Int32.MaxValue == 0)
                    Console.WriteLine("{0,15}{1,46}{2,15}",
                        "Main", "something else is doing......",
                        Thread.CurrentThread.ManagedThreadId);
**               /* Checking the Task whether it's completed or not */**
                else if (showNumber.IsCompleted)
                    break;

            Console.WriteLine("{0,15}{1,46}{2,15}",
                "Main", "Finished execution",
                Thread.CurrentThread.ManagedThreadId);
            Console.ReadLine();
        }

        public static async Task ShowEvenNumbers()
        {
            Console.WriteLine("{0,15}{1,46}{2,15}", "ShowEvenNumbers",
                "Processing is continuing.....",
                Thread.CurrentThread.ManagedThreadId);
            int limit = new Random().Next(Int32.MaxValue);
            string range = string.Format("({0},{1})", 1, limit);

        **    /* Initialize and schedule a Task to run sometime later on.*/**
            Task<int> evenNumbersTask = Task.Run(
                () => Enumerable.Range(1, limit).Count(item => item % 2 == 0));

    **        /* The await statement await the Task to complete later by**
**             * set up the continuation code block to execute after the**
**             * Task finishes it's job.*/**
            int count = await evenNumbersTask;

**            /* Following code block will be used as the continuation code**
**             * block for the evenNumbersTask and it will be setup by**
**             * the C# compiler. */**
            Console.WriteLine("{0,15}{1,46}{2,15}", "ShowEvenNumbers",
                string.Format("In {0} Total: {1} On Thread", range, count),
                Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine("{0,15}{1,46}{2,15}", "ShowEvenNumbers",
                "Processing is finished.....",
                Thread.CurrentThread.ManagedThreadId);
        }` `    }
}`

这个程序将产生输出。

`         Method                                     Description  Thread Id
           Main                           Start Processing.....          1
ShowEvenNumbers                   Processing is continuing.....          1
           Main                   something else is doing......          1
           Main                   something else is doing......          1
           Main                   something else is doing......          1
ShowEvenNumbers    In (1,1507146102) Total: 753573051 On Thread          3
ShowEvenNumbers                     Processing is finished.....          3
           Main                              Finished execution          1`

从[清单 14-26](#list_14_26) 的输出中，您可以看到`Main`方法启动了处理并调用了`ShowEvenNumbers`方法，该方法通过将`Task`分配给调度程序在它能够执行的时候执行，然后返回到`Main`方法做其他事情来开始处理。所有这些操作都在同一个线程中执行，如清单 14-26 的输出所示。您可以看到，稍后,`ShowEvenNumbers`方法显示它已经处理了结果，并继续执行其剩余的操作，例如，从`ShowEvenNumbers`方法的延续在控制台上显示`"Processing is finished"`。`ShowEvenNumbers`的所有处理都在线程 3 中执行，这与其他线程不同，但是调度器控制继续在可用线程上分配调度任务。[图 14-7](#fig_14_7) 展示了 C# 中`async`方法的基本控制流程。

![images](img/-07.jpg)

***图 14-7。**基本程序流异步程序*

当[清单 14-26](#list_14_26) 开始执行时，它从`Main`方法开始并继续执行，直到到达步骤 1。从那里，CLR 按照这些步骤执行程序，如[图 14-7](#fig_14_7) 中的数字所示:

> 1.  The program moves to the `ShowEvenNumbers` method.
> 2.  CLR continues to execute the statements from the `ShowEvenNumbers` method, such as displaying the initial `"Processing is continuing"` message on the console, generating the `Random` number, and instantiating the task.
> 3.  Once the CLR reaches the `await` expression, in order to execute the task, it will continue to be assigned to the recipient of the task, and the execution will be suspended.
> 4.  The control immediately returns to the `Main` method, to the point where it left off, and to the `ShowEvenNumbers` method in step 1.
> 5.  CLR will continue to execute the remaining statements from the `Main` method.
> 6.  Sometimes, when the waiting task (in step 3) has been completed, it will reach the point marked as step 6 in [Figure 14-7](#fig_14_7) to complete the execution of other operations, including all statements after `await` expression set in `ShowEvenNumbers` method, as the continuation of step 3.
> 7.  Complete the CLR `ShowEvenNumbers` method.

这解释了在 C# 中基于`async`和`await`的异步编程中使用的非常基本的高级工作流。下面几节将探讨更多关于 C# 中这些异步方法的操作。

### 幕后异步

在 .NET Framework 4.5 中，任何标有`async`关键字的方法都被认为是 C# 中的异步方法。C# 编译器将使用任务异步模式(TAP)执行必要的转换来异步实现该方法。

C# 编译器将异步方法编译成两个重要的代码块:

> *   *The stub method* contains the initial setting information of the asynchronous method, including generating the code related to the `AsyncTaskMethodBuilder` class and starting the state machine generated by the C# compiler for the method based on `async`.
> *   *The state machine* maintains the state of asynchronous methods. For example, as mentioned earlier, the method based on `async` resumes its execution by allocating continuation to process it later. The state machine keeps the state of the method before the recovery is started, where this will be what it will do after the recovery is started or when it finishes its execution.

本节将详细探讨 C# 编译器如何为基于`async`的方法生成必要的代码，以及这些生成的代码如何在运行时工作。

#### 编译时异步

[图 14-8](#fig_14_8) 展示了基于`async`的方法是如何被 C# 编译器重新编译的。那个 .NET Reflector 工具用于反编译从[清单 14-26](#list_14_26) 生成的可执行文件，以探索为`ShowEvenNumbers`方法生成的存根方法和状态机，如图[图 14-8](#fig_14_8) 所示。

![images](img/-08.jpg)

***图 14-8。**C # 编译器为异步方法生成代码*

[图 14-8](#fig_14_8) 展示了 C# 编译器将`ShowEvenNumbers`方法编译成两个代码块:

> *   The stub method is used to initialize the state machine generated by the C# compiler for the `ShowEvenNumbers` method. It will initialize the state machine with the default value–1 and start the state machine.
> *   The state machine is the core of the asynchronous method of `ShowEvenNumbers`, which maintains the state of the operation for later use when resuming the operation.

下一节探讨 C# 编译器生成的存根方法和 S `howEvenNumbers`方法的状态机。

##### 异步方法的存根方法

C# 编译器为[清单 14-26](#list_14_26) 中的`ShowEvenNumbers`异步方法生成存根方法，如[清单 14-27](#list_14_27) 所示。

***清单 14-27。** IL 版存根法*

`.method public hidebysig static class
        [mscorlib]System.Threading.Tasks.Task
        ShowEvenNumbers() cil managed
{
**    /* Code removed */**
    .maxstack 2
    .locals init (
        [0] valuetype Ch14.Program/<ShowEvenNumbers>d__5 d__,
        [1] class [mscorlib]System.Threading.Tasks.Task task,
        [2] valuetype   
            [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder
            builder)

    L_0000: ldloca.s d__

**    /* It creates AsyncTaskMethodBuilder and store into**
**     * the  <>t__builder  field */        **
    L_0002: call valuetype
            [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder
            [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder::
            Create()

    L_0007: stfld valuetype
            [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder
            Ch14.Program/<ShowEvenNumbers>d__5::<>t__builder

    L_000c: ldloca.s d__

**     /* Initiates the state machine with it's default value -1 */**
**    L_000e: ldc.i4.m1**
**    L_000f: stfld int32 Ch14.Program/<ShowEvenNumbers>d__5::<>1__state**` `    L_0014: ldloca.s d__
    L_0016: ldfld valuetype
            [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder
            Ch14.Program/<ShowEvenNumbers>d__5::<>t__builder
    L_001b: stloc.2
    L_001c: ldloca.s builder
    L_001e: ldloca.s d__

**    /* Start the state machine by executing the Start method from**
**     * the AsyncTaskMethodBuilder*/**
**    L_0020: call instance**
**            void**
**            [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder::**
**            Start<valuetype Ch14.Program/<ShowEvenNumbers>d__5>(!!0&)**

    L_0025: ldloca.s d__
    L_0027: ldflda valuetype
            [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder
            Ch14.Program/<ShowEvenNumbers>d__5::<>t__builder

**    /* Get the Task which has been initialized and scheduled to execute**
**     * later on */**
**    L_002c: call instance class**
**            [mscorlib]System.Threading.Tasks.Task**
**            [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder::**
**            get_Task()**

    L_0031: stloc.1
    L_0032: br.s L_0034
    L_0034: ldloc.1
    L_0035: ret
}`

这个存根方法是 C# 编译器为基于`ShowEvenNumbers` `async`的方法生成的一段重要代码，它负责通过将生成的状态机`<ShowEvenNumbers>d__5`设置为状态机的`<>1__state`字段，用在`L_000f`中设置的初始值–1 来初始化该状态机。在`L_0020`中，它将从`AsyncTaskMethodBuilder`类中调用`Start`方法来启动状态机`<ShowEvenNumbers>d__5`。稍后，它从`AsyncTaskMethodBuilder`类调用`get_Task`方法来获取任务(不管它是否完成)，这将用于访问来自`Task`类的结果(如果有)或获取任务的状态。

##### 异步方法的状态机

[清单 14-28](#list_14_28) 显示了 C# 编译器为清单 14-26 的[生成的状态机`<ShowEvenNumbers>d__5`。](#list_14_26)

***清单 14-28。**编译器生成的状态机*

`private struct <ShowEvenNumbers>d__5 : IAsyncStateMachine
{
    public  int                                   <>1__state;
    public  AsyncTaskMethodBuilder                <>t__builder;` `private object                                <>t__stack;
    private TaskAwaiter<int>                      <>u__$awaiter9;
    public  int                                    <count>5__8;
    public  Task<int>                             <evenNumbersTask>5__7;
    public  string                                 <range>5__6;
    public  Program.<>c__DisplayClass2            CS$<>8__locals3;

    private void MoveNext()
    {
        try
        {
            TaskAwaiter<int> CS$0$0001;
            bool <>t__doFinallyBodies = true;

            switch (this.<>1__state)
            {
                case -3:
                    goto Label_0196;

                case 0:
                    break;

                default:
                    this.CS$<>8__locals3 = new Program.<>c__DisplayClass2();

                    Console.WriteLine("{0,15}{1,46}{2,15}", "ShowEvenNumbers",
                        "Processing is continuing.....",
                        Thread.CurrentThread.ManagedThreadId);

                    this.CS$<>8__locals3.limit = new Random().Next(0x7fffffff);
                    this.<range>5__6 = string.Format("({0},{1})",
                                  1, this.CS$<>8__locals3.limit);

                    this.<evenNumbersTask>5__7 = Task.Run<int>(
                        new Func<int>(
                                this.CS$<>8__locals3.<ShowEvenNumbers>b__0));

                    CS$0$0001 = this.<evenNumbersTask>5__7.GetAwaiter();

                    if (CS$0$0001.IsCompleted)
                    {
                        goto Label_0104;
                    }
                    this.<>1__state = 0;
                    this.<>u__$awaiter9 = CS$0$0001;

                    this.<>t__builder.AwaitUnsafeOnCompleted<TaskAwaiter<int>,
                            Program.<ShowEvenNumbers>d__5>(
                                          ref CS$0$0001, ref this);
                    <>t__doFinallyBodies = false;` `                    return;
            }

            CS$0$0001 = this.<>u__$awaiter9;
            this.<>u__$awaiter9 = new TaskAwaiter<int>();
            this.<>1__state = -1;

        Label_0104:
            int introduced6 = CS$0$0001.GetResult();

            CS$0$0001 = new TaskAwaiter<int>();

            int CS$0$0003 = introduced6;
            this.<count>5__8 = CS$0$0003;
            Console.WriteLine("{0,15}{1,46}{2,15}", "ShowEvenNumbers",
                string.Format("In {0} Total: {1} On Thread",
                    this.<range>5__6, this.<count>5__8),
                    Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine("{0,15}{1,46}{2,15}", "ShowEvenNumbers",
                "Processing is finished.....",
                Thread.CurrentThread.ManagedThreadId);
        }
        catch (Exception <>t__ex)
        {
            this.<>1__state = -2;
            this.<>t__builder.SetException(<>t__ex);
            return;
        }
    Label_0196:
        this.<>1__state = -2;
        this.<>t__builder.SetResult();
    }

**    /* Code removed */**
}`

###### 状态机中的字段

C# 编译器将为它拥有的每个字段生成状态机的字段，如[表 14.1](#tab_14_1) 所示。

![images](img/.jpg)

![images](img/.jpg)

根据环境和在`async`方法中使用的局部变量的数量，字段可能会有所不同。

###### 状态机中的方法

C# 编译器为状态机生成两种方法:

> *   `MoveNext`: This method includes `switch` module, which is used to control the operation according to the state of the state machine.
> *   `SetStateMachine`: This method is used to set the state machine.

#### 运行时异步

当 CLR 开始执行基于`async`的异步方法时，它从 stub 方法开始执行，以初始化和启动状态机，调度任务，并为任务设置延续(如果有的话),并将异步任务留给调度程序在调度后执行。CLR:

> *   Start state machine
> *   Scheduling task
> *   Set continuation
> *   carry out a task
> *   Execution continuation

本节将探究这些步骤中涉及的细节，以展示 CLR 如何在运行时执行基于`async`的异步方法。CLR 通过调用`AsyncTaskMethodBuilder`类的`Create`方法，在`L_0002`中实例化`AsyncTaskMethodBuilder`类的一个实例，如[清单 14-27](#list_14_27) 所示。然后，`Create`方法实例化了`AsyncTaskMethodBuilder`类的一个实例:

`public static AsyncTaskMethodBuilder Create()
{
    return new AsyncTaskMethodBuilder();
}`

在实例化了`AsyncTaskMethodBuilder`类之后，CLR 执行其余的异步代码，如下面的章节所述。

##### 启动状态机

CLR 使用之前创建的`AsyncTaskMethodBuilder`来启动状态机`<ShowEvenNumbers>d__5`，方法是从它调用`Start`方法(图 14-9 中的步骤 1)。CLR 将来自存根方法的初始化状态机`<ShowEvenNumbers>d__5`作为输入传递给`AsyncTaskMethodBuilder`类的`Start`方法。[清单 14-29](#list_14_29) 显示了来自`AsyncTaskMethodBuilder`类的`Start`方法。

***清单 14-29。**从`AsyncTaskMethodBuilder`类到*类的`Start`法

`.method public hidebysig instance void Start<(System.Runtime.CompilerServices.
IAsyncStateMachine) TStateMachine>(!!TStateMachine& stateMachine) cil managed
{
    .custom instance void
    System.Diagnostics.DebuggerStepThroughAttribute::.ctor()
    .custom instance void __DynamicallyInvokableAttribute::.ctor()
    .maxstack 8
    L_0000: ldarg.0
    L_0001: ldflda valuetype
       System.Runtime.CompilerServices.AsyncTaskMethodBuilder'1
        <valuetype System.Threading.Tasks.VoidTaskResult>
        System.Runtime.CompilerServices.AsyncTaskMethodBuilder::m_builder
    L_0006: ldarg.1
    L_0007: call instance void
       System.Runtime.CompilerServices.AsyncTaskMethodBuilder'1
        <valuetype System.Threading.Tasks.VoidTaskResult>::
        Start<!!TStateMachine>(!!0&)
    L_000c: ret
}`

`Start`方法从清单 14-29 的[中的`L_0007`类内部调用`Start`方法。`AsyncTaskMethodBuilder<VoidTaskResult>`类的`Start`方法在](#list_14_29)[清单 14-30](#list_14_30) 中演示。

***清单 14-30。**从`AsyncTaskMethodBuilder<TResult>`类到*类的`Start`法

`.method public hidebysig instance void Start
        <(System.Runtime.CompilerServices.IAsyncStateMachine) TStateMachine>
        (!!TStateMachine& stateMachine) cil managed
{
    .custom instance void System.Diagnostics.DebuggerStepThroughAttribute::.ctor()
    .custom instance void __DynamicallyInvokableAttribute::.ctor()
    .maxstack 8
    L_0000: ldarg.0

    L_0001: ldflda valuetype
            System.Runtime.CompilerServices.AsyncMethodBuilderCore
            System.Runtime.CompilerServices
                  .AsyncTaskMethodBuilder'1<!TResult>::m_coreState
    L_0006: ldarg.1

**    /* Call the Start method of the AsyncMethodBuilderCore which will**
**     * start the given state machine.*/**
    L_0007: call instance
            void System.Runtime.CompilerServices.AsyncMethodBuilderCore::
            Start<!!TStateMachine>(!!0&)` `    L_000c: ret
}`

从清单 14-30 中的[开始，CLR 调用`L_0007`中`AsyncMethodBuilderCore`类的`Start`方法，传递它作为输入接收的状态机。`Start`方法的内部工作方式如反编译的`Start`方法代码所示，如](#list_14_30)[清单 14-31](#list_14_31) 所示。

***清单 14-31。来自 AsyncMethodBuilderCore 类的** `Start`方法*

`.method assembly hidebysig instance void Start
    <(System.Runtime.CompilerServices.IAsyncStateMachine) TStateMachine>
    (!!TStateMachine& stateMachine) cil managed
{
    .custom instance void  
            System.Security.SecuritySafeCriticalAttribute::.ctor()
    .custom instance void
            System.Diagnostics.DebuggerStepThroughAttribute::.ctor()
    .maxstack 3
    .locals init (
        [0] class System.Threading.Thread thread,
        [1] valuetype System.Threading.ExecutionContextSwitcher switcher)
    **/* Code removed */**

**    /* The CLR calls the MoveNext method from the state machine to do a**
**     * transition in the state machine */**
    L_003b: callvirt instance void
            System.Runtime.CompilerServices.IAsyncStateMachine::MoveNext()

    /* Code removed */
    .try L_002b to L_0042 finally handler L_0042 to L_004b
}`

`AsyncMethodBuilderCore`类的`Start`方法从传递给它的状态机中调用`MoveNext`方法。[图 14-9](#fig_14_9) 展示了运行时存根方法和状态机`<ShowEvenNumbers>d__5`的执行。

![images](img/-09.jpg)

***图 14-9。运行时异步方法的**存根([清单 14-27](#list_14_27) )和状态机([清单 14-28](#list_14_28) )*

在图 14-9 的[步骤 2 中，CLR 带着它的默认值-1(从 stub 方法设置)来到状态机，并从状态机`<ShowEvenNumbers>d__5`执行`switch`块的默认部分。CLR 用提供的操作实例化了`Task`类的一个实例，该操作必须通过`Task`类的`Run`方法完成，该方法从`Task`类内部调用`StartNew`方法:](#fig_14_9)

`public static Task<TResult> Run<TResult>(Func<TResult> function)
{
    StackCrawlMark lookForMyCaller = StackCrawlMark.LookForMyCaller;` `return Task<TResult>.StartNew(
            null,
            function,
            new CancellationToken(),
            TaskCreationOptions.DenyChildAttach,
            InternalTaskOptions.None,
            TaskScheduler.Default,
            ref lookForMyCaller);
}` 

通过从`Task`类中调用`ScheduleAndStart`方法，`StartNew`方法启动一个任务并调度新创建的任务:

`internal static Task<TResult> StartNew(
    Task parent,
    Func<TResult> function,
    CancellationToken cancellationToken,
    TaskCreationOptions creationOptions,
    InternalTaskOptions internalOptions,
    TaskScheduler scheduler,
    ref StackCrawlMark stackMark)
{
**  /*Code removed*/**
    Task<TResult> task = new Task<TResult>(
        function,
        parent,
        cancellationToken,
        creationOptions,
        internalOptions | InternalTaskOptions.QueuedByRuntime,
        scheduler,
        ref stackMark);

**    /* Schedules the Task to execute when it is scheduled or sometime**
     *** later on */**
    task.ScheduleAndStart(false);
    return task;
}`

##### 计划任务

在图 14-9 的[步骤 3 中，`Task`类的`ScheduleAndStart`方法使用`ThreadPoolTaskScheduler`类的`QueueTask`方法对任务进行排队，该方法继承自`TaskScheduler`类。来自`Task`类的`m_taskScheduler`字段保存`TaskScheduler`类。`QueueTask`是在`TaskScheduler`类中定义的`abstract`方法:](#fig_14_9)

`protected internal abstract void QueueTask(Task task);`

让我们看看来自`ThreadPoolTaskScheduler`类的`QueueTask`方法的实现:

`protected internal override void QueueTask(Task task)
{
    TplEtwProvider log = TplEtwProvider.Log;
    if (log.IsEnabled(EventLevel.Verbose, ~EventKeywords.None))
    {` `        Task internalCurrent = Task.InternalCurrent;
        Task parent = task.m_parent;
        log.TaskScheduled(base.Id,
            (internalCurrent == null) ? 0 : internalCurrent.Id,
            task.Id,
            (parent == null) ? 0 : parent.Id,
            (int) task.Options);
    }
    if ((task.Options & TaskCreationOptions.LongRunning) !=
                                   TaskCreationOptions.None)
    {
        new Thread(s_longRunningThreadWork)
                  { IsBackground = true }.Start(task);
    }
    else
    {
        bool forceGlobal = (task.Options & TaskCreationOptions.PreferFairness)
                                    != TaskCreationOptions.None;
        ThreadPool.UnsafeQueueCustomWorkItem(task, forceGlobal);
    }
}`

`ThreadPool`类的`UnsafeQueueCustomWorkItem`方法的实现是:

`internal static void UnsafeQueueCustomWorkItem
                               (IThreadPoolWorkItem workItem, bool forceGlobal)
{
    EnsureVMInitialized();
    try
    {
    }
    finally
    {
        ThreadPoolGlobals.workQueue.Enqueue(workItem, forceGlobal);
    }
}`

字段`workQueue`来自`ThreadPoolWorkQueue`类，该类调用`Enqueue`方法并最终将任务排队到`ThreadPool`中:

`public void Enqueue(IThreadPoolWorkItem callback, bool forceGlobal)
{
**    /* Code removed */**
    else
    {
        QueueSegment queueHead = this.queueHead;
        while (!queueHead.TryEnqueue(callback))
        {
            Interlocked.CompareExchange<QueueSegment>(
                                ref queueHead.Next, new QueueSegment(), null);
            while (queueHead.Next != null)
            {
                Interlocked.CompareExchange<QueueSegment>(` `                               ref this.queueHead, queueHead.Next, queueHead);
                queueHead = this.queueHead;
            }
        }
    }
    this.EnsureThreadRequested();
}`

##### 设置延续

在图 14-9 的[步骤 4 中，CLR 返回初始化的任务。在步骤 5 中，在完成任务初始化和调度之后，CLR 通过检查从步骤 4 中的任务返回的 awaiter 来检查任务是否已经完成。如果任务没有完成，那么它在任务中设置继续或恢复代码，或者回调代码块。](#fig_14_9)

在步骤 6 中，程序控制在 CLR 调用`Start`方法的地方立即转移回`async`存根方法(在`L_0020`中，来自清单 14-27 中[的存根方法代码)。](#list_14_27)

在步骤 7 中，CLR 通过调用`L_002c`中的`get_Task`方法从`AsyncTaskMethodBuilder`获取任务，并将其返回给`async`方法`ShowEvenNumbers`的调用者。然后 CLR 继续执行来自调用者方法的操作(如果有的话)，这个方法就是`Main`方法。

在步骤 8 中，稍后，`ThreadPool`中调度的任务将被操作系统(OS)调度程序触发开始执行，如代码所示:

`internal static class _ThreadPoolWaitCallback
{
    [SecurityCritical]
    internal static bool PerformWaitCallback()
    {
        return ThreadPoolWorkQueue.Dispatch();
    }
}`

##### 执行计划任务

在步骤 9 中，CLR 将任务从`ThreadPool`中出队，并执行分配给该任务的操作，例如`b__1`方法，如代码所示:

`private static bool <ShowEvenNumbers>b__1(int item)
{
    return ((item % 2) == 0);
}`

在步骤 10 中，CLR 执行`b__1`方法并将新状态设置到状态机中。它调用状态机的`MoveNext`方法进入下一个状态，并执行与关联状态相关的代码。

在步骤 11 中，继续或恢复代码块将被执行以完成`async`方法处理。状态机的状态转换将开始工作，如图 14-10 中的[所示。](#fig_14_10)

![images](img/-10.jpg)

***图 14-10。**状态机的状态转换*

当 CLR 执行状态机时，它带有缺省值–1，该值执行`switch`块的缺省部分并用 0 更新状态，设置延续，并返回给调用者。状态机值当前设置为 0，每次 CLR 试图通过从状态机调用`MoveNext`方法进行另一次转换时，它将从状态值 0 开始。因此它执行`case 0`，这将中断`switch`块并在`Label_0104`执行代码块，以获得 awaiter 并用–1 更新状态。当从 CLR 输入–3 作为状态时，程序控制转移到`Label_0196`以将状态机的状态更新–2，并将结果设置为由状态机的调用者获取。

### 测试用例

接下来的部分将探索一些基于关键字`async`和`await`的异步方法的常见场景。

#### 没有返回类型时

当你设计一个程序时，它可能要求你触发一个任务，而不是等待任务完成并返回给你。当您执行异步操作时，您可以通过使用`FireAndForget`任务来实现。要编写一个`FireAndForget`任务，您需要从基于`async`的方法中返回 void，而不是`Task`或`Task<TResult>`。在`FireAndForget`任务中，C# 编译器在为其生成 stub 方法时不会生成和返回任何任务，因此调用者不可能跟踪基于`FireAndForget`的任务的完成或状态。[清单 14-32](#list_14_32) 显示了一个使用`async`和`await`语句的`FireAndForget`任务的例子。

***清单 14-32。**异步方法返回无效的例子*

`using System;
using System.Linq;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            FireAndForget();

            for (int i = 0; i < Int32.MaxValue; ++i)
            {
                if (i % (Int16.MaxValue*999) == 0)
                    Console.Write(".");
            }
            Console.ReadLine();
        }

        public static async void FireAndForget()
        {
            var evenNumbersTask = Task.Run(
                () =>
                {
                    Enumerable.Range(1, 5).ToList().ForEach(itemOuter =>
                    {
                        int limit = new Random().Next(Int16.MaxValue * 999);
                        var result = Enumerable.Range(
                        itemOuter, limit).Count(item =>
                        {
                            return item % 2 == 0;
                        });` `                        Console.WriteLine(
                           "\nProcessing and processed result {0}.", result);
                    });
                });
            await evenNumbersTask;
        }
    }
}`

该程序将产生以下输出:

`..
Processing and processed result 7689415.
Processing and processed result 335471.
..
Processing and processed result 6208074.
Processing and processed result 3476038.
.
Processing and processed result 1138061.
.............................................................`

void 返回和从异步方法返回的任务之间的区别在于，返回 void 的异步方法不能被等待。如果你要给清单 14-32 的[添加另一个方法:](#list_14_32)

` public static async void FireAndForget2()
{
    await FireAndForget();
}`

C# 编译器会报错并显示以下错误:

`'Ch14.Program.FireAndForget()' does not return a Task and cannot be awaited. Consider changing
it to return Task.`

如果您想要等待任何异步方法，该异步方法需要返回`Task`或`Task<TResult>`。C# 编译器生成的 stub 方法不会为 void return `async`方法返回`Task`，因此没有什么可等待的。所以你可以看到，使用`FireAndForget`方法没有什么可等待的，因为`FireAndForget`方法不返回`Task`。

让我们看看 C# 编译器为清单 14-32 的[方法生成的存根方法，如清单 14-33](#list_14_32) 的[所示。](#list_14_33)

***清单 14-33。**清单 14-32* 的 C# 编译器生成的存根方法

`.method public hidebysig static void FireAndForget() cil managed
{
**    /* code removed */**
    .maxstack 2
    .locals init (
        [0] valuetype Ch14.Program/<FireAndForget>d__6 d__,
        [1] valuetype  
            [mscorlib]System.Runtime.CompilerServices.AsyncVoidMethodBuilder
            builder)
    L_0000: ldloca.s d__` `    L_0002: call valuetype
            [mscorlib]System.Runtime.CompilerServices.AsyncVoidMethodBuilder
             [mscorlib]System.Runtime.CompilerServices.AsyncVoidMethodBuilder::
            Create()
    L_0007: stfld valuetype
            [mscorlib]System.Runtime.CompilerServices.AsyncVoidMethodBuilder
              Ch14.Program/<FireAndForget>d__6::<>t__builder
    L_000c: ldloca.s d__

    L_000e: ldc.i4.m1
    L_000f: stfld int32 Ch14.Program/<FireAndForget>d__6::<>1__state
    L_0014: ldloca.s d__

    L_0016: ldfld valuetype
            [mscorlib]System.Runtime.CompilerServices.AsyncVoidMethodBuilder
             Ch14.Program/<FireAndForget>d__6::<>t__builder
    L_001b: stloc.1
    L_001c: ldloca.s builder
    L_001e: ldloca.s d__

**   /* State machine has  been started */**
    L_0020: call instance void
            [mscorlib]System.Runtime.CompilerServices.AsyncVoidMethodBuilder::
              Start<valuetype Ch14.Program/<FireAndForget>d__6>(!!0&)

**    /* There has not been return any Task from this Stub method */**
    L_0025: br.s L_0027

**    /* This method does not return  */**
    L_0027: ret
}`

[清单 14-33](#list_14_33) 显示 CLR 不会返回`Task`作为结果，所以不可能从`FireAndForget`方法获得状态。它只用作一个调用，并把一切交给那个调用方法。

#### 当异步方法中有多个 Await 语句时

清单 14-34 展示了一个在程序中使用多个`await`语句的例子。

***清单 14-34。**多个 Await 语句*

`using System;
using System.Linq;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {` `        static void Main()
        {
            MultipleAwait();

            for (int i = 0; i < Int16.MaxValue * 8; ++i)
            {
                if (i / byte.MaxValue==0)
                    Console.Write(">");
            }
            Console.WriteLine("Operation is completed.");
            Console.ReadLine();
        }
        public static async void MultipleAwait()
        {
            await EvenNumbers();
            await EvenNumbers();
        }

        public static async Task EvenNumbers()
        {
            int limit = new Random().Next(Int16.MaxValue);
            Task<int> evenNumbersTask = Task.Run(
                 () => Enumerable.Range(1, limit).Count(
               item => item % 2 == 0));
            await evenNumbersTask;
            Console.WriteLine("\n" + evenNumbersTask.Result);
        }
    }
}`

该程序将产生以下输出:

`>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
11635
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
8954
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Operation is completed.`

#### 用户界面异步时

到目前为止，您已经看到了控制台应用中使用的`async`方法。[清单 14-35](#list_14_35) 显示了在图形用户界面(GUI)应用中使用的`async`方法的一个例子。

***清单 14-35。**GUI 异步的例子*

`using System;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;` `namespace Ch14_GUI
{
    public partial class EvenNumberDisplayWindow : Form
    {
        public EvenNumberDisplayWindow()
        {
            InitializeComponent();
        }

        private void btnProcess_Click(object sender, EventArgs e)
        {
            ShowEvenNumbers();
        }
        public async Task ShowEvenNumbers()
        {
            int limit = new Random().Next(Int32.MaxValue);
            string range = string.Format("({0},{1})", 1, limit);

            Task<int> evenNumbersTask = Task.Run(
                () => Enumerable.Range(1, limit).Count(item => item % 2 == 0));

            int count = await evenNumbersTask;
            txtEvenNumbers.Text = count.ToString();
        }

        private void btnCurrentTime_Click(object sender, EventArgs e)
        {
            txtCurrentTime.Text = DateTime.Now.ToLongTimeString();
        }
    }
}`

该程序将产生图 14-11 中[所示的输出。](#fig_14_11)

![images](img/-11.jpg)

***图 14.11。**使用 GUI 异步方法产生的输出*

### 基于任务的异步模式

基于任务的异步模式(TAP)用于实现 .NET 框架。它建立在`Task`和`Task<TResult>`类型的基础之上。当你定义一个遵循 TAP 的方法时，它需要遵循一些规则，比如它必须返回`Task`或`Task<TResult>`，并且一个方法除了任务组合符之外，都标记为`async`，比如`WhenAll`、`WhenAny`。在 TAP 方法中，您还可以使用`CancellationToken`将取消设置为正在运行的取消，或者您可以使用`IProgress<T>`获取正在运行的任务的进度状态。以下部分将探讨`Cancellation`和`IProgress`。

#### 使用取消来取消正在运行的任务

对于一个响应迅速的系统来说，当它执行一个长时间运行的操作时，允许用户随时取消任务是很常见的行为。对于异步操作，我们还希望可以随时取消任务。您可以通过使用取消标志来实现这一点，例如，`CancellationToken`，这是在`mscorlib.dll`程序集的`System.Threading`命名空间中引入的一种类型。[清单 14-36](#list_14_36) 显示了`CancellationToken`结构定义。

***清单 14-36。**取消令牌结构*

`public struct CancellationToken
{
    public static CancellationToken None                                     {}
    public bool IsCancellationRequested                                      {}
    public bool CanBeCanceled                                                {}
    public System.Threading.WaitHandle WaitHandle                            {}
    public CancellationToken(bool canceled)                                  {}
    public CancellationTokenRegistration Register(Action callback)           {}
    public CancellationTokenRegistration Register
              (Action callback, bool useSynchronizationContext)              {}
    public CancellationTokenRegistration Register(Action<object> callback,  
                                             object state)                   {}
    public CancellationTokenRegistration Register(
        Action<object> callback, object state, bool useSynchronizationContext){}
    public bool Equals(CancellationToken other)                              {}
    public override bool Equals(object other)                                {}
    public override int GetHashCode()                                        {}
    public static bool operator ==
                  (CancellationToken left, CancellationToken right)          {}
    public static bool operator !=
                  (CancellationToken left, CancellationToken right)          {}
    public void ThrowIfCancellationRequested()                               {}   
}`

一个`CancellationToken`是通过一个`CancellationTokenSource`创建的，它也是在`mscorlib.dll`程序集的`System.Threading`命名空间中定义的。清单 14-37 显示了`CancellationTokenSource`结构的定义。

***清单 14-37。**取消令牌源结构*

`public class CancellationTokenSource : IDisposable
{
    static CancellationTokenSource()                               {}
    public CancellationTokenSource()                               {}
    public CancellationTokenSource(int millisecondsDelay)          {}
    public CancellationTokenSource(TimeSpan delay)                 {}
    public void Cancel()                                           {}
    public void Cancel(bool throwOnFirstException)                 {}` `    public void CancelAfter(int millisecondsDelay)                 {}
    public void CancelAfter(TimeSpan delay)                        {}
    public static CancellationTokenSource
        CreateLinkedTokenSource(params CancellationToken[] tokens) {}
    public static CancellationTokenSource
        CreateLinkedTokenSource(CancellationToken token1,
                               CancellationToken token2)           {}
    public void Dispose()                                          {}
    public bool IsCancellationRequested                            {}    
    public CancellationToken Token                                 {}    
}`

源的`Token`属性返回`CancellationToken`，当源的`Cancel`方法被调用时，它可以被用来发出信号，如清单 14-38 中的[所示。](#list_14_38)

***清单 14-38。**异步方法中任务取消的例子*

`using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            CancellationTokenSource cancelSource = new CancellationTokenSource();

**            /* Initialize the Task with the cancel Token from**
**             * the CancellationTokenSource */**
            Task showNumber = ShowEvenNumbers(cancelSource.Token);

**            /* Following for-loop simulates as something else is going on */**
            for (int i = 0; i < Int64.MaxValue; ++i)
                if (i == byte.MaxValue)
                {
**                    /* Call the Cancel method to cancel the task in sometime**
**                     * when the Task was executing it's Task*/**
                    cancelSource.Cancel();
                    break;
                }
            Console.WriteLine("Cancel");
            Console.ReadLine();
        }

        public static async Task ShowEvenNumbers(CancellationToken cancelToken)
        {
            int limit = new Random().Next(Int32.MaxValue);
            string range = string.Format("({0},{1})", 1, limit);` `**            /* Pass the cancel token to the Task  */**
            Task<int> evenNumbersTask = Task.Run(
                () => Enumerable.Range(1, limit).Count(
              item => item % 2 == 0), cancelToken);
            int count = await evenNumbersTask;
        }
    }
}`

该程序将产生以下输出:

`Cancel`

#### 使用 IProgress < T >和 Progress 来显示正在运行的任务的进度

使用异步方法时，能够查看操作的进度状态会很有帮助。为了实现这一点，您可以通过传递一个每当任务进度发生变化时就会触发的`Action`委托来使用`Progress<T>`类的`Report`方法。`Progress<T>`类实现了在`mscorlib.dll`程序集的`System`名称空间中定义的`IProgress<T>`。清单 14-39 显示了`IProgress<T>`和`Progress<T>`类的定义。

***清单 14-39。**使用 IProgress <中的 T >和 Progress<T>T3】*

`public interface IProgress<in T>
{
    void Report(T value);
}

public class Progress<T> : IProgress<T>
{
    public event EventHandler<T> ProgressChanged                    {}
    public Progress()                                               {}
    public Progress(Action<T> handler)                              {}
    protected virtual void OnReport(T value)                        {}
    void IProgress<T>.Report(T value)                               {}
}`

清单 14-40 显示了进度报告的一个例子。

***清单 14-40。**进度报告示例*

`using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()` `        {
            CancellationTokenSource cancelSource = new
                                    CancellationTokenSource();
            Progress<int> progressReport = new Progress<int>((status) =>
            {
                Console.Clear();
                Console.WriteLine(status + " %");
            });
            Task showNumber = ShowEvenNumbers(cancelSource.Token,
                                              progressReport);

            for (int i = 0; i < Int64.MaxValue; ++i)
                if (i == Int32.MaxValue)
                {
                    cancelSource.Cancel();
                    break;
                }
            Console.WriteLine("Cancel");
            Console.ReadLine();
        }

        public static async Task ShowEvenNumbers(
            CancellationToken cancelToken,
            IProgress<int> onProgressChanged)
        {
            int limit = new Random().Next(Int32.MaxValue);
            string range = string.Format("({0},{1})", 1, limit);

            Task<int> evenNumbersTask = Task.Run(
                () => Enumerable.Range(1, limit).Count(item =>
                {
                    onProgressChanged.Report((item * 100) / limit);
                    return item % 2 == 0;
                }), cancelToken);
            int count = await evenNumbersTask;
        }
    }
}`

#### 组合子

在基于任务的异步模式中，组合子指的是任务的创建、操作或组合，例如，`WhenAll`、`WhenAny`或`Delay`。下面几节将探讨这些组合子。

##### 任务何时结束

`WhenAll`方法用于异步等待代表多个异步操作的任务。此方法返回一个任务，该任务在分配给此方法的所有任务完成后完成。`WhenAll`方法有以下重载签名:

`public  static Task WhenAll(IEnumerable<Task>  tasks)                        {}
public static Task<TResult[]> WhenAll<TResult>(
                                   IEnumerable<Task<TResult>> tasks)         {}
public  static Task WhenAll(params Task[] tasks)                             {}
public  static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks){}`

清单 14-41 展示了`WhenAll`方法的使用。

***清单 14-41。**when all 方法的例子*

`using System;
using System.Linq;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task<int> combinedResult = TestWhenAll();
            while (true)
            {
                if (combinedResult.IsCompleted)
                {
                    Console.WriteLine("Finished : {0}", combinedResult.Result);
                    break;
                }
                Console.Write(".");
            }
            Console.ReadLine();
        }

        public static async Task<int> TestWhenAll()
        {
            int[] combinedResult =
        await Task.WhenAll(CountEvenNumbers(),
                          CountEvenNumbers(), CountEvenNumbers());
            return combinedResult.Sum();
        }

        public static async Task<int> CountEvenNumbers()
        {
            return await Task.Run(
            () => Enumerable.Range(1, Int16.MaxValue).Count(x => x % 2 == 0));
        }
    }
}`

该程序将产生输出:

`..................Finished : 49149`

如果上述示例代码中出现任何异常，比如其中一个方法抛出异常，CLR 将继续执行在`WhenAll`方法中分配的其他任务，完成后，返回到在`Exception`的`InnerException`属性中有相关异常的任务。[清单 14-42](#list_14_42) 显示了分配给`WhenAll`方法的任务发生异常的例子。

***清单 14-42。**when all 方法中的异常*

`using System;
using System.Linq;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task<int> combinedResult = TestWhenAll();
            while (true)
            {
                if (combinedResult.IsCompleted)
                {
                    Console.WriteLine("Finished : {0}", combinedResult.Result);
                    break;
                }
                Console.Write(".");
            }
            Console.ReadLine();
        }

        public static async Task<int> TestWhenAll()
        {
            int[] combinedResult =
                  await Task.WhenAll(CountEvenNumbers(),
                       ThrowAnException(), CountEvenNumbers());
            return combinedResult.Sum();
        }

        public static async Task<int> ThrowAnException()
        {
            return await Task.Run(() =>
            {
                throw new Exception(
                          "There is something wrong in the processing....");
                return Enumerable.Range(1, Int16.MaxValue).Count(
                                                  x => x % 2 == 0);
            });
        }
        public static async Task<int> CountEvenNumbers()
        {
            return await Task.Run(() =>` `            {
                int result = Enumerable.Range(1, Int16.MaxValue).Count(
                                                  x => x % 2 == 0);
                Console.WriteLine(result);
                return result;
            });
        }
    }
}`

这将产生输出:

`16383
16383
...
Unhandled Exception: System.AggregateException: One or more errors occurred. ---
> System.Exception: There is something wrong in the processing....
   at Ch14.Program.<ThrowAnException>b__4()

**/* Rest of the error details removed */**`

这个输出显示了带有`CountEvenNumbers`方法的 CLR 进程返回的结果是 16383 和 16383。另一方面，在处理`ThrowAnException`方法时，它抛出一个 CLR 作为`AggregateException`传递的异常。

##### 任何时候的任务

当分配方法中的任何一个方法(分配给`WhenAny`方法)完成其操作时，使用`WhenAny`方法。`WhenAny`方法有以下重载签名:

`public static Task<Task> WhenAny(IEnumerable<Task> tasks)      {}
public static Task<Task<TResult>> WhenAny<TResult>(
       IEnumerable<Task<TResult>> tasks)                       {}
public static Task<Task> WhenAny(params Task[] tasks)          {}
public static Task<Task<TResult>> WhenAny<TResult>(
                      params Task<TResult>[] tasks)            {}`

清单 14-43 展示了`WhenAny`方法的使用。

***清单 14-43。**when any 方法的例子*

`using System;
using System.Linq;
using System.Threading.Tasks;

namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task<int> result = TestWhenAny();
            while (true)` `            {
                if (result.IsCompleted)
                {
                    Console.WriteLine("Finished : {0}", result.Result);
                    break;
                }
                Console.Write(".");
            }
            Console.ReadLine();
        }

        public static async Task<int> TestWhenAny()
        {
            Task<int> firstCompleted=
        await Task.WhenAny(CountEvenNumbers(),
                          CountEvenNumbers(), CountEvenNumbers());
            return firstCompleted.Result;
        }

        public static async Task<int> CountEvenNumbers()
        {
            return await Task.Run(() => Enumerable.Range(1,
                                   Int16.MaxValue).Count(x => x % 2 == 0));
        }
    }
}`

该程序产生了以下输出:

`................................................................................................
...........................................................................Finished : 16383`

##### 任务延迟

来自`Task`类的`Delay`方法用于在异步方法执行时将暂停设置为异步方法。此方法可用于创建延迟一段时间后完成的任务。`Delay`方法有以下重载签名:

`public static Task Delay(int millisecondsDelay)                             {}
public static Task Delay(TimeSpan delay)                                    {}
public static Task Delay(int millisecondsDelay,
              System.Threading.CancellationToken cancellationToken)         {}
public static Task Delay(TimeSpan delay,
              System.Threading.CancellationToken cancellationToken)         {}`

清单 14-44 展示了`WhenAny`方法的使用。

***清单 14-44。**延迟的例子*

`using System;
using System.Threading.Tasks;`  `namespace Ch14
{
    class Program
    {
        static void Main()
        {
            Task combinedResult = TestDelayWithWhenAny();

            while (true)
            {
                if (combinedResult.IsCompleted)
                {
                    Console.WriteLine("Finished waiting");
                    break;
                }
                Console.Write(".");
            }
            Console.ReadLine();
        }

        public static async Task TestDelayWithWhenAny()
        {
            await Task.WhenAny(Task.Delay(1), Task.Delay(2000));
        }
    }
}`

这个程序产生了输出。

`................................................................................................
........................................................Finished waiting`

### 总结

在这一章中，我们已经探索了使用`Task`类的异步编程 .NET 框架。您已经学习了如何在`Task`类中设置延续，如何在实例化`Task`类时设置不同的选项，以及如何在`Task`中设置延续时设置不同的延续选项。您还学习了使用`Task`类进行异步操作时的异常处理。

引入关键字`async`和`await`是为了展示如何使用这些新特性进行异步操作。然后`async`和`await`被深入探究，以了解 C# 编译器如何通过使用操作系统的可用调度来调度任务执行异步操作，而不是阻塞程序的执行，从而生成存根方法和状态机来处理异步操作。您还了解了这些新特性如何通过处理 continuation 块中的设置来改进异步编程，从而保持程序的流程和结构简单。

最后，本章介绍了基于`Task`的异步模式，展示了可以在异步编程中使用的不同内置组合子，以及如何在中设置任务的取消和进度报告 .NET 使用 C#。最后一章将介绍中的诊断工具 .NET 进行调试。