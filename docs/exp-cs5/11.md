## 第十一章

![images](img/.jpg)

## 集合说明

本章将讨论中的不同集合类型。NET— `Array`、`List<T>`、`ArrayList`、`Stack`、`Queue`、`Hashtable`和`Dictionary`—用于存储和管理应用中的数据。我们将看看`List<T>`类的内部工作方式，以及 CLR 如何实例化`List<T>`类的一个实例，如何向其中添加条目，以及如何扩展其内部数组以容纳更多条目。我们还将研究`ArrayList`、`Stack`、`Queue`、`Hashtable`和`Dictionary`类的内部工作方式，看看 CLR 如何处理这些类来存储信息。

### 收藏在。网

中的`System.Collections`命名空间。NET 包含的数据结构可以在 C#中用来定义不同种类的集合类型。所有集合类都实现了具有附加功能的接口`ICollection`。[图 11-1](#fig_11_1) 显示了. NET 中不同的集合类

![images](img/-01.jpg)

***图 11-1。**不同的收藏类所用的。网*

每个类都有自己的功能和用法。[表 11-1](#tab_11_1) 总结了[图 11-1](#fig_11_1) 所示的不同采集类型。

T2】

### 数组类

`Array`类是所有单维和多维数组的隐式基类，它是实现标准集合接口的最基本类型之一。`Array`类提供了类型统一，因此一组通用的方法可用于所有数组，而不管它们的声明或底层元素类型。

#### 数组类在。网

`Array`类提供了创建、操作、搜索和排序数组的方法。它充当 CLR 中所有数组的基类。它已经在中的`mscorlib.dll` ( `C:\Windows\Microsoft.NET\ Framework\v4.0.30319`)汇编中定义。如图 11-2 中的[所示。](#fig_11_2)

![images](img/-02.jpg)

***图 11-2。**系统命名空间中的数组类*

`Array`类的签名是:

`public abstract class Array : ICloneable, IList, ICollection, IEnumerable`

`Array`类是一个抽象类型，它实现了`ICloneable`、`IList`、`ICollection`和`IEnumberable`接口。

#### 数组类成员

`Array`类有不同的公共属性和方法，可以用来操作存储在`Array`类中的数据。在下一节中，我们将探索`Array`类的不同属性和方法。

##### 性能

[表 11-2](#tab_11_2) 列出了`Array`类的不同属性。

![images](img/.jpg)

##### 方法

`Array`类有不同的方法，可以用来做不同的操作。[表 11-3](#tab_11_3) 列出了`Array`类的不同方法。

T2】

![images](img/.jpg)

### 列表

中使用的`List<T>`类。NET 表示对象的集合。该类公开了用于操作存储在其中的对象的不同方法和属性。本节将研究`List<T>`类。

#### 列表的容量和大小< T >

`List<T>`是一个动态数组，其大小根据需要增加。`List<T>`可以容纳的元素数量被称为`List<T>`类的容量。如果`List<T>`的初始容量(它可以容纳的项目数)是 N，那么在`List<T>`扩展的每个阶段，为了容纳更多的项目，CLR 在`List<T>`的内部数组中增加额外的 N 个空槽，或者增加到 2N 个。[图 11-3](#fig_11_3) 展示了`List<T>`级的尺寸和扩展。

![images](img/-03.jpg)

***图 11-3。**列表< T >基础知识*

当您实例化`List<T>`类而没有指定容量时，`List<T>`的初始容量为零。在对`List<T>`实例的第一次`Add`操作中，它将增加默认容量为四(N)的`capacity`，该容量存储在`List<T>`类的内部字段`_defaultCapacity`中。当需要在`List<T>`实例中容纳更多项目时，将增加`List<T>`的容量，例如 4(N) × 2 = 8 (2N)、8(N) × 2 = 16 (2N)、16(N) × 2 = 32 (2N)等等。这意味着在`List<T>`类的每一次扩展中，`List<T>`的新容量将被计算，并且将是以前容量的两倍。`List<T>`中实际占用的项目由`List<T>`类的`Count`属性(内部为`_size`字段)引用，总项目可以添加到`Capacity`属性引用的`List<T>`中。当`List<T>`的容量扩大以容纳更多物品时，容量值会更新。例如，如果您考虑一个`List<T>`类的实例，其当前容量是 8(由`Capacity`属性引用),但它实际上包含 5 个项目，那么`List<T>`实例的`Count`属性引用 5(在`_size`字段内部),而`Capacity`是 8。`List<T>`的容量也可以设置:

*   显式地通过设置`Capacity`属性
*   在`List<T>`的实例化时间
*   当基于另一个类型为`ICollection`的列表实例化`List<T>`类时，该列表的大小被用作`List<T>`类的初始容量

通过调用`TrimExcess`方法可以减少`List<T>`的容量。如果`List<T>`的一个实例的容量为 N(其中 N = 4 ),并且在`List<T>`的那个实例中只存储了两个项目，那么调用 CLR 的`TrimExcess`方法将通过从`List<T>`类的内部数组中移除 N-2 个单元来将`List<T>`的容量减少到两个。

#### 列表声明

中的`mscorlib.dll` ( `C:\Windows\Microsoft.NET\ Framework\v4.0.30319`)程序集的`System.Collections`命名空间中定义了`List<T>`类。如[图 11-4](#fig_11_4) 所示。

![images](img/-04.jpg)

***图 11-4。**列出系统中的< T >类。通用名称空间*

`List<T>`类的签名应该是:

`public class List<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList,  ICollection, IEnumerable`

让我们看一个例子，其中`List<T>`类被用来创建`numbers`对象的实例，如[清单 11-1](#list_11_1) 所示。

***清单 11-1。**例单< T >类*

`using System;
using System.Collections;
using System.Collections.Generic;

namespace Ch11
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> numbers = new List<int>();
            numbers.Add(0);
            numbers.Add(1);       
            ShowResult(numbers);
        }
        public static void ShowResult(IEnumerable aList)
        {
            foreach (var item in aList)
                Console.Write("{0}\t", item);
            Console.WriteLine();
        }
    }
}`

该程序将产生以下输出:

`0       1`

#### 列表实例化< T >

当您调用以下三个重载构造函数之一时,`List<T>`开始生效:

`public List()                            {}
public List(int capacity)                {}
public List(IEnumerable<T> collection)   {}`

当 CLR 执行第一个版本的`List<T>`构造函数时，它用默认大小零初始化内部`_items`数组，但是在第一次`Add`操作时，它将增加到 4。在构造函数的第二个版本中，它用作为参数`capacity`提供的给定大小初始化`_items`数组。CLR 通过输入集合的`Count`属性从参数`collection`获取大小。对于第三个版本，构造函数初始化内部的`_items`数组，并将集合的全部内容复制到`_items`数组中。图 11-5 展示了`List<T>`类的实例化。

![images](img/-05.jpg)

***图 11-5。**列出< T >类及其构造函数*

#### 列表中的加法运算< T >

要将任何项目添加到`List<T>`中，CLR 会检查该项目是否可以存储在内部`_items`数组中。CLR 通过使用`List<T>`类的`EnsureCapacity`方法检查`List<T>`的`_items`数组中的元素数量来确保这一点。如果大小由`EnsureCapacity`方法确保，CLR 将该项(必须是相同的类型，因为 T 引用列表< T >)添加到`_items`数组。[图 11-6](#fig_11_6) 显示了`List<T>`类的基本`Add`和`AddRange`操作。

![images](img/-06.jpg)

***图 11-6。**列表中的加法运算< T >类*

`EnsureCapacity`方法完成整个后端工作，以确保`List<T>`能够在`_items`数组中保存所需数量的数据(基于可用内存)。CLR 用`List<T>` + 1 的当前`_size`字段的值调用这个方法。`EnsureCapacity`方法计算`_items`数组的新容量，并将这个新容量值设置到`List<T>`类的`Capacity`属性中。`List<T>`类的`EnsureCapacity`方法的实现如[清单 11-2](#list_11_2) 所示。

***清单 11-2。**清单的实现方法< T >类*

`**/* min = (current size (value of the _size) of the List<T> + 1) */**
private void EnsureCapacity(int min)
{
    **/* The _items.Legth refers to the current total length of the _items**
     *** array or total cells of the _items array where as _size field of**
     *** the List<T> class refers to the currently used cells from the**
     *** _items array of the List<T> class. To able to add any new item into**
     *** the List<T>, _size has to be < _items.Length */**
    if (this._items.Length < min)
    {
        int num = (this._items.Length == 0) ? 4 : (this._items.Length * 2);
        if (num >  0x7fefffff)
        {
            num = 0x7fefffff;
        }
        if (num < min)
        {
            num = min;
        }
        this.Capacity = num;
    }
}`

`List<T>`类的`Capacity`属性使用新的容量值([清单 11-2](#list_11_2) 中的`num`)作为这个新数组的总长度来创建一个新数组。它将`_items`数组的现有内容复制到这个新数组中。新数组将包含所有现有的项目和四个新的空单元格，用于存储额外的项目。最后，这个新数组将替换现有的 _ `items`数组。让我们检查一下`Capacity`属性的实现，如[清单 11-3](#list_11_3) 所示。

***清单 11-3。**列表的实现能力属性< T >类*

`public int Capacity
{
    get
    {
        return this._items.Length;
    }
    set
    {
       **/*.....*/**
        **/* value refers to the new Capacity value ensured by the**
         *** EnsureCapacity method.*/**
        if (value > 0)
        {
             **/* Temporary array to hold existing item and new empty items.*/**
            T[] destinationArray = new T[value];
            if (this._size > 0)
            {

                **/* Copy the existing items into the new array. */**
                Array.Copy(
                    this._items,      **/* It refers the source array from**
                                       *** where items will be copied */**
                    0,                **/* The position of the source array**
                                       *** from where the copy will start */**
                    destinationArray, **/* It refers the destination array in**
                                       *** where items will be copied into*/**
                    0,                **/* The position of the destination array**
                                       *** in where the item will be**
                                       *** placed after copying*/**
                    this._size        **/* Total number of item will be copied**
                                       *** from the source array.*/**
                    );
            }

           **/* Replace _items with the temporary array which currently holding**
            *** existing contents of the _items array and empty items**
            *** for the expanded cells. */**
            this._items = destinationArray;
        }
        else
        {
         **/* Otherwise set _items with 0 items as _emptyArray hold 0 items. */**
            this._items = List<T>._emptyArray;
        }
       /*.....*/` `    }
}`

#### 在列表中插入操作< T >

与`Add`方法相比，`InsertRange`方法的工作方式稍有不同。`InsertRange`方法从`_items`数组的给定位置开始，将一系列项目添加到`List<T>`中。从[清单 11-4](#list_11_4) 中，您可以看到值`{22, 33, 77}`是通过将数字中现有的项目`{3}`复制到数字的新位置中而插入的。它从`numbers`列表的位置 3 开始复制项目，直到要复制的项目数等于`numbers`(原始序列)列表的大小(4)——要插入的项目数(3)。计算项目将被复制到的新索引也很重要。使用索引加计数来计算位置 6，其中`index`指的是从源数组复制的开始位置(作为输入提供给`InsertRange`，为 3)，而`count`指的是在`InsertRange`方法中提供的要插入到原始列表中的项目数。结果，条目`{3}`将被复制到数组位置 6，但是原始列表号的容量是 4。所以它需要扩大容量来容纳更多的物品。原始列表扩展后，将复制扩展后的原始列表新值`{22,33,77}`位置`{3,4,5}`的单元格。[清单 11-4](#list_11_4) 显示了`InsertRange`方法的用法。

***清单 11-4。**列表的 InsertRange 方法示例< T >类*

`using System;
using System.Collections;
using System.Collections.Generic;

namespace Ch11
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> numbers = new List<int>()
            {
                0,1, 2, 3
            };
            numbers.InsertRange(3, new List<int>() { 22, 33, 77 });
            ShowResult(numbers);
        }

        public static void ShowResult(IEnumerable aList)
        {
            foreach (var item in aList)
                Console.Write("{0}\t", item);
            Console.WriteLine();
        }
    }
}`

该程序将产生以下输出:

`0       1       2       22      33      77      3`

`InsertRange`方法的工作原理如图[图 11-7](#fig_11_7) 所示。

![images](img/-07.jpg)

***图 11-7。**在列表中插入 Range 操作< T >类*。

从[图 11-7](#fig_11_7) 可以看出:

*   CLR 将从原始列表中复制项目，从给定的位置(3)开始(对于[清单 11-4](#list_11_4) )，直到它达到要复制的项目数，即 1，因为它是使用`this._size-index`计算的，即(4 - 3) = 1。因此，它将从位置 3 复制该项，并将其存储在位置 6 的`_items`数组中的位置 6。
*   将新值插入到`_items`数组的第三到第五个单元格中，这将用新值`{22, 33, 77}`覆盖现有的`{3, 0, 0}`项。

#### 列表中的删除操作< T >

在`List <T>`类中，可以使用`Remove`、`RemoveAll`或`Clear`方法对列表中的项目进行删除操作或清除操作。让我们看看`Remove`方法内部是如何工作的:

*   当 CLR 执行`Remove`方法时，它将一个将要移除的项目作为参数。它使用`IndexOf`方法在`_items`数组中寻找该项的索引位置。这将返回该项的索引，CLR 将这个索引作为输入传递给`RemoveAt`方法。
*   `RemoveAt`方法从项目索引(将被删除)的位置加 1 复制项目，直到要复制的项目数达到`_items`数组的当前大小—要被删除的项目的位置(要被删除的项目的索引)—在目标数组中要被删除的项目的索引的位置。
*   CLR 会将类型 T 的默认值设置为`_items`数组的最后一项。

`RemoveAt`方法的实现如[清单 11-5](#list_11_5) 所示。

***清单 11-5。**列表的 RemoveAt 方法的实现< T >类*

`public void RemoveAt(int index)       **/* index - The position of the item which is going to**
                **remove */**
{
    if (index >= this._size)
    {
        ThrowHelper.ThrowArgumentOutOfRangeException();
    }
    this._size--;
    if (index < this._size)
    {
        Array.Copy(
              this._items,        **/* Source array - from where**
                                   *** items will be copied */**
              index + 1,          **/* Source index - the position from where**
                                   *** the item will start copying */**
              this._items,        **/* Destination array - to where items will**
                                   *** be copied over */**
              index,              **/* Destination index - the position in where**
                                   *** the item will be placed after copied */**
              this._size - index  **/* Total number of item will be copied */**
                  );
    }
    this._items[this._size] = default(T); **/* Set the last item with the**
                                           *** default value */**
    this._version++;
}`

#### 列出<师>班成员

本节研究了在`List<T>`中使用的不同字段、构造函数和成员。

##### 构造器

`List<T>`类有三个重载的构造函数来初始化`List<T>`类的一个实例。表 11-4 列出了用于实例化`List<T>`类的三个构造函数。

![images](img/.jpg)

![images](img/.jpg)

##### 性能

[表 11-5](#tab_11_5) 列出了`List<T>`类的不同属性。

![images](img/.jpg)

##### 方法

`List<T>`类有不同的方法，可以用来做不同的操作。[表 11-6](#tab_11_6) 列出了`List<T>`类的不同方法。

![images](img/.jpg)

![images](img/.jpg)

![images](img/.jpg)

![images](img/.jpg)

### 阵列列表

`ArrayList`类是. NET 集合的另一种类型。本节将更详细地探讨`ArrayList`类。

#### 数组列表的容量和大小。网

`ArrayList`是一个动态数组，其大小根据需要动态增加。一个`ArrayList`可以容纳的元素数量指的是`ArrayList`的容量。如果在内部`_items`阵列扩展的每个阶段`ArrayList`的初始容量(它可以容纳的项目数)是 N，以容纳更多的项目，CLR 增加额外的 N 个项目或增加到 2N。比如`ArrayList`的默认容量是 4，会增加为 4 × 2 = 8，8 × 2 = 16，16 × 2 = 32，以此类推。[图 11-8](#fig_11_8) 展示了`ArrayList`级的尺寸和扩展。

![images](img/-08.jpg)

***图 11-8。**数组列表基础知识*

当你实例化`ArrayList`类而没有指定初始`Capacity`时，`ArrayList`的容量为零。在使用`ArrayList`实例的第一个`Add`操作中，它将增加四(N)值的容量，该值存储在`ArrayList`类的内部字段`_defaultCapacity`中。当需要在`ArrayList`实例中容纳更多项目时，它会增加，例如 4(N) × 2 = 8 (2N)、8(N) × 2 = 16 (2N)、16(N) × 2 = 32 (2N)等等(如图[图 11-8](#fig_11_8) 所示)。这意味着在`ArrayList`类的每一次扩展中，将会计算出`ArrayList`的新容量，该容量将是以前容量的两倍。实际占用`ArrayList`的项目被称为`ArrayList`类的`Count`属性(内部为`_size`字段)，项目总数可以添加到`Capacity`属性所引用的`ArrayList`中。当 CLR 扩展`ArrayList`的容量以容纳更多项目时，容量值会更新。例如，如果考虑一个`ArrayList`类的实例，其当前容量是 8(由`Capacity`属性引用),但它实际上包含 5 个项目，那么`ArrayList`实例的`Count`属性引用 5(在`_size`字段内部),容量是 8。`ArrayList`的容量也可以设置:

*   通过在`Capacity`属性中设置所需的值来显式设置
*   在`ArrayList`的实例化时间
*   当`ArrayList`将基于另一个类型为`ICollection`的列表被实例化时，该列表的大小将被用作`ArrayList`的初始容量

通过调用`TrimToSize`方法可以减少`ArrayList`的容量。如果`ArrayList`的一个实例的容量为 N(其中 N = 4 ),并且该实例中只存储了两个条目，那么调用`TrimToSize`方法 CLR 将通过从`ArrayList`类的内部数组中移除 N-2 个单元格来将`ArrayList`的容量减少 2。

#### 数组列表声明

中的`mscorlib.dll` ( `C:\Windows\Microsoft.NET\ Framework\v4.0.30319`)程序集的`System.Collections`命名空间中定义的`ArrayList`类。NET 在[图 11-9](#fig_11_9) 中演示。

![images](img/-09.jpg)

***图 11-9。**系统中的 ArrayList 类。集合名称空间*

`ArrayList`类的签名是:

`public class ArrayList : IList, ICollection, IEnumerable, ICloneable`

让我们看一个`ArrayList`用法的例子，如[清单 11-6](#list_11_6) 所示。

***清单 11-6。**数组列表类的例子*

`using System;
using System.Collections;

namespace Ch11
{
    class Program
    {
        static void Main(string[] args)
        {
            ArrayList terrestrialPlanets = new ArrayList();
            terrestrialPlanets.Add("Mercury");   **/* Default capacity is 4.*/**
            terrestrialPlanets.Add("Venus");
            terrestrialPlanets.Add("Earth");
            terrestrialPlanets.Add("Mars");

            ShowResult(terrestrialPlanets);
        }

        public static void ShowResult(
                           IEnumerable aList, char mySeparator = ' ')
        {
            foreach (string item in aList)
                Console.Write("{0}{1}", mySeparator, item);
            Console.WriteLine();
        }
    }
}`

该程序将产生以下输出:

`Mercury Venus Earth Mars`

#### 数组列表实例化

当您调用以下三个重载构造函数之一时，它就会活跃起来:

`public ArrayList()                     {}
public ArrayList(int capacity)         {}
public ArrayList(ICollection c)        {}`

当 CLR 执行第一个版本的`ArrayList`构造函数时，它用默认大小零初始化内部`_items`数组。但是在第一次`Add`行动中，它将增加到四个。对于构造函数的第二个版本，它用作为输入提供给`capacity`参数的给定大小初始化`_items`数组。CLR 通过第三版构造函数的`c`集合的`Count`属性获取参数`c`(引用一个集合)的大小，并使用该大小初始化`_items`数组。它将`c`的全部内容复制到`_items`数组中。[图 11-10](#fig_11_10) 展示了使用不同构造函数的`ArrayList`实例化。

![images](img/-10.jpg)

***图 11-10。**数组列表类及其构造函数*

#### ArrayList 类中的添加和插入操作

要将任何项目添加到`ArrayList`中，CLR 会检查该项目是否可以存储在`_items`数组中。CLR 通过使用`ArrayList`类的`EnsureCapacity`方法检查`ArrayList`类中元素的当前数量来确保这一点。如果通过`EnsureCapacity`方法确保了大小，CLR 会将该项添加到扩展的`_items`数组中。[图 11-11](#fig_11_11) 演示了`ArrayList`中的`Add`和`Insert`操作。

![images](img/-11.jpg)

***图 11-11。**数组列表类的添加和插入操作*

清单 11-7 中展示了`ArrayList`类的`Add`方法的实现。

***清单 11-7。**ArrayList 类的 Add 方法的实现*

`public virtual int Add(object value)
{
    if (this._size == this._items.Length)
    {
        this.EnsureCapacity(this._size + 1);
    }
    this._items[this._size] = value;
    this._version++;
    return this._size++;
}`

`EnsureCapacity`方法将完成整个后端工作，以确保`ArrayList`能够在其中保存所需数量(基于可用内存)的数据。CLR 用`ArrayList + 1`的当前`_size`字段的值调用这个`EnsureCapacity`方法。`EnsureCapacity`方法为`_items`数组计算当前的新容量，并将这个新值设置到`ArrayList`类的`Capacity`属性中。`ArrayList`类的`EnsureCapacity`方法的实现如[清单 11-8](#list_11_8) 所示。

***清单 11-8。**ArrayList 类的 EnsureCapacity 方法的实现*

`**/* min is current size (_size) of the List<T> + 1 */**
private void EnsureCapacity(int min)
{

**    /* The _items.Legth refers to the current total length of the _items**
**     * array or total. cells of the _items array where as _size field of**
**     * the ArrayList refers to the currently used cells from the _items**
**     * array of the ArrayList class. To able to add any item into**
     *** the ArrayList, _size has to be < _items.Length */**
    if (this._items.Length < min)
    {
        int num = (this._items.Length == 0) ? 4 : (this._items.Length * 2);
        if (num < 0x7fefffff)
        {
            num = 0x7fefffff;
        }
        if (num < min)
        {
            num = min;
        }
        this.Capacity = num;
    }
}`

`ArrayList`类的`Capacity`属性创建一个新数组，其大小是使用`EnsureCapacity`方法计算的新容量值。它将现有的条目从`_items`数组复制到这个新数组中。新数组将包含来自`_items`数组的所有现有项目和四个新的空单元格。最后，这个新数组将替换现有的`_items`数组。让我们看看`Capacity`属性的实现，如[清单 11-9](#list_11_9) 所示。

***清单 11-9。**ArrayList 类的 Capacity 属性的实现*

`public virtual int Capacity
{
    get
    {
        return this._items.Length;
    }
    set
    {
        if (value != this._items.Length)
        {
**           /*  value refers to the new Capacity value ensured by**
**            * the EnsureCapacity method.*/**
            if (value > 0)
            {
**               /* Temporary array to hold existing item and new empty items.*/**
                object[] destinationArray = new object[value];

                if (this._size > 0)
                {
                     **/* Copy the existing items into the new array. */**
                     Array.Copy(
                        **/* It refers the source array from where items**
                         *** will be copied */**
                         this._items,           
                        **/* The position of the source array from where**
                         *** the copy will start */**
                         0,                             
                        **/* It refers the destination array in  where items**
                         *** will be copied into */**
                         destinationArray,
                        **/* The position of the destination array**
                         *** in where the item will be placed after copying */**
                         0,
                        **/* Total number of item will be copied from the**
                         *** source array */**                            
                         this._size                                           
                     );
                }
               **/* Replace _items with the temporary array which currently**
                *** holding existing contents of the  _items array and empty**
                *** items for the expanded cells. */       **
                this._items = destinationArray;
            }
            else
            {
                this._items = new object[4]; **/* Otherwise set _items with 4**` `                                              *** items. */**
            }
        }
    }
}`

#### 在数组列表中插入一系列项目

`InsertRange`方法的工作方式与`Add`方法略有不同。`InsertRange`方法从`_items`数组的给定位置开始，将一系列项目添加到`ArrayList`中。它从数字的位置 3(提供给`InsertRange`方法)开始复制，一直复制到要复制的项目数等于数字(原始序列)的大小(4)，即要插入的项目数(3)。从将要复制的项目中计算新的索引也很重要。使用 index 加 count 来计算位置 6，其中 index 指的是从源数组复制的开始位置(作为添加到为 3 的`InsertRange,`的输入提供)，count 指的是在`InsertRange`方法中提供的要插入到原始列表中的项目数。因此，条目`{3}`将被复制到位置 6 的数组中，但原始列表的容量是 4，因此需要扩展容量以容纳更多的条目。原始列表扩展后，对于扩展列表中位置`{3,4,5}`的单元格，将复制新值`{22,33,77}`。[清单 11-10](#list_11_10) 说明了`InsertRange`方法。

***清单 11-10。**ArrayList 类的 InsertRange 方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;

namespace Ch11
{
    class Program
    {
        static void Main(string[] args)
        {
            ArrayList numbers = new ArrayList()
            {
                0,1, 2, 3
            };
            numbers.InsertRange(3, new List<int>() { 22, 33, 77 });
            ShowResult(numbers);
        }

        public static void ShowResult(IEnumerable aList)
        {
            foreach (var item in aList)
                Console.Write("{0}\t", item);
            Console.WriteLine();
        }
    }
}`

该程序将产生输出:

`0       1       2       22      33      77      3`

这项工作如图[图 11-12](#fig_11_12) 所示。

![images](img/-12.jpg)

***图 11-12。**ArrayList 类的 InsertRange 操作*

从[图 11-12](#fig_11_12) 可以看出:

*   CLR 从原始列表中复制项目，它从给定的位置开始(对于[清单 11-10](#list_11_10) ，为 3)，直到它达到要复制的项目数(为 1，因为它是使用`_`size-index 计算的，即(4 - 3) = 1。因此，它将从位置 3 复制该项，并将其存储在位置 6 的`_items`数组中。
*   CLR 会将新值插入到`_items`数组位置 3 到 5 的空单元格中。

#### 数组列表中的删除操作

如果想从`ArrayList`中删除任何项目，可以使用`Remove`方法。清单 11-11 中的程序展示了`ArrayList`类的`Remove`方法的用法。

***清单 11-11。**从数组列表中移除项目*

`using System;
using System.Collections;

namespace Ch11
{
    class Program
    {` `        static void Main(string[] args)
        {
            ArrayList terrestrialPlanets = new ArrayList();
            terrestrialPlanets.Add("Mercury");
            terrestrialPlanets.Add("Venus");
            terrestrialPlanets.Add("Earth");
            terrestrialPlanets.Add("Mars");

            terrestrialPlanets.Remove("Venus");
            ShowResult(terrestrialPlanets);
        }

        public static void ShowResult(IEnumerable aList)
        {
            foreach (string item in aList)
                Console.Write("{0}\t",item);
            Console.WriteLine();
        }
    }
}`

该程序将产生以下输出:

`Mercury Earth   Mars`

CLR 采取以下步骤来执行`terrestrialPlanets.Remove("Venus")`语句:

*1。步骤 1* :从`Remove`方法中，CLR 将试图从`ArrayList`类的内部数组`_items`中找到`Venus`对象的索引。然后，它将使用为`Venus`项找到的索引在内部调用`RemoveAt`方法。

![images](img/-13.jpg)

***图 11-13。**移除 ArrayList 类中的操作*

②*。步骤 2* :在`RemoveAt`方法内部，CLR 调用`Array`类的`Copy`方法，并带有相关参数，如要移除的项目的计算索引和`ArrayList`类的`_size`字段。此复制操作一次替换一个项目。CLR 复制`Earth`和`Mars`来替换`_items`数组的`Venus`和`Earth`。`_items`数组中不再有`Venus`。CLR 将用 null 设置`_items`数组中位置`Mars`(最后一次出现)的内容。[图 11-13](#fig_11_13) 显示了被移除的最后一个设置为空值的项目，并且(除非你调用`TrimToSize`方法)内部的`array _items`保存被移除项目的空值。清单 11-12 展示了`RemoveAt`方法的实现。

***清单 11-12。**ArrayList 类的 RemoveAt 方法的实现*

`/* index - The position of the item which is going to remove */
public virtual void RemoveAt(int index)
{
    this._size--;
    if (index < this._size)
    {
        Array.Copy(
              this._items,       **/* It refers the source array - from where**
                                  *** items will be copied  */**
              index + 1,         **/* The position of the source array from**
                                  *** where the copy will start */**
              this._items,       **/* It refers the destination array in where**
                                  *** items will be copied over */**
              index,             **/* The position of the destination array**
                                  *** in where the item will be**
                                  *** placed after copying */**
              this._size - index **/* Total number of item will be copied from**
                                  *** the source array */**
                  );
    }
    this._items[this._size] = null;
    this._version++;
}`

#### 数组列表类成员

本节将探索在`ArrayList`中使用的不同字段、构造函数和成员。

##### 菲尔茨

[表 11-7](#tab_11_7) 列出了`ArrayList`类中不同的字段，这些字段是`ArrayList`类在内部用来实现`ArrayList`功能的。

T2】

##### 构造器

`ArrayList`类有三个重载的构造函数来初始化`ArrayList`类的一个实例。表 11-8 列出了三个可以用来实例化`ArrayList`类的构造函数。

![images](img/.jpg)

##### 属性

[表 11-9](#tab_11_9) 列出了`ArrayList`类的不同属性。

![images](img/.jpg)

##### 方法

`ArrayList`类有不同的方法，可以用来做不同的操作。[表 11-10](#tab_11_10) 列出了`ArrayList`类的不同方法。

![images](img/.jpg)

![images](img/.jpg)

![images](img/.jpg)

#### 数组与数组列表

一个`ArrayList`是一个复杂版本的数组。大多数需要数组的情况可以使用`ArrayList`来代替。一般来说，`ArrayList`更容易使用，性能类似于类型对象的数组。[表 11-11](#tab_11_11) 列出了一个`Array`和`ArrayList`的元素。

![images](img/.jpg)

### 堆叠

一个`Stack`是一个只能在序列的一端访问的项目序列。放入序列中的最后一个数据项首先被处理。所有活动都发生在`Stack`的顶部。`Push`操作将一个数据项放在`Stack`的顶部，但是`Pop`从`Stack`的顶部移除一个数据项。

#### 叠在一起。网

当您实例化`Stack`类而没有指定容量时，`Stack`的初始容量是 10。`Stack`的初始容量将被设置为默认容量 N (= 10)，默认存储在`Stack`类的内部字段`_defaultCapacity`中，或者提供不同的初始容量。`Stack`类在内部使用`_size`字段来表示内部`_array`当前保存了多少项。如果`Stack`的当前容量是十，并且它保存三个项目，则`_size`字段将是三个。容量会增加到 2N，以在需要时扩展内部`_array`。[图 11-14](#fig_11_14) 展示了`Stack`操作的行为。

![images](img/-14.jpg)

***图 11-14。**堆栈基础知识*

如果堆栈的当前容量为 10，并且需要添加另一个项目，它会将容量增加到 10 × 2 = 20(将是 20 × 2 = 40，40 × 2 = 80，80 × = 160，160 × 2 = 320，320 × 2 = 640，以此类推，以将更多的项目容纳到`Stack`中)。在将新项目添加到`Stack`之后，它会将`_size`字段更新 1，因此在添加之后`_size`字段将是 11。

#### 堆栈声明

英寸 NET 中，`Stack`类在`mscorlib.dll` ( `C:\Windows\ Microsoft.NET \Framework\v4.0.30319`)程序集的`System.Collections`命名空间中定义，如图[图 11-15](#fig_11_15) 所示。

![images](img/-15.jpg)

***图 11-15。**系统中的栈类。集合名称空间*

`Stack`类的签名应该是:

`public class Stack : ICollection, IEnumerable, ICloneable`

让我们看一个`Stack`用法的例子，如[清单 11-13](#list_11_13) 所示。

***清单 11-13。**栈类的一个例子*

`using System;
using System.Collections;

namespace Ch11
{
    class Program
    {
        static void Main(string[] args)
        {
            Stack terrestrialPlanets = new Stack();
            terrestrialPlanets.Push("Mercury");
            terrestrialPlanets.Push("Venus");
            terrestrialPlanets.Push("Earth");
            terrestrialPlanets.Push("Mars");

            ShowResult(terrestrialPlanets);
        }

        public static void ShowResult(IEnumerable aList)
        {
            foreach (string item in aList)
                Console.Write("{0}\t",item);
            Console.WriteLine();
        }
    }
}`

该程序将产生以下输出:

`Mars    Earth   Venus   Mercury`

#### 栈的实例化

当您调用三个重载构造函数中的一个时,`Stack`开始生效:

`public Stack()                          {}
public Stack(int initialCapacity)       {}
public Stack(ICollection col)           {}`

当 CLR 执行第一个版本的`Stack`构造函数时，它用默认值 10 初始化内部的`_array`。构造函数的第二个版本用参数`initialCapacity`提供的给定大小初始化`_array`。CLR 获取第三版构造函数的参数`col`的大小(使用`col`的`Count`属性的值)，用这个大小初始化`_array`，并将`col`的全部内容复制到`_array`中。[图 11-16](#fig_11_16) 展示了`Stack`构造函数的实例化。

![images](img/-16.jpg)

***图 11-16。**堆栈类及其构造函数*

清单 11-14 中显示了`Stack`构造函数的实现。

***清单 11-14。**重载栈构造函数的实现*

`public Stack()
{
    this._array = new object[10];
    this._size = 0;
    this._version = 0;
}

public Stack(int initialCapacity)
{
    if (initialCapacity < 10)
    {
        initialCapacity = 10;
    }
    this._array = new object[initialCapacity];
    this._size = 0;
    this._version = 0;
}`

从第二个构造函数中，您可以看到用`initialCapacity`来定义内部`_array`的大小。第三个版本的`Stack`构造函数接受一个`Collection`对象作为输入，并基于给定的`Collection`对象初始化`Stack`对象。[清单 11-15](#list_11_15) 展示了`Stack`类的第三个构造器的实现。

***清单 11-15。**堆栈构造函数的实现，它接受一个集合作为输入*

`public Stack(ICollection col) : this((col == null) ? 0x20 : col.Count)
{
    if (col == null)
    {` `        throw new ArgumentNullException("col");
    }
    IEnumerator enumerator = col.GetEnumerator();
    while (enumerator.MoveNext())
    {
        this.Push(enumerator.Current);
    }
}`

#### 堆栈中的推送操作

当 CLR 将元素推入`Stack`时，它检查`_size`字段和内部`_array`的长度是否相同。如果它们相等，则 CLR:

*   用当前`_array x 2`的大小在本地创建一个新的临时数组
*   将现有`_array`的内容复制到这个新数组中
*   将这个临时本地数组复制到`_array`

[图 11-17](#fig_11_17) 展示了基于`Stack`类内部`_array`的`Stack`类的`Push`和`Pop`操作，CLR 在此存储添加到`Stack`的项目。

![images](img/-17.jpg)

***图 11-17。**栈中的推送和弹出操作*

清单 11-16 中的[展示了`Push`方法的实现。](#list_11_16)

***清单 11-16。**栈类的 Push 方法的实现*

`public virtual void Push(object obj)
{
    **/* _size refers to the number of cells from _array is being used. */**
    if (this._size == this._array.Length)                                    
    {` `        object[] destinationArray = new object[2 * this._array.Length];
        Array.Copy(this._array, 0, destinationArray, 0, this._size);
        this._array = destinationArray;
    }
    this._array[this._size++] = obj;
    this._version++;
}`

#### 栈中的 Peek 和 Pop 操作

当 CLR 执行`Peek`方法时，它从`Stack`类的`_array`中返回一个顶层项目的副本，如使用`Peek`方法实现的[清单 11-17](#list_11_17) 所示。

***清单 11-17。**Stack 类的 Peek 方法的实现代码*

`public virtual object Peek()
{
   **/* It copies the item stored at position (_size -1) from  _array*/**
    return this._array[this._size - 1]; 
}`

另一方面，`Pop`方法将从`Stack`的`_array`返回最顶端的项目，并将该位置的值设置为 null，以删除该位置的值的内容。清单 11-18 展示了`Stack`类的`Pop`方法的实现。

***清单 11-18。**栈类的 Pop 方法的实现*

`public virtual object Pop()
{
   **/* Copy the top most value from the _array into the obj2 */**
    object obj2 = this._array[--this._size];   
   **/* Set the value as null at the top most position of the _array */**
    this._array[this._size] = null;
    return obj2;
}`

#### 清除堆栈中的操作

`Stack`类的`Clear`方法将保存在`_array`中的所有现有项目重置为默认值，并将`Stack`类的`_size`设置为零。`Clear`方法不会调整`_array`的大小，但是会删除`_array`中存储的所有值。`Clear`方法的实现如[清单 11-19](#list_11_19) 所示。

***清单 11-19。**栈类的 Clear 方法的实现*

`public virtual void Clear()
{
    Array.Clear(
        this._array, **/* The original array which to reset */**
        0,           **/* The starting index from where the reset will start */**
        this._size   **/* Total number of item to reset which is the size of**` `                      *** the _array */**
        );
    this._size = 0;  **/* Set the size of the Stack as 0 which makes the Count**
                      *** property as 0 as the Count property is return**
                      *** this._size; */**
    this._version++;
}`

#### 堆栈类成员

`Stack`类为列表中的`Push`和`Pop`项提供了几个方法。

##### 菲尔茨

[表 11-12](#tab_11_12) 列出了`Stack`类内部用来实现堆栈功能的不同字段。

![images](img/.jpg)

##### 构造器

`Stack`类有三个重载的构造函数来初始化`Stack`类的一个实例。

![images](img/.jpg)

##### 性能

[表 11-14](#tab_11_14) 列出了`Stack`类的不同属性。

T2】

##### 方法

`Stack`类有不同的方法，可以用来做不同的操作。[表 11-15](#tab_11_15) 列出了`Stack`类中使用的不同方法。

![images](img/.jpg)

![images](img/.jpg)

### 队列

`Queue`是一种数据结构，它使 CLR 能够以一种确保先进先出的方式向列表中输入数据。一个数据项从后面进入`Queue`，从前面离开。当一个项目加到`Queue`的末尾，就说是`Enqueue`；但是当它删除了`Queue`开头的一项，就说是`Dequeue`。

#### 队列的大小。网

`Queue`的大小用 N 表示，其中 N 是 32，这是`Queue`的默认大小，除非为该大小定义了不同的值。[图 11-18](#fig_11_18) 演示了`Queue`类。

![images](img/-18.jpg)

***图 11-18。**队列类基础知识*

#### 队列声明

在`mscorlib.dll`组件的`System.Collections`命名空间中定义的`Queue`类在[图 11-19](#fig_11_19) 中演示。

![images](img/-19.jpg)

***图 11-19。**系统中的队列。集合命名空间*

`Queue`类的签名是:

`public class Queue : ICollection, IEnumerable, ICloneable`

让我们看一个使用`Queue`类的例子，如[清单 11-20](#list_11_20) 所示。

***清单 11-20。**队列类的例子*

`using System;
using System.Collections;

namespace Ch11
{
    class Program
    {
        static void Main(string[] args)
        {
            Queue terrestrialPlanets = new Queue();
            terrestrialPlanets.Enqueue("Mercury");
            terrestrialPlanets.Enqueue("Venus");
            terrestrialPlanets.Enqueue("Earth");
            terrestrialPlanets.Enqueue("Mars");
            ShowResult(terrestrialPlanets);
        }

        public static void ShowResult(IEnumerable aList)
        {
            foreach (string item in aList)
                Console.Write("{0}\t", item);
            Console.WriteLine();
        }
    }
}`

该程序将产生以下输出:

`Mercury   Venus   Earth   Mars`

#### 队列实例化

当您调用以下四个重载构造函数之一时,`Queue`开始生效:

`public Queue()                                               {}
public Queue(int capacity)                                   {}
public Queue(ICollection col)                                {}
public Queue(int capacity, float growFactor)                 {}`

当 CLR 执行第一个版本的`Queue`构造函数时，它用默认值 32 初始化内部的`_array`。构造函数的第二个版本用作为输入提供给`capacity`参数的给定大小初始化`_array`。CLR 获取第三版构造函数的参数`col`的大小(使用`col`的`Count`属性的值)，并使用该大小初始化`_array`。然后，它将`col`的全部内容复制到`_array`中。[图 11-20](#fig_11_20) 展示了`Queue`构造器的内部工作方式。

![images](img/-20.jpg)

***图 11-20。**队列类及其构造函数*

清单 11-21 中显示了`Queue`构造函数的实现。

***清单 11-21。**队列类的构造函数的实现*

`public Queue() : this(0x20, 2f){}
public Queue(ICollection col) : this((col == null) ? 0x20 : col.Count)
{
    IEnumerator enumerator = col.GetEnumerator();
    while (enumerator.MoveNext())
    {
        this.Enqueue(enumerator.Current);
    }
}
public Queue(int capacity) : this(capacity, 2f){}
public Queue(int capacity, float growFactor)
{
    this._array = new object[capacity];` `    this._head = 0;
    this._tail = 0;
    this._size = 0;
    this._growFactor = (int) (growFactor * 100f);
}`

#### 队列中的入队和出队操作

当 CLR 将一个元素排入`Queue`时，它会检查`_size`字段和内部`_array`的长度是否相同。如果它们相等，则 CLR:

*   使用新长度确保具有新长度的内部`_array`的容量，新长度是`_array`的当前长度加四
*   在内部调用`SetCapacity`方法来为`Queue`设置这个新值
*   将元素放在`_array`的顶部

[图 11-21](#fig_11_21) 演示了`Queue`类的`Enqueue`和`Dequeue`操作。

![images](img/-21.jpg)

***图 11-21。**队列类中的入队和出队操作*

清单 11-22 中的[展示了`Dequeue`方法的实现。](#list_11_22)

***清单 11-22。**队列类的出列方法的实现*

`public virtual object Dequeue()
{
    object obj2 = this._array[this._head];
    this._array[this._head] = null;
    this._head = (this._head + 1) % this._array.Length;
    this._size--;
    this._version++;
    return obj2;
}`

清单 11-23 中展示了`Enqueue`方法的实现。

***清单 11-23。**队列类的 Enqueue 方法的实现*

`public virtual void Enqueue(object obj)
{
    if (this._size == this._array.Length)
    {
        int capacity = (int) ((this._array.Length * this._growFactor) / 100L);
        if (capacity < (this._array.Length + 4))
        {
            capacity = this._array.Length + 4;
        }
        this.SetCapacity(capacity);
    }
    this._array[this._tail] = obj;
    this._tail = (this._tail + 1) % this._array.Length;
    this._size++;
    this._version++;
}`

#### 清除队列中的操作

`Queue`类的`Clear`方法将所有保存在`_array`中的现有项目重置为默认值，并将`Queue`类的`_size`、`_head`和`_tail`设置为零。`Clear`方法不会删除存储在`_array`中的所有项目，而是用默认值重置它们。清单 11-24 展示了`Clear`方法的实现。

***清单 11-24。**队列类的 Clear 方法的实现*

`public virtual void Clear()
{
    **/*.........*/**
    Array.Clear(
        this._array,  **/* The original array which to reset */**
        _head, ,      **/* The starting index from where the reset will start */**
        this._size,   **/* Total number of item to reset*/**
        );
    **/*.........*/**
    this._head = 0;
    this._tail = 0;
    this._size = 0;
    this._version++;
    this._size = 0; , **/* Set the size of the Queue as 0 which makes the Count,**                                                      
                       *** property as 0 as the Count property is return**
                       *** this._size; */**
    this._version++;
}`

#### 队列类成员

本节将探索在`Queue`中使用的不同字段、构造函数和成员。

##### 字段

[表 11-16](#tab_11_16) 列出了`Queue`类内部用来实现队列功能的不同字段。

![images](img/.jpg)

##### 构造器

`Queue`类有四个重载的构造函数来初始化`Queue`类的一个实例。表 11-17 列出了四个可以用来实例化`Queue`类的构造函数。

![images](img/.jpg)

##### 性能

[表 11-18](#tab_11_18) 列出了`Queue`类的不同属性。

![images](img/.jpg)

##### 方法

`Queue`类有不同的方法，可以用来做不同的操作。[表 11-19](#tab_11_19) 列出了`Queue`类中使用的不同方法。

![images](img/.jpg)

### 哈希表

一个`Hashtable`类由包含集合元素的`buckets`数组组成。一个`bucket`是`Hashtable`中元素的虚拟子组，这使得搜索和检索比大多数集合更容易和更快。`Hashtable`在。NET 表示基于键的哈希代码组织的键和值对的集合。*哈希函数*是一种算法，它基于一个键返回一个数字哈希代码。散列函数必须总是为同一个键返回相同的散列码，而且它也可能为两个不同的键生成相同的散列码(冲突)。但是，当从哈希表中检索元素时，为每个唯一键生成唯一哈希代码的哈希函数会产生更好的性能。

#### 哈希表的大小。网

`Hashtable`的初始大小是三(第一个质数如[表 11-20](#tab_11_20) 所示)，它将使用[表 11-20](#tab_11_20) 中所示的值之一来调整`buckets`数组的大小，以容纳更多的项目。

![images](img/.jpg)

CLR 用来自`primes`数组的三初始化其默认大小，如[表 11-20](#tab_11_20) 所示，并逐步增加来自`primes`数组的下一个质数，以扩展大小来容纳更多的项目。否则，CLR 会手动生成一个新的素数来调整`Hashtable`的大小。

#### 哈希表声明

中的`mscorlib.dll` ( `C:\Windows\Microsoft.NET\ Framework\v4.0.30319`)程序集的`System.Collections`命名空间中定义了`Hashtable`类。NET，如图[图 11-22](#fig_11_22) 所示。

![images](img/-22.jpg)

***图 11-22。**系统中的哈希表类。集合命名空间*

`Hashtable`类的签名是:

`public class Hashtable :
                  IDictionary, ICollection, IEnumerable, ISerializable,
                  IDeserializationCallback, ICloneable`

清单 11-25 中的[显示了`Hashtable`的一个例子。](#list_11_25)

***清单 11-25。**哈希表类的例子*

`using System;
using System.Collections;

namespace Ch11
{
    class Program
    {
        static void Main(string[] args)
        {
            Hashtable terrestrialPlanets = new Hashtable();
            terrestrialPlanets.Add("Mercury",       
                                   "The innermost of the eight planets.");
            terrestrialPlanets.Add("Venus",            
                                   "The second planet from the Sun.");
            terrestrialPlanets.Add("Earth",             
                                   "The third planet from the Sun.");
            terrestrialPlanets.Add("Mars",              
                                   "The fourth planet from the Sun.");
            terrestrialPlanets.Add("Vesta",              
                         "One of the largest asteroids in the Solar System.");

            Console.WriteLine(
                "Mercury\t{0}\nVenus\t{1}\nEarth\t{2}\nMars\t{3}\nVesta\t{4}",
                terrestrialPlanets["Mercury"],
                terrestrialPlanets["Venus"],
                terrestrialPlanets["Earth"],` `                terrestrialPlanets["Mars"],
                terrestrialPlanets["Vesta"]);
        }
    }
}`

该程序将产生以下输出:

`Mercury               The innermost of the eight planets.
Venus                 The second planet from the Sun.
Earth                 The third planet from the Sun.
Mars                  The fourth planet from the Sun.
Vesta                 One of the largest asteroids in the Solar System.`

#### 哈希表的实例化

当您调用以下 15 个重载构造函数之一时,`Hashtable`开始生效:

`public Hashtable()                                                      {}
public Hashtable(bool trash)                                            {}
public Hashtable(IDictionary d)                                         {}
public Hashtable(IEqualityComparer equalityComparer)                    {}
public Hashtable(int capacity)                                          {}
public Hashtable(IDictionary d, IEqualityComparer equalityComparer)     {}
public Hashtable(IDictionary d, float loadFactor)                       {}
public Hashtable(IHashCodeProvider hcp, IComparer comparer)             {}
public Hashtable(int capacity, IEqualityComparer equalityComparer)      {}
public Hashtable(IDictionary d, IHashCodeProvider hcp,
                                                     IComparer comparer){}
public Hashtable(IDictionary d, float loadFactor, IEqualityComparer
                                                       equalityComparer){}
public Hashtable(int capacity, IHashCodeProvider hcp,
                                                     IComparer comparer){}
public Hashtable(int capacity, float loadFactor, IEqualityComparer
                                                       equalityComparer){}
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp,
                                                    IComparer comparer) {}
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp,  
                                                     IComparer comparer){}`

当 CLR 执行第一个版本的`Hashtable`构造函数时，它用默认大小三初始化内部数组`buckets`。在`Add`操作中，CLR 通过检查`Hashtable`中元素的当前数量或者增加哈希表的大小以容纳新的条目来检查条目是否可以存储在`buckets`数组中。

#### 哈希表中的加法操作

当您向`Hashtable`中添加一个新项时，CLR 通过调用`InitHash`方法来计算给定项的关联键的哈希代码:

`**/* num3 refers to the Hashcode of the key of the given item */**
uint num3 = this.InitHash(key, this.buckets.Length, out num, out num2);`

`InitHash`方法计算给定项目的键的散列码。`InitHash`方法的实现应该是:

`**/*incr hold the value for the num2*/**
private uint InitHash(object key, int hashsize, out uint seed, out uint incr)   
{
   uint num = (uint) (this.GetHash(key) & 0x7fffffff);
   seed = num;
   incr = 1 + ((uint) (((seed * 0x65) + 1) % (hashsize - 1)));
   return num;
}`

CLR 使用`num3`变量(包含哈希代码)来生成`buckets`表的槽索引(指的是将添加该项的`buckets`数组的位置)，它在该表中存储该项(`buckets`是一个一维数组，每个单元格被称为`buckets`的一个槽)。`buckets`数组的每一项都包含一个`bucket`，它被定义为`struct`的一种类型，如[清单 11-26](#list_11_26) 所示。

***清单 11-26。**哈希表类中使用的桶结构的实现*

`private struct bucket
{
    public int           hash_coll; **/* To hold the Hash code of the Key */**
    public object        key;       **/* To store the Key */**
    public object        val;       **/* To store the associated value of the Key*/**
}`

槽索引将使用给定键的散列码和`buckets`数组的当前长度来计算:

`**/* num6 refers to the slot index of the buckets table. */** int num6 = (int) (num % this.buckets.Length);`

CLR 使用这个槽索引作为`buckets`表的位置，将一个项目添加到`buckets`表中。计算完槽索引后，CLR 会根据三个条件尝试将该项添加到`buckets`中:无冲突、冲突和重复检查。接下来的部分将详细探讨每一个。

##### 向哈希表添加项目时没有冲突

CLR 使用槽索引(`num6`)在`buckets`中寻找空闲槽，以查看它是否已经被占用或者是否有任何重复的键。如果没有冲突，CLR 会将键和值添加到存储在由槽索引(`num6`)引用的位置处的`buckets`数组中的`bucket`的实例中，如该实现所示:

`**/* To check whether the item in the position of slot index (num6) of the**
 *** buckets array contains any key or not by checking the bucket, return**
 *** from the buckets array at position num6, holds null for the Key field */**
if ((this.buckets[num6].key == null) ||
    ((this.buckets[num6].key == this.buckets) &&    
    ((this.buckets[num6].hash_coll & 0x80000000L) == 0L)))
{
    if (index != -1)` `    {
        num6 = index;
    }
    Thread.BeginCriticalRegion();
    this.isWriterInProgress = true;

  **/* Stores the value of the item into buckets array at the position of the**
   *** slot index num6 calculated earlier */**
    this.buckets[num6].val = nvalue;

  **/* Stores the key of the item into buckets array at the at the position of**
   *** the slot index num6 calculated earlier */**
    this.buckets[num6].key = key;

   **/* num3 refers the hash code generated from the Key */**
    this.buckets[num6].hash_coll |= (int) num3;

   **/* Increase the count which refers the total number of items stored in**
    *** the buckets array.*/**
    this.count++;                                                        
    this.UpdateVersion();
    this.isWriterInProgress = false;
    Thread.EndCriticalRegion();
}`

结果，CLR 在`buckets`数组的槽索引位置(`num6`)添加该项。

##### 向哈希表添加项目时发生冲突

如果来自`buckets`的索引(`num6`)位置处的槽已经被占用，CLR 使用旧的槽索引重新生成槽索引(因此将重新生成`num6`的值)。它还通过对旧的`hash_coll`值进行(或运算)来修改存储在`buckets`数组中旧的生成的槽索引(`num6`)的位置处的项目的`hash_coll`值:

`**/* Updates the hashcoll value by doing the OR */**
this.buckets[num6].hash_coll   |= -2147483648;`

这个新计算的槽索引(`num6-regenerated`)用于检查`buckets`在该位置是否有空闲槽。如果 CLR 在`buckets`中找到任何空闲的槽，那么它将给定的项添加到那个槽中，或者重复地在`buckets`中寻找一个可用的槽。对此的实现将是:

`{
    if ((index == -1) && (this.buckets[num6].hash_coll >= 0))
    {
        **/* Change the old slot item's hash code value */**
        this.buckets[num6].hash_coll |= -2147483648;
        this.occupancy++;
    }

    **/* Generates new slot index and stores into num6\. num2 refers in the**
     *** InitHash method discussed earlier */**` `    num6 = (int) ((num6 + num2) % ((ulong) this.buckets.Length));
    if (++num4 < this.buckets.Length)
    {
        **/* Go to the code block in where CLR will check for the availability**
         *** of the empty slot */**
    }
}`

当你试图向`Hashtable`中添加更多的条目，但是`Hashtable`中的条目总数开始超过`Hashtable`的大小限制时，`buckets`的大小必须扩展(当前`buckets`的大小是三，程序试图添加更多，如[清单 11-25](#list_11_25) 所示)。CLR 使用下一个质数(例如，`primes`数组中的 7 `)`,并调用`rehash`方法将旧`buckets`中的现有项重新分配到新的扩展`buckets`中，新的槽索引是基于新的`buckets`长度和存储在`buckets`数组中的每个现有键的散列码值计算的。在这一阶段，CLR 通过执行 OR 操作来替换所有负的`hash_coll`值(如前所述，当获取索引时，CLR 更新该项目的`hash_coll`),或通过`0x7fffffff`回滚该项的先前`hash_coll`值:

`bucket.hash_coll & 0x7fffffff`

##### 添加到哈希表时出现重复项

当 CLR 向`Hashtable`添加一个项目时，如果发现任何重复的键，CLR 抛出一个异常，因为`Hashtable`不允许重复的键。[图 11-23](#fig_11_23) 展示了 CLR 在`Hashtable`中执行的`Add`操作。

![images](img/-23.jpg)

***图 11-23。**哈希表中的添加操作。*

从[图 11-23](#fig_11_23) 可以看出:

*   CLR 用默认值 3 初始化`buckets`的大小，并且用默认值初始化`buckets`中的每个桶。例如，`bucket` struct 有`hash_coll`的`int`、`key`的`object`和`val`，所以对于 **`buckets`** 中的每个**桶**都初始化为`{0, null, null}`。
*   第一项`Mercury`被添加到`buckets`数组的位置 0，因为已经计算了索引 0。
*   在`Venus`加法的迭代中，CLR 为`Venus`生成了槽索引 0，但是它已经被`Mercury`占用。所以生成了一个新的槽索引，它是 2，并且在`buckets`数组的位置 2 添加了项目`Venus`。此外，`0x7fffffff`已经对索引 0 的`hash_coll`值进行了“或”运算，并且该“或”值将在`buckets`扩展和`rehashing`时间回滚。
*   当 CLR 试图将`Earth`添加到`Hashtable`中时，它发现需要扩展现有的`buckets`。它扩展`buckets`，重新散列现有项目，并将所有现有项目添加到具有更新的槽索引信息的`buckets`中。基于新的`buckets`再次计算新的槽索引，以添加`Earth`项。
*   根据这个添加规则，`Mars`和`Vesta`项被添加到`Hashtable`的`buckets`中。

#### 哈希表中的删除操作

当您试图根据键删除存储在`Hashtable`中的任何项时，CLR 会计算哈希代码，并使用该哈希代码来生成索引，以便在`buckets`数组中定位键。如果索引包含您试图移除的键，CLR 将为存储在`buckets`数组该位置的该项设置`key`和`val`为空值，并将`Hashtable`的`count`字段减 1。

#### 哈希表类成员

本节将探索在`Hashtable`中使用的不同字段、构造函数和成员。

##### 性能

[表 11-21](#tab_11_21) 列出了`Hashtable`类的不同属性。

![images](img/.jpg)

##### 方法

`Hashtable`类有不同的方法，可以用来做不同的操作。[表 11-22](#tab_11_22) 列出了`Hashtable`类的不同方法。

![images](img/.jpg)

![images](img/.jpg)

### 字典

`Dictionary<TKey,TValue>`是一个通用的数据结构，表示 C#中键值的集合。它维护一个`buckets`和`entries`表来实现`Dictionary`功能。`entries`表包含一个由`struct`条目组成的数组，用于保存键和值信息，而`buckets`表根据存储在`entries`表中的键来维护项目的索引或位置。[图 11-24](#fig_11_24) 展示了`Dictionary<TKey,TValue>`类中`buckets`和`entries`表之间的关系。

![images](img/-24.jpg)

***图 11-24。**字典中的桶和条目关系< TKey，TValue > Class*

#### 字典的大小。网

`Dictionary<TKey, TValue>`类用默认的大小三初始化`buckets`和`entries`表，但是这个大小可以改变以容纳更多的条目。CLR 使用[表 11-23](#tab_11_23) 中显示的一个值(质数)来调整`buckets`和`entries`表的大小。否则，CLR 会手动生成一个质数来调整`buckets`和`entries`表的大小。

![images](img/.jpg)

#### 字典声明

中的`mscorlib.dll`程序集的`System.Collections.Generic`命名空间中定义的`Dictionary<TKey, TValue>`类。NET 在[图 11-25](#fig_11_25) 中演示。

![images](img/-22.jpg)

***图 11-25。**系统中的字典< TKey，TValue >。通用名称空间*

`Dictionary<TKey, TValue>`类的签名应该是:

`public class Dictionary<TKey, TValue> :
    IDictionary<TKey, TValue>,
    ICollection<KeyValuePair<TKey, TValue>>,
    IEnumerable<KeyValuePair<TKey, TValue>>,
    IDictionary,
    ICollection,
    IEnumerable,
    ISerializable,
    IDeserializationCallback`

清单 11-27 展示了一个`Dictionary<TKey, TValue>`类的例子。

***清单 11-27。**字典的例子< TKey，TValue >类*

`using System;
using System.Collections.Generic;

namespace Ch11
{
    class Program
    {
        static void Main(string[] args)
        {
            IDictionary<string, string> terrestrialPlanets =
                                        new Dictionary<string, string>();

            terrestrialPlanets.Add("Mercury",      
                                   "The innermost of the eight planets.");
            terrestrialPlanets.Add("Venus",        
                                   "The second planet from the Sun.");
            terrestrialPlanets.Add("Earth",        
                                   "The third planet from the Sun.");
            terrestrialPlanets.Add("Mars",         
                                   "The fourth planet from the Sun.");` `            terrestrialPlanets.Add("Vesta",        
                         "One of the largest asteroids in the Solar System.");
            terrestrialPlanets.Add("Ceres",        
                               "The dwarf planet in the inner Solar System.");
            terrestrialPlanets.Add("Pallas",       
                                   "One of the largest in the Solar System.");

            Console.WriteLine(                "Mercury\t{0}\nVenus\t{1}\nEarth\t{2}\nMars\t{3}\
nVesta\t{4}\nCeres\t{5}\nPallas\t{6}\n",
                terrestrialPlanets["Mercury"    ],
                terrestrialPlanets["Venus"      ],
                terrestrialPlanets["Earth"      ],
                terrestrialPlanets["Mars"       ],
                terrestrialPlanets["Vesta"      ],
                terrestrialPlanets["Ceres"      ],
                terrestrialPlanets["Pallas"     ]);
        }
    }
}`

清单 11-27 中的程序将产生以下输出:

`Mercury                 The innermost of the eight planets.
Venus                   The second planet from the Sun.
Earth                   The third planet from the Sun.
Mars                    The fourth planet from the Sun.
Vesta                   One of the largest asteroids in the Solar System.
Ceres                   The dwarf planet in the inner Solar System.
Pallas                  One of the largest in the Solar System`

#### 字典的实例化

当您调用以下六个重载构造函数之一时,`Dictionary<TKey, TValue>`开始生效:

`public Dictionary()                                                {}
public Dictionary(IDictionary<TKey, TValue> dictionary)            {}
public Dictionary(IEqualityComparer<TKey> comparer)                {}
public Dictionary(int capacity)                                    {}
public Dictionary(IDictionary<TKey, TValue> dictionary,                 
                                  IEqualityComparer<TKey> comparer){}
public Dictionary(int capacity, IEqualityComparer<TKey> comparer)  {}`

当 CLR 执行`Dictionary`的构造函数时，它初始化其内部数据结构`buckets`和`entries`。`buckets`表保存`entries`表的索引，`entries`表保存基于使用`Key`计算的索引的`{Key, Value}`信息。使用`Entry`结构将`Key`和`Value`信息存储在`entries`表中。清单 11-28 中显示了`Entry`结构的实现。

***清单 11-28。**字典类中使用的入口结构的实现*

`private struct Entry
{
    public int        hashCode;   **/* It holds the hash code for the Key */**
    public TKey       key;        **/* It holds the key of the item */**
    public int        next;       **/* It holds the index of an Entry from**
                                   *** the entries table */**
    public TValue     value;      **/* It holds the value of the item */**
}`

#### 字典中的加法运算

在`Dictionary`的`Add`操作中，CLR 首先初始化两个内部数据结构`buckets`和`entries`。在初始化这些数据结构之后，CLR 计算`buckets`表的索引，在那个位置上`buckets`表的条目指向包含键和值的`entries`表。然后，CLR 将在`Dictionary`中添加相关项，并存储键和值。

##### 时段和条目初始化

当 CLR 第一次执行`Dictionary<TKey, TValue>`中的`Add`操作时，它用默认值初始化两个数据结构——`buckets`和`entries`。例如，`buckets`的每一项都用-1 初始化，`entries`表中的每一项都用其默认值:

`{
     0        **/* hashCode */,**
     null     **/* key */,**
     0        **/* next item in the entry */,**
     null     **/* value */**
}`

##### 指数计算

CLR 使用以下语句计算给定键(`Ki`)的哈希代码(`Hc`):

`**/* Calculates the Hashcode */**
int num = this.comparer.GetHashCode(key) & 0x7fffffff;`

然后，CLR 使用以下语句使用`Hc` ( `num)`)和`buckets`的长度来计算索引:

`int index = num % this.buckets.Length;  **/* Calculates the index */**`

这个索引`Ib`用于在`buckets`表中查找可用的空闲单元格(值为-1 ),如果找到，它将把条目表中该项的位置(相关项是根据`Dictionary`的`count`字段存储的)作为索引存储在`buckets`表中`Ib`的位置。

索引`Ib`用作`buckets`表的位置，用于存储`entries`表的位置，其中存储了与键相关的值(已经为其计算了索引`Ib`)。

##### 添加到字典时没有冲突、碰撞和重复检查

CLR 计算`buckets`的索引，以在发生冲突的过程中存储相关项目。下面几节将对此进行更详细的探讨。

向字典添加项目时没有冲突

CLR 检查`buckets`表中的索引`Ib`(它将其用作在`buckets`表中查找的位置号)是否有任何空闲单元格，或者桶中该索引`Ib`位置的值是否已经被填充，如语句所示:

`int i = this.buckets[index];   i >= 0;   i = this.entries[i].next`

`I > 0`表达式表示在计算出的索引`Ib`的位置上`buckets`中是否有项目。如果数组查找(`this.buckets[index]`)的结果为-1 (-1 已被 CLR 置位以初始化`buckets`表的`bucket`)，则该索引位置处的桶(单元)尚未被使用。因此，-1 表示相关的桶单元已经初始化，但尚未使用。CLR 将使用该单元格存储项目在`entries`表中的位置(将项目与为其计算`Ib`的键相关联)(基于`Dictionary`类的`freeList`字段用作位置)。

CLR 使用当前的`count` ( `freeList`使用`Dictionary`类的`count)`的值作为位置(如[清单 11-27](#list_11_27) 所示，`Mercury`T5 的值为 0)来存储`entries`表中的项目:

`**/* freeList holds the value of the count of the  Dictionary */**
this.entries[freeList].hashCode = num;
**/* The value of buckets at position index Ib stores into the next  to do the**
 *** linked with collide data*/**
this.entries[freeList].next           = this.buckets[index];  
this.entries[freeList].key            = key;
this.entries[freeList].value          = value;
**/* Update the value of the buckets at position of the computed index Ib with**
** * the current count (freeList) value. So now the entries and buckets holding**
** * the same index for the Key */**
this.buckets[index]           = freeList;`

CLR 还将`Dictionary`类的`count`加 1，稍后它将被用作 entries 表的位置，以将下一项添加到`Dictionary`。

`buckets`表中的每一项都具有索引信息，该索引信息引用回条目表的索引，在该索引中已经存储了与关键字相关联的项。

向字典中添加条目时的冲突和重复检查

如果数组 look up ( `buckets[index])`的返回值大于-1，这意味着`buckets`的单元格正在被占用。因此，`entries`表中有一个条目，数组查找返回值指的是`entries`表中可以找到条目的位置。这被称为*碰撞*。为了解决冲突，CLR 将首先遍历存储在`entries`表中的条目(`Ec`)，其位置是在`buckets`表中存储(作为值)索引`Ib`的位置。然后，它检查关键字的散列码是否存储在`entries`表的条目`Ec`项中，以及当前关键字的相关散列码(与要添加的项相关联)是否相同。如果是相同的，CLR 抛出这个重复的异常。

向词典添加条目时发生冲突

如果给定项目(`Gi`)有任何冲突，CLR 将通过`freeList`变量获得`Dictionary`类的当前`count`值，并将该位置(`freeList`)的项目`Gi`作为一个条目添加到 entries 表中。对于该项的下一个字段，CLR 将位于 entries 表中的项放在`buckets[index]`结果的位置，如代码所示:

`**/* It adds the index of the entry from the entries table at position of**
 *** the result of the buckets[index] into the next field of the current**
 *** entry item stored in the entries table at position of the freeList*/**
this.entries[freeList].next = this.buckets[index];`

CLR 然后用当前`freeList`的值更新存储在桶表的当前索引`Ib`位置中的信息，当前`freeList`是当前项目`Gi`已经存储在`entries`表中的最新位置:

`**/* It updates the information stored in the buckets at position of index (Ib)**
 *** with the current freeList which is the latest count value. */**
this.buckets[index] = freeList;`

因此，这确保了对于`entries`表中的所有项目，使用正确的映射索引来存储`buckets`。[图 11-26](#fig_11_26) 展示了`Dictionary<TKey,TValue>`中的`Add`操作。

![images](img/-26.jpg)

***图 11-26。** CLR 在运行时执行加法操作*

从[图 11-26](#fig_11_26) 中，你可以看到 CLR 在`Dictionary:`中添加项目

*   对于`entries`表中的每个项目，CLR 用-1 和`{0, null, 0, null}`初始化`buckets`数据。
*   当 CLR 试图添加键`Mercury`时，它会计算用于查找`buckets`的索引，并检查该单元格是否可用于存储`Mercury`项的条目表的索引信息。与`Mercury`关联的项目将存储在`entries`表的位置 0，也存储在索引的`buckets`数组的位置 0。
*   当 CLR 尝试添加`Venus`时，它将计算索引位置，即位置 0，但它已经被`Mercury`条目占用。因此，CLR 将增加`Dictionary`的当前`count`字段，该字段随后成为位置 1，并在条目数组中的`Dictionary`的`count`的该位置添加`Venus`信息，还将位置 0 的项目与其链接(解决冲突)。CLR 将索引信息存储在桶表中的位置 0，并将更新后的新位置信息存储在条目表中。`buckets`表中位置 0 的项目现在将是 1 而不是 0。
*   当 CLR 试图在`Dictionary`中添加`Mars`键时，它发现需要扩展`buckets`和`entries`数组。所以在扩展之后，CLR 会刷新存储在`buckets`和`entries`表中的现有条目和映射信息。它将基于`Mars`键重新计算索引，并更新`buckets`数组的长度。最后，它将`Mars`添加到`entries`数组的右边位置，并更新`buckets`数组的映射信息。
*   重复这些相同的步骤，在数组中添加其他项目。

#### 查字典

当 CLR 根据`Dictionary`中的键查找项目时，它遵循几个步骤。首先，它访问 index 属性，通过提供键来查找`Dictionary`。它调用`FindEntry`方法，检查`buckets`是否为空。然后，它将计算给定键(`num`)的散列码，并计算索引，以使用散列码和`buckets`的长度来查找`buckets`表:

`num % this.buckets.Length`

`bucket [num % this.buckets.Length]`的返回值将是用于查找匹配键的`entries`表的相关索引。使用从`bucket [num % this.buckets.Length ]`语句返回的值，CLR 循环直到到达`> = 0`；如果不是`> 0`，那么就是`-1`，也就是说这个条目没有其他关联条目。正如我们在初始化中了解到的，当`buckets`中没有条目时，默认值是-1，如基于[清单 11-29](#list_11_29) 中的键的字典查找的实现所示。

***清单 11-29。**字典类的 FindEntry 方法的实现*

`private int FindEntry(TKey key)
{
    if (this.buckets != null)
    {
        int num = this.comparer.GetHashCode(key) & 0x7fffffff;
        for (int i = this.buckets[num % this.buckets.Length]; i >= 0;
                                            i = this.entries[i].next)
        {
            if ((this.entries[i].hashCode == num) &&
                 this.comparer.Equals(this.entries[i].key, key))
            {
                return i;
            }
        }
    }
    return -1;
}`

在这个迭代中，它将检查来自`entries`的项目是否具有与查找键相同的散列码和键，如果是，CLR 停止迭代并返回`i`的值，该值引用 `entries`表的索引。使用这个位置值，CLR 从`entries`表中返回一个`Entry`，实现`Index`属性，如[清单 11-30](#list_11_30) 所示。

***清单 11-30。**字典索引的实现< TKey，TValue >类*

`public TValue this[TKey key]
{
    get
    {
        int index = this.FindEntry(key);
        if (index >= 0)
        {
            return this.entries[index].value;
        }

        return default(TValue);
    }
    set {.....}
}`

#### 字典类成员

`Dictionary<TKey, TValue>`类提供了创建、操作和搜索项的键和值的方法。接下来的部分探索了在`Dictionary`类中使用的不同的字段、构造函数和成员。

##### 性能

[表 11-24](#tab_11_24) 列出了`Dictionary`类的不同属性。

![images](img/.jpg)

##### 方法

`Dictionary`类有不同的方法，可以用来做不同的操作。[表 11-25](#tab_11_25) 列出了`Dictionary`类的不同方法。

![images](img/.jpg)

### 总结

在本章中，我们学习了中的不同集合类型。NET，比如`Array`、`List`、`ArrayList`、`Stack`、`Queue`、`Hashtable`、`Dictionary`。您已经了解了这些类中的每一个如何动态地确保容纳所需数据量的容量，并且已经了解了这些类是如何通过使用阵列在内部实现的。在下一章，你将深入探究 C#中的 Linq。