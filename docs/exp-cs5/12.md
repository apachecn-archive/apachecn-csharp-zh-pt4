## 第十二章

![images](img/.jpg)

## C#中的 Linq

本章将讨论中的语言集成查询(Linq)。NET 并详细探究在`Enumerable`类中定义的扩展方法，这些扩展方法被提供来使用 C#执行 Linq 操作。首先，您将学习 Linq 的基础知识，然后研究在`Enumerable`类中提供的每个扩展方法的幕后操作。基于它们基于委托的查询语法，您将在`ildasm.exe`和的帮助下学习这些扩展方法的内部实现。网络反射器工具。

### 先来看看 Linq in。网

英寸任何从`mscorlib.dll`程序集的`System.Collections.Generic`命名空间实现`IEnumerable<T>`的数据结构都能够访问在`System.Core.dll`程序集的`System.Linq`命名空间的`Enumerable`类中定义的所有扩展方法。在你深入研究之前，我应该提到基于委托的 Linq 查询操作符是在`System.Core.dll`汇编的`Enumerable`类中定义的，这些操作符的完整列表显示在[表 12-1](#tab_12_1) 中。下面的代码提供了一个例子，其中`series`有三项:

`List<string> series = new List<string>(){`"`One`"`,` "`Two`"`,` "`Three`"`};`

您可以使用`Where`方法过滤列表，或者使用`Select`投射到输出中。因为`List<T>`类型实现了`IEnumerable`接口和`Enumerable`类中定义的`Where`和`Select`扩展方法，所以它是`IEnumerable<T>.`类型，例如,`Where`扩展方法是`IEnumerable<TSource>`的类型，如下面的代码所示:

`public static IEnumerable<TSource> Where<TSource>(
    this IEnumerable<TSource> source, Func<TSource, bool> predicate)`

任何实现了`IEnumerable<T>`的类型都能够使用在`Enumerable`类中定义的扩展方法。例如，`List<T>`类实现`IEnumerable<T>`作为`List<T>`类的签名，如代码所示:

`public class List<T> :
    IList<T>,ICollection<T>,IEnumerable<T>,IList,ICollection,IEnumerable`

`Enumerable`类是一个静态不可继承的类。代码中演示了`Enumerable`类的定义:

`.class public abstract auto ansi sealed beforefieldinit
    System.Linq.Enumerable extends [mscorlib]System.Object`

在`System.Core.dll`组件的`System.Linq`命名空间中定义，如图[图 12-1](#fig_12_01) 所示。

![images](img/-01.jpg)

***图 12-1。**系统。系统中的 Linq . Enumberable 类。Linq*

静态的`Enumerable`类是`IEnumerable<T>`的不同扩展方法类型的容器，例如:

`public static bool Contains<TSource>(
    this IEnumerable<TSource> source, TSource value)                      {}
public static int Count<TSource>(this IEnumerable<TSource> source)        {}
public static IEnumerable<TSource> Distinct<TSource>(
    this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer){}
   /* and many more */`

### 扩展方法

extension 方法是基于委托的 Linq 查询操作的核心。你可以在第 4 章中找到更多关于扩展方法的细节。

### Linq 中的 Lambda 表达式和表达式树

英寸 NET 中，Linq 查询方法(指的是那些在`Enumerable`类中定义的扩展方法)允许您对一系列项目执行不同的操作，比如过滤、投影、键提取或分组。在查询操作中，您可以使用 lambda 表达式的概念来代替这些函数(即过滤、投影)，这将提供一种方便的方式来编写可以作为参数传递给后续计算的函数。Lambda 表达式是一种 CLR 委托函数，它必须封装由委托类型定义的方法。Lambda 表达式类似于 CLR 委托，它们必须遵循委托类型定义的方法签名。例如:

`string expressionName = "Lambda Expression";
Func<string, int> filter = item => item.Length >3;`

我们可以在`Where`方法中使用这个滤波器λ，例如:

`**/* To filter the string in expressionName variable */**
expressionName.Where(filter);`

你也可以这样写:

`expressionName.Where( item => item.Length >3 );`

一般来说，您可以在查询方法中自由使用命名方法、匿名方法或 lambda 表达式。Lambda 表达式的优势在于为创作提供了最直接、最简洁的语法。Linq 还允许使用`Expression<T>`(在`System.core.dll`程序集的`System.Expresion`名称空间中定义)来定义 lambda 表达式。当您使用这个`Expression<T>`创建 lambda 表达式时，C#编译器会为 lambda 表达式生成一个表达式树，而不是定义方法体。使用`Expression<T>`的表达式树的一个例子是:

`Expression<Predicate<int>> expression = n => n < 10;`

在编译时，C#编译器将根据查询操作符中 lambda 表达式的用法来确定是发出 IL 指令还是表达式树。编译器使用以下基本规则来确定是为查询方法生成表达式树还是基于方法:

*   当 lambda 表达式被赋给类型为委托的变量、字段或参数时，编译器会发出与匿名方法相同的 IL。
*   当 lambda 表达式被赋给类型为`Expression<T>`的变量、字段或参数时，编译器会发出一个表达式树。

本章将探讨可用于基于委托的方法的 Linq 查询方法。

### 在 Linq 中延迟执行

*延迟* *执行*是执行模型的一种模式，通过这种模式，CLR 确保只有在需要时才会从基于`IEnumerable<T>`的信息源中提取值。当任何 Linq 操作符使用延迟执行时，CLR 将相关信息(如原始序列、谓词或选择器(如果有))封装到一个迭代器中，当使用`ToList`方法或`ForEach`方法或手动使用 C#中的底层`GetEnumerator`和`MoveNext`方法从原始序列中提取信息时，将使用该迭代器。[图 12-2](#fig_12_02) 演示了 Linq 中的延迟执行。

![images](img/-02.jpg)

***图 12-2。**延期执行的例子*

例如，如图 12-2 中的[所示，为了从序列`numbers`中提取数据，CLR 为一个`Iterator`对象准备相关信息，在`result fetch`阶段，它将实际执行迭代器，使用谓词和/或选择器从序列中获取数据，这是在准备阶段封装的。](#fig_12_02)

在 C#中，通过在相关迭代器块中直接使用`yield`关键字来支持延迟执行。[表 12-1](#tab_12_1) 列出了 C#中使用`yield`关键字来确保延迟执行的迭代器。

![images](img/.jpg)

![images](img/.jpg)

### Linq 中的查询方法

在这里，我们将研究实现基于委托的语法的 Linq 查询方法的幕后操作。所有的查询方法都有类别，如[表 12-2](#tab_12_2) 所示，该表总结了所有的扩展方法及其关联的类别。

![images](img/.jpg)

![images](img/.jpg)

#### 基于过滤和投影的方法

本节将探讨过滤方法`Where`和投影方法`Select`。

##### 在哪里选择

`Where`和`Select`是`IEnumerable<TSource>`常用的两种扩展方法，用于过滤和投影列表或序列的数据。列表与这两个扩展方法一起工作，并且需要实现`IEnumerable<T>`。`Where`和`Select`扩展的签名是:

`public static IEnumerable<TSource> Where<TSource>(
    this IEnumerable<TSource> source, Func<TSource, bool> predicate)
public static IEnumerable<TSource> Where<TSource>(
    this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)`

[清单 12-1](#list_12_1) 演示了`Where`和`Select`扩展方法的使用。

***清单 12-1。**Where 和 Select 子句的示例*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)` `        {
            IList<string> numbers = new List<string>()
            {
                "One", "Two", "Three", "Four", "Five", "Six", "Seven"
            };

            var numbersLengthThree =
                numbers.Where(x => x.Length == 3).Select(x => x).ToList();

            numbersLengthThree.ForEach(x => Console.WriteLine(x));
        }
    }
}`

[清单 12-1](#list_12_1) 创建一个字符串序列并将它们存储在`numbers`中，这是`IList<string>`的一种类型，然后从`numbers`中过滤出字符总数等于 3 的项目，并将结果投射到一个新的列表`numbersLengthThree`。使用`ForEach`方法，它遍历新列表并在控制台上显示输出。清单 12-1 的输出将是:

`One
Two
Six`

Where 和 Select 执行的内部操作

让我们仔细分析一下[清单 12-1](#list_12_1) 中的代码，以便真正理解 CLR 在执行程序时如何处理`Where`和`Select`扩展方法。关注[清单 12-1](#list_12_1) 中的下面一行，看看 CLR 是如何处理的:

`numbers.Where(x => x.Length == 3).Select(x => x).ToList()`

这一行代码用于过滤和投影来自`numbers`序列的数据。[图 12-3](#fig_12_03) 展示了基于[清单 12-1](#list_12_1) 的`Where`和`Select`扩展方法。

![images](img/-03.jpg)

***图 12-3。**Where 和 Select 扩展方法如何工作*

从[图 12-3](#fig_12_03) 可以看出:

*   CLR 将`numbers`序列作为输入传递给`Where`方法以及`MulticastDelegate`的一个实例，该实例保存了关于在编译时由 C#编译器为匿名方法块`(x=>x.Length == 3)`编译的`<Main>b__1`方法的信息。
*   `Where`方法返回`WhereListIterator<string>`迭代器的一个实例，然后在`Select`方法中与`MulticastDelegate`的另一个实例一起使用，该实例保存了关于在编译时从匿名方法`(x=>x)`创建的方法`<Main>b__2`的信息。
*   `Select`方法根据输入的可枚举数实例化相关的迭代器；例如，[清单 12-1](#list_12_1) 中程序的`WhereSelectListIterator<string, string>`迭代器。在此之前，由于延迟执行，CLR 不会处理原始列表。
*   CLR 将这个迭代器实例作为输入传递给`ToList`方法，该方法最终使用过滤标准(`<Main>b__1`)遍历序列来处理原始列表，并使用投影(`<Main>b__2`)获得一个新列表作为输出。

**执行 Where 方法**

本节分析了 CLR 在执行`Where`方法时采取的步骤。

*1。步骤 1*:C#编译器将来自`Where`方法的匿名方法块`x => x.Length == 3`编译成`<Main>b__1.`，跟在 C #编译器为匿名方法`x => x.Length == 3`生成的反编译后的 IL 代码之后:

`.method private hidebysig static bool <Main>b__1(string x) cil managed
{
   **/* Code removed */**
    L_0000: ldarg.0

   **/* To get the Length of the string */**
    L_0001: callvirt instance int32 [mscorlib]System.String::get_Length()
    L_0006: ldc.i4.3

   **/* Check the equality of the length */**
    L_0007: ceq
    L_0009: stloc.0
    L_000a: br.s L_000c
    L_000c: ldloc.0
    L_000d: ret
}`

等效的 C#代码应该是:

`private static bool <Main>b__1(string x) {
    return (x.Length == 3);
}`

CLR 使用方法`<Main>b__1`实例化`MulticastDelegate`的一个实例，该实例将被用作从序列中过滤项目的委托。在编译时，C#编译器还为`(x=>x)`创建了另一个方法`<Main>b__2`，如以下 IL 代码所示:

`.method private hidebysig static string <Main>b__2(string x) cil managed
{
    **/* Code removed */**
    L_0000: ldarg.0
    L_0001: stloc.0
    L_0002: br.s L_0004
    L_0004: ldloc.0
    L_0005: ret
}`

或者使用等效的 C#代码:

`private static string <Main>b__2(string x)
{
    return x;
}`

CLR 使用`<Main>b__2`实例化了`MulticastDelegate`的另一个实例，它将被用作投影器来投影来自过滤序列的项目。

*2。第二步*:当 CLR 开始执行[清单 12-1](#list_12_1) 中的程序时，它开始执行`Where`方法。它传递原始序列号和`MulticastDelegate`(在步骤 1 中创建)的实例作为输入，如下面清单 12-1 中的`Main`方法的反编译 IL 代码所示:

`.method private hidebysig static void Main(string[] args) cil managed {
    .entrypoint
    .maxstack 4
    .locals init (
        [0] class [mscorlib]System.Collections.Generic.IList'1<string> numbers
        **/* Code removed */)**
    L_0000: nop

    **/* Step 1: Created List<string> object for the numbers */**
    L_0001: newobj instance void
            [mscorlib]System.Collections.Generic.List'1<string>::.ctor()
    **/* Code removed */**
    L_005c: stloc.0

    **/* Step 2: Load the numbers variable into the evaluation stack */**
    L_005d: ldloc.0
    L_005e: ldsfld class
            [mscorlib]System.Func'2<string, bool>  /***Field type** */
            Ch12.Program::CS$<>9__CachedAnonymousMethodDelegate4
    L_0063: brtrue.s L_0078
    L_0065: ldnull
    L_0066: ldftn bool Ch12.Program::<Main>b__1(string)` `    L_006c: newobj instance void
            [mscorlib]System.Func'2<string, bool>::.ctor(object, native int)

    L_0071: stsfld class
            [mscorlib]System.Func'2<string, bool>
            **/* It is holding the <Main>b__1 now */**
            Ch12.Program::CS$<>9__CachedAnonymousMethodDelegate4

    L_0076: br.s L_0078
    L_0078: ldsfld class
            [mscorlib]System.Func'2<string, bool>
            Ch12.Program::CS$<>9__CachedAnonymousMethodDelegate4

    **/* Step 3: CLR will call the Where extension by passing numbers retrieved**
     *** into the evaluation stack at L_005c and the delegate object of**
     *** System.Func'2<string, bool> (inherited from MulticastDelegate)**
     *** at L_0078 */**
    L_007d: call
        **/* return type of the Where */**
        class [mscorlib]System.Collections.Generic.IEnumerable'1<!!0>
        [System.Core]System.Linq.Enumerable::Where<string>(
            **/* First parameter type, CLR will pass value for this */**
            class [mscorlib]System.Collections.Generic.IEnumerable'1<!!0>,
            **/* Second parameter type CLR will pass value for this  */**
            class [mscorlib]System.Func'2<!!0, bool>
        )
    /* Code removed */
}`

*3。步骤 3* :基于`numbers`的数据类型，`Where`方法返回适当的迭代器实例作为输出。返回适当迭代器的`Where`方法的实现在[清单 12-2](#list_12_2) 中演示。

***清单 12-2。**Where 方法的实现*

`public static IEnumerable<TSource> Where<TSource>(
    this IEnumerable<TSource> source, Func<TSource, bool> predicate)
{
    if (source is Iterator<TSource>)
        return ((Iterator<TSource>) source).Where(predicate);
    if (source is TSource[])
        return new WhereArrayIterator<TSource>((TSource[]) source, predicate);
    if (source is List<TSource>)
        return new WhereListIterator<TSource>(
                   (List<TSource>) source, predicate);
    return new WhereEnumerableIterator<TSource>(source, predicate);
}

public static IEnumerable<TSource> Where<TSource>(
    this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
{` `    return WhereIterator<TSource>(source, predicate);
}`

您可以在 Linq 的`System.Core.dll`汇编中找到不同扩展方法使用的迭代器类的完整列表。[图 12-4](#fig_12_04) 显示了用于`Where`方法的迭代器。

![images](img/-04.jpg)

***图 12-4。**System.Core.dll 程序集的可枚举类中使用的迭代器类*

例如，CLR 从`Where`方法返回`WhereListIterator<TSource>`迭代器，它包含作为源序列的原始列表和作为谓词的`<Main> b__1`。CLR 将这个`WhereListIterator<TSource>`作为输入传递给`Select`方法。

**选择方法的执行**

在执行`Select`方法时，CLR 根据`IEnumerable`对象和选择器委托的输入实例化相关的迭代器。对于清单 12-1 中的[程序，CLR 将返回一个`WhereSelectListIterator<TSource,TResult>`的实例作为`Select`方法的输出。返回适当迭代器的`Select`方法的实现在](#list_12_1)[清单 12-3](#list_12_3) 中演示。

***清单 12-3。**选择方法的实现代码*

`public static IEnumerable<TResult> Select<TSource, TResult>(
    this IEnumerable<TSource> source, Func<TSource, TResult> selector)
{
    if (source is Iterator<TSource>)
        return ((Iterator<TSource>) source).Select<TResult>(selector);
    if (source is TSource[])
        return new WhereSelectArrayIterator<TSource, TResult>(
              (TSource[]) source, null, selector);
    if (source is List<TSource>)
        return new WhereSelectListIterator<TSource, TResult>(
              (List<TSource>) source, null, selector);

    return new WhereSelectEnumerableIterator<TSource, TResult>(source, null, selector);
}` 
`public static IEnumerable<TResult> Select<TSource, TResult>(
    this IEnumerable<TSource> source, Func<TSource, int, TResult> selector)
{
    return SelectIterator<TSource, TResult>(source, selector);
}`

由`Select`方法返回的迭代器包含原始列表、谓词委托(`<Main>b__1`)和选择器或投影委托(`<Main>b__2`)。

*4。第 4 步*:CLR 不会处理序列，直到程序调用`ToList`方法或者由于延迟执行而使用`ForEach`方法。CLR 将这个`WhereSelectListIterator<string,string>`迭代器实例作为输入传递给`ToList`方法。在`ToList`方法中，CLR 通过将`WhereSelectListIterator<string,string>`迭代器作为输入传递给它来实例化`List<string>`的实例。

*5。步骤 5*:CLR 遍历枚举器，从输入参数`collection` ( `WhereSelectListIterator<string,string>`)中获取项目，并对其应用过滤标准，并将结果添加到动态`_items`数组中(`List<TSource>`类的一个字段)。该列表对象作为原始列表的结果返回。在`Where`和`Select`方法的新列表实例化过程中演示了`List<TSource>`构造函数的实现，如[清单 12-4](#list_12_4) 所示。

***清单 12-4。**列表的构造者<资源>T3】*

`public list(ienumerable<t> collection)
{
    **/* copy the original list into is2 */**
    icollection<t> is2 = collection as icollection<t>;
    if (is2 != null)
    {
        int count = is2.count;

        **/* Initialize the _items using number of item in the original list.*/**
        this._items = new t[count];
        is2.copyto(this._items, 0);
        this._size = count;
    }
    else
    {
        this._size = 0;
        this._items = new t[4];
        using (ienumerator<t> enumerator = collection.getenumerator())
        {
            **/* iterate through each of the item from the sequence and execute**
             *** the filtering function Predicate over that item if it returns**
             *** true then that item will be add to the new list. */**
            while (enumerator.movenext())
            {
            **/* This add method internally work as dynamic array by making**
             *** sure the size of the array using EnsureCapacity method**` `             *** (See [Chapter 11](11.html#ch11) for the more about the**
             *** EnsureCapacity method).*/**
            this.add(enumerator.current);
            }
        }
    }
}`

您已经详细研究了从序列中过滤和投影数据的`Where`和`Select`扩展方法。下一节将研究 Linq 的基于分区的扩展方法，这些方法可用于操作序列。

#### 基于分区的方法

本节将探讨基于分区的方法，比如`Skip`、`SkipWhile`、`Take`和`TakeWhile`。

##### 跳跃

`Skip`方法用于绕过序列中指定数量的元素，然后将剩余的元素作为输出返回。由于延迟执行，立即返回值是相关迭代器类型的对象，它存储了执行跳过操作所需的所有信息。`Skip`方法遍历列表，从列表的开始处跳过指定数量的项目。指定的数字作为此方法的参数提供。`Skip`的签名扩展方法是:

`public static IEnumerable<TSource> Skip<TSource>(this IEnumerable<TSource> source, int count)`

[清单 12-5](#list_12_5) 中的程序在`numbers`中创建了一个`strings`序列，其中保存了 1、2、3、4 和 5 作为这个序列的项目。

***清单 12-5。**跳过方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<string> numbers = new List<string>()
            {
                "One","Two","Three", "Four","Five"
            };

            var result = numbers.Skip(2);
            result.ToList().ForEach(number => Console.WriteLine(number));
        }` `}
}` 

清单 12-5 中的程序将产生输出:

`Three
Four
Five`

跳过执行方法的内部操作

让我们看看 CLR 如何执行清单 12-5 中的代码`numbers.Skip(2)`。

*1。第 1 步*:CLR 从`Skip`方法返回`SkipIterator<TSource>`(它保存原始列表和计数，以定义要跳过的项目数)。

*2。步骤 2* :由于延迟执行模式，这个`SkipIterator<TSource>`由 CLR 执行，例如，在迭代用于`ToList`方法的序列时，如[清单 12-5](#list_12_5) 所示。在`SkipIterator<TSource>`中，CLR 运行一个循环，直到要跳过的项目数变为零。在这个迭代过程中，CLR 移动内部`Enumerator`对象的当前位置。当项目数变为零时，它再次循环遍历列表，将原始序列中的剩余项目作为输出返回，如[清单 12-6](#list_12_6) 所示。

***清单 12-6。**Skip 方法的实现代码*

`private static IEnumerable<TSource> SkipIterator<TSource>(
    IEnumerable<TSource> source,
    int count)
{
    using (IEnumerator<TSource> iteratorVariable0 = source.GetEnumerator())
    {
        **/* Skip items from the begin of the list as long as count > 0 */**
        **/* Outer loop */**
        while ((count > 0) && iteratorVariable0.MoveNext())
            count--;
        **/* As soon as count becomes 0 CLR returns the rest of the item**
         *** as output. */**
        if (count <= 0)
        {
            **/* The CLR will start iterating the original list from the point**
             *** the CLR left from the outer loop */**
            **/* Inner loop */**
            while (iteratorVariable0.MoveNext())
                yield return iteratorVariable0.Current;
        }
    }
}`

##### 滑雪时

只要指定的条件为真，扩展方法就绕过序列中的元素，并将剩余的元素作为输出返回。这个扩展方法的签名是:

`public static IEnumerable<TSource> SkipWhile<TSource>(
    this IEnumerable<TSource> source, Func<TSource, bool> predicate)
public static IEnumerable<TSource> SkipWhile<TSource>(
    this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)`

清单 12-7 中的[提供了一个使用`SkipWhile`方法的例子。](#list_12_7)

***清单 12-7。**skip while 方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<string> numbers = new List<string>()
            {
                "One","Two","Three", "Four","Five"
            };

            var result = numbers.SkipWhile(number => number.Length == 3);
            result.ToList().ForEach(number => Console.WriteLine(number));
        }
    }
}`

清单 12-7 中的程序将产生输出:

`Three
Four
Five`

SkipWhile 执行方法的内部操作

输出显示,`SkipWhile`方法排除了输出序列中长度等于 3 的项目。让我们详细分析[清单 12-7](#list_12_7) 中的代码，以理解当 CLR 执行`SkipWhile`方法时发生了什么。

*1。步骤 1*:C #编译器在编译时使用匿名方法(`number => number.Length == 3`)构造一个方法`<Main>b__1`。CLR 将使用`<Main>b__1`方法作为`SkipWhile`的谓词来实例化`MulticastDelegate`的实例。CLR 使用原始列表和谓词`<Main>b__1`实例化`SkipWhileIterator`迭代器的一个实例。由于延迟执行，`SkipWhileIterator`不会执行，直到 CLR 调用`ToList`或使用`ForEach`方法进行迭代。

*2。步骤 2*:CLR 对从`SkipWhile`方法返回的`SkipWhileIterator`执行`ToList`方法，在`SkipWhileIterator`内部，CLR 逐个遍历原始列表，并对每一项执行谓词。如果谓词返回 false，那么`SkipWhileIterator`将返回该项作为`SkipWhile`方法的结果；或者如果它返回 true，那么它继续遍历列表，直到完成。CLR 在运行时使用的`SkipWhileIterator`的实现如[清单 12-8](#list_12_8) 所示。

***清单 12-8。**skip while iterator 的实现代码*

`private static IEnumerable<TSource> SkipWhileIterator<TSource>(
    IEnumerable<TSource> source,
    Func<TSource, bool> predicate)
{
    bool iteratorVariable0 = false;
    foreach (TSource iteratorVariable1 in source)
    {
        if (!iteratorVariable0 && !predicate(iteratorVariable1))
            iteratorVariable0 = true;

        if (iteratorVariable0)
            yield return iteratorVariable1;
    }
}`

##### 拿

方法用于从列表中返回指定数量的元素。`Take`方法的一个例子显示在[清单 12-9](#list_12_9) 中。

***清单 12-9。**Take 方法的例子*

`using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> series = new List<int>()
           {
               1,2,3,4,5,6,7
           };` `            series.Take(4)
                .ToList()
                .ForEach(number =>
                         Console.Write(string.Format("{0}\t",number)));
        }
    }
}`

该程序将产生以下输出:

`1       2       3       4`

它将返回`TakeIterator`，它将封装原始列表和保存要获取的元素数量的计数。迭代器一执行完`ToList`或`Foreach`方法，就会立即执行。

##### 抓紧时间

`TakeWhile`方法用于从满足给定条件的序列中提取那些项目。[清单 12-10](#list_12_10) 展示了`TakeWhile`方法的使用。

***清单 12-10。**take while 方法的例子*

`using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> series = new List<int>()
           {
               1,2,3,4,5,6,7
           };
            Console.WriteLine("When the condition is true");
            series.TakeWhile(number => number < 3)
                .ToList()
                .ForEach(number => Console.Write(string.Format("{0}\t",
                                                                 number)));

            Console.WriteLine("\nOn first false return iteration will stop ");
            series.TakeWhile(number => number > 3)
                .ToList()
                .ForEach(number => Console.Write(string.Format("{0}\t",
                                                                 number)));
        }
    }
}`

该程序产生了以下输出:

`When the condition is true
1       2
On first false return iteration will stop`

TakeWhile 执行方法的内部操作

`TakeWhile`方法将返回带有原始列表和谓词的`TakeWhileIterator`,它将把这个迭代器传递给`List`类，同时对其执行`ToList`方法。`ToList`将创建一个新的`List`，在`List`构造函数中，它将遍历迭代器，也就是`TakeWhileIterator`。它将根据几个步骤返回原始列表中的项目。只要列表中的项的条件为真，它就会继续沿着列表向下移动，从列表中取出该项。但是，当谓词第一次出现错误返回时，CLR 将停止迭代原始列表以获取该项，并返回到目前为止找到的任何项(即，列表中满足条件的任何项，并且只有这些项)。实现这一点的代码应该是:

`private static IEnumerable<TSource> TakeWhileIterator<TSource>(
    IEnumerable<TSource> source,
    Func<TSource, bool> predicate)
{
    foreach (TSource iteratorVariable0 in source)
    {
        **/* While the predicate return false for a item from the original list it will break the**
**iteration*/**
        if (!predicate(iteratorVariable0))
        {
            break;
        }
        **/* Otherwise return that item from the original list */**
        yield return iteratorVariable0;
    }
}`

#### 串联方式

本节详细讨论了`Concat`方法的操作。

##### 联结合并多个字符串

`Concat`扩展方法将两个序列连接成一个序列。这个方法不同于`Union`方法，因为`Concat<TSource>`返回输入序列中所有的原始元素，而不考虑重复的元素，而`Union`方法只返回序列中唯一的元素。这个扩展方法的签名应该是:

`public static IEnumerable<TSource> Concat<TSource>(
    this IEnumerable<TSource> first, IEnumerable<TSource> second)`

清单 12-11 中的程序演示了`Concat`方法。

***清单 12-11。**Concat 方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> listOne = new List<int>()
            {
                1,2,3,4,5,6
            };

            IList<int> listTwo = new List<int>()
            {
                6,7,8,9,10
            };

            var result = listOne.Concat(listTwo).ToList();
            result.ForEach(x => Console.Write(string.Format("{0}\t",x)));
        }
    }
}`

清单 12-11 中的程序将产生输出:

`1       2       3       4       5       6       6       7       8       9
10`

Concat 执行方法的内部操作

CLR 将序列`listOne`和`listTwo`中的项目连接成一个新序列，该序列包含所有具有重复值的项目，例如`{ 1,2,3,4,5,6,6,7,8,9,10 }`。[图 12-5](#fig_12_05) 展示了`Concat`方法的内部工作原理。

![images](img/-05.jpg)

***图 12-5。**Concat 扩展方法如何工作*

[图 12-5](#fig_12_05) 显示 CLR 将`listOne`和`listTwo`序列作为输入传递给`Concat`方法，并将`ConcatIterator<int>`的一个实例作为输出返回给调用者。由于`Concat`方法使用的延迟执行模式，`ToList`方法迭代序列中的项目，并基于连接逻辑连接`ConcatIterator<int>`和`listOne`序列，以产生最终的输出序列。让我们分析一下[清单 12-11](#list_12_11) 中的代码，来帮助解释当 CLR 执行`Concat`方法时发生了什么。

*1。步骤 1*:CLR 将原始列表`listOne`和`listTwo`作为输入传递给`Concat<TSource>`方法。

*2。步骤 2* :在`Concat`方法中，CLR 实例化`ConcatIterator<int>`迭代器，它保存`listOne`和`listTwo`，并返回给`Concat`方法的调用方。`Concat`方法的实现是:

`public static IEnumerable<TSource> Concat<TSource>(
    this IEnumerable<TSource> first,
    IEnumerable<TSource> second)
{
    return ConcatIterator<TSource>(first, second);
}`

*3。步骤 3*:`ToList`方法通过从`ConcatIterator<int>`实例返回的`Enumerator`对象遍历列表，例如`listOne`和`listTwo`，并将来自`listOne`和`listTwo`的每个项目插入到一个新列表中，并返回这个新列表作为`Concat`扩展的结果。

#### 订购方式

本节将探讨`ThenBy`和`Reverse`排序方法。

##### 然后呢

`ThenBy`方法按照升序对序列中的元素进行后续排序。因为它遵循了`ThenBy`中的延迟执行模式，所以立即返回值是一个相关类型的对象，它存储了所有信息，比如原始列表、键选择器等等。`ThenBy`的签名扩展方法是:

`public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(
    this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector)
public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(
    this IOrderedEnumerable<TSource> source,
    Func<TSource, TKey> keySelector, IComparer<TKey> comparer)`

清单 12-12 展示了`ThenBy`方法。

***清单 12-12。**then by 扩展方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;` 
`namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<Person> persons = new List<Person>()
            {
                new Person(){ Name="Person F", Address= "Address of F",  
                              Id= 111116},
                new Person(){ Name="Person G", Address= "Address of G",
                              Id= 111117},
                new Person(){ Name="Person C", Address= "Address of C",  
                              Id= 111113},
                new Person(){ Name="Person B", Address= "Address of B",
                              Id= 111112},
                new Person(){ Name="Person D", Address= "Address of D",
                              Id= 111114},
                new Person(){ Name="Person A", Address= "Address of A",
                              Id= 111111},
                new Person(){ Name="Person E", Address= "Address of E",
                              Id= 111115}           
            };

            var result =
                persons.OrderBy(person => person.Id).ThenBy(person => person);

            foreach (Person person in result)
            {
                Console.WriteLine("{0,-15} {1,-20}{2,-20}",
                    person.Name,
                    person.Address,
                    person.Id);
            }
        }
    }

    public class Person
    {
        public string Name
        {
            get;
            set;
        }

        public string Address
        {
            get;
            set;
        }` 
`        public double Id
        {
            get;
            set;
        }
    }
}`

该程序产生了以下输出:

`Person A        Address of A        111111
Person B        Address of B        111112
Person C        Address of C        111113
Person D        Address of D        111114
Person E        Address of E        111115
Person F        Address of F        111116
Person G        Address of G        111117`

ThenBy 执行方法的内部操作

该方法的工作原理如以下步骤所示。

*1。步骤 1* :它将调用`CreateOrderedEnumerable`方法，如[清单 12-13](#list_12_13) 所示。

***清单 12-13** 。ThenBy 方法的实现*

`public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(
    this IOrderedEnumerable<TSource> source,
    Func<TSource, TKey> keySelector)
{
    return source.CreateOrderedEnumerable<TKey>(keySelector, null, false);
}`

*2。步骤 2* : `CreateOrderedEnumerable`方法实例化`OrderedEnumerable`的一个实例，如[清单 12-14](#list_12_14) 所示。

***清单 12-14** 。CreateOrderedEnumerable 方法的实现*

`IOrderedEnumerable<TElement> IOrderedEnumerable<TElement>.CreateOrderedEnumerable<TKey>(
    Func<TElement, TKey> keySelector,
    IComparer<TKey> comparer,
    bool descending)
{
    return new OrderedEnumerable<TElement, TKey>(
        this.source,
        keySelector,
        comparer, descending)
    { parent = (OrderedEnumerable<TElement>) this };
}`

*3。第三步*:实现了`OrderedEnumerable`类，如[清单 12-15](#list_12_15) 所示。

***清单 12-15** 。`OrderedEnumerable`类*的实现

`internal class OrderedEnumerable<TElement, TKey> : OrderedEnumerable<TElement>
{
   /* Code removed*/
    internal OrderedEnumerable(
        IEnumerable<TElement> source,
        Func<TElement, TKey> keySelector,
        IComparer<TKey> comparer, bool descending)    {  /*Code removed*/ }

    internal override EnumerableSorter<TElement> GetEnumerableSorter(
        EnumerableSorter<TElement> next)
    {
        EnumerableSorter<TElement> enumerableSorter = new
            EnumerableSorter<TElement, TKey>(
                this.keySelector,
                this.comparer,
                this.descending, next);
        if (this.parent != null)
        {
            enumerableSorter =       
                     this.parent.GetEnumerableSorter(enumerableSorter);
        }
        return enumerableSorter;
    }
}`

##### 反面的

方法颠倒了序列中元素的顺序。该方法遵循延迟执行模式。与`OrderBy`不同，这种排序方法在确定顺序时不考虑实际值本身。相反，它只是以底层源产生元素的相反顺序返回元素。`Reverse`的签名扩展方法是:

`public static IEnumerable<TSource> Reverse<TSource>(this IEnumerable<TSource> source)`

在[清单 12-16](#list_12_16) 提供的例子中，`Reverse`方法颠倒了原始序列。

***清单 12-16。**逆向方法的例子*

`using System;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> numbers = new List<int>() { 1, 2, 3, 4, 5 };` `            var reverseNumbers = numbers.Reverse();

            var result = reverseNumbers.ToList();

            result.ForEach(x => Console.Write("{0}\t", x));
            Console.WriteLine();
        }
    }
}`

清单 12-16 中的程序将产生输出:

`5       4       3       2       1`

反向执行方法的内部操作

让我们仔细分析清单 12-16 中的代码，以真正理解当 CLR 执行`Reverse`方法时发生了什么。

*1。步骤 1*:CLR 将原始序列(在本例中为`numbers`)作为输入传递给`Reverse`方法，并实例化`ReverseIterator<TSource>`的一个实例，该实例包含由`ToList`或`ForEach`方法执行的相关信息。

*2。步骤 2*:CLR 将把`ReverseIterator<TSource>`实例传递给`ToList`方法，后者将这个迭代器传递给`List`类，并根据`ReverseIterator<TSource>`中实现的迭代逻辑处理操作。最后，这个方法产生相反的序列作为输出，如清单 12-17 所示。

***清单 12-17。**实施反向操作<t 资源>T3】*

`private static IEnumerable<TSource> ReverseIterator<TSource>(
    IEnumerable<TSource> source)
{
    **/* Copy the original list into this Buffer instance. Buffer is a struct**
     *** which hold input list into a internal array. */**
    Buffer<TSource> iteratorVariable0 = new Buffer<TSource>(source);

    **/* index will hold the last index of the buffer */**
    int index = iteratorVariable0.count - 1;

    while (true)
    {
        if (index < 0)
            yield break;

        **/* So the item at the last index from internal array of the Buffer**
         *** will be return and index will be decremented as long as the**
         *** while loop continue. */**
        yield return iteratorVariable0.items[index];` `        index--;
    }
}`

`Buffer`结构的定义是:

`.class private sequential ansi sealed beforefieldinit Buffer<TElement>     extends [mscorlib]System.ValueType
{

    .method assembly hidebysig specialname rtspecialname instance void
        .ctor(class
            [mscorlib]System.Collections.Generic.IEnumerable'1<!TElement>
            source) cil managed         {**/* Code removed */** }

    .method assembly hidebysig instance !TElement[] ToArray() cil managed
                   { **/* Code removed  */** }
    .field assembly int32 count

    **/* items array will hold the data from the sequence*/**
    .field assembly !TElement[] items
}`

#### 基于分组和连接的方法

本节将研究不同的基于分组和连接的方法，例如`Join`、`GroupJoin`和`GroupBy`。

##### 加入

`Join`操作符用于根据连接条件将两个序列合并成一个。[图 12-6](#fig_12_06) 演示了`Join`的操作。

![images](img/-06.jpg)

***图 12-6。**加入基本操作*

`Join`操作通过以下步骤进行:

*1。步骤 1* :使用内部序列和内部键选择器构建一个分组表。

*2。第二步*:遍历外部序列，与分组表匹配，确定匹配项，匹配项传递给结果选择器，处理匹配项，存储在`<>f__AnonymousType0<string,string>`类型的列表中。类型`<>f_AnonymousType0<string,string>`是基于传递给结果选择器的匿名类型构造的。

`Join`操作员的签名是:

`public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(
    this IEnumerable<TOuter> outer, IEnumerable<TInner> inner,
    Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector,
    Func<TOuter, TInner, TResult> resultSelector)

public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(
    this IEnumerable<TOuter> outer, IEnumerable<TInner> inner,
    Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector,
    Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer
)`

清单 12-18 中的[给出了一个`Join`操作的例子。](#list_12_18)

***清单 12-18。**执行加入操作*

`using System;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            List<Person> persons;
            List<Address> addresses;

            InitializeData(out persons, out addresses);

            **/* persons - Outer Sequence */**
            var result = persons.Join(
                **/*addresses - Inner Sequence*/**
                addresses,
                **/* Outer Key Selector */**
                person => person,
                **/* Inner Key Selector */**
                address => address.AddressOf,
                **/* Result Selector */**` `(person, address) =>
                    new
                    {
                        PersonName = person.PersonName,
                        AddressDetails = address.AddressDetails
                    }
                );

            result.ToList().
                ForEach(personAddress =>
                    Console.WriteLine("{0} \t{1}",
                    personAddress.PersonName, personAddress.AddressDetails));
        }

        private static void InitializeData(
            out List<Person> persons, out List<Address> addresses)
        {
            var personA = new Person
                { PersonID = "PA_01", PersonName = "A" };
            var personB = new Person
                { PersonID = "PB_01", PersonName = "B" };
            var personC = new Person
                { PersonID = "PC_01", PersonName = "C" };

            var addressOne = new Address
                { AddressOf = personA,
                  AddressDetails = "Mystery Street,Jupiter" };
            var addressTwo = new Address
                { AddressOf = personA, AddressDetails = "Dark Street,Mars" };
            var addressThree = new Address
                { AddressOf = personB, AddressDetails = "Sun Street,Jupiter" };
            var addressFour = new Address
                { AddressOf = personC, AddressDetails = "Dry Street,Neptune" };

            persons = new List<Person>
                { personA, personB, personC };
            addresses = new List<Address>
                { addressOne, addressTwo, addressThree, addressFour };
        }
    }

    public class Person
    {
        public string PersonID { get; set; }
        public string PersonName { get; set; }
    }

    public class Address
    {
        public Person AddressOf { get; set; }
        public string AddressDetails { get; set; }` `    }
}`

清单 12-18 中的程序产生了输出:

`A       Mystery Street,Jupiter
A       Dark Street,Mars
B       Sun Street,Jupiter
C       Dry Street,Neptune`

执行 Join 方法的内部操作

让我们分析一下[清单 12-18](#list_12_18) 中的代码，帮助我们深入理解 CLR 执行`Join`时发生了什么。[图 12-7](#fig_12_07) 展示了`Join`方法的内部细节。

![images](img/-07.jpg)

***图 12-7。**Join 方法如何工作*

图 12-7 所示的每个步骤将在以下讨论中详细探讨。

*1。步骤 1*:CLR 将相关数据，比如外部序列、内部序列、键和结果选择器，传递给`Join`方法，该方法选择合适的迭代器，如[清单 12-19](#list_12_19) 所示。

***清单 12-19。**Join 方法的实现*

`public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(
    this IEnumerable<TOuter> outer,
    IEnumerable<TInner> inner,` `    Func<TOuter, TKey> outerKeySelector,
    Func<TInner, TKey> innerKeySelector,
    Func<TOuter, TInner, TResult> resultSelector,
    IEqualityComparer<TKey> comparer)
{

    **/* JoinIterator will be returned which holds all the necessary information**
     *** to**   **execute while enumerated either via ToList() or ForEach method*/**
    return JoinIterator<TOuter, TInner, TKey, TResult>(
        outer,
        inner,
        outerKeySelector,
        innerKeySelector,
        resultSelector,
        comparer);
}`

[清单 12-19](#list_12_19) 显示了`Join`方法将`JoinIterator`返回给封装了相关信息的调用者。`Join`方法的调用者不会立即执行`JoinIterator`。

*2。步骤 2* :由于延迟执行，`Join`方法的调用者一调用`ToList`方法，CLR 就会开始执行`JoinIterator`。清单 12-20 显示了`JoinIterator`的实现代码。

***清单 12-20。**执行加入操作*

`private static IEnumerable<TResult> JoinIterator<TOuter, TInner, TKey, TResult>(
    IEnumerable<TOuter> outer,
    IEnumerable<TInner> inner,
    Func<TOuter, TKey> outerKeySelector,
    Func<TInner, TKey> innerKeySelector,
    Func<TOuter, TInner, TResult> resultSelector,
    IEqualityComparer<TKey> comparer)
{
    Lookup<TKey, TInner> iteratorVariable0 =
        Lookup<TKey, TInner>.CreateForJoin(**inner, innerKeySelector**, comparer);

    foreach (TOuter iteratorVariable1 in outer)
    {
        Lookup<TKey, TInner>.Grouping grouping =
            iteratorVariable0.GetGrouping(outerKeySelector(iteratorVariable1),
                                          false);

        if (grouping != null)
        {
            for (int i = 0; i < grouping.count; i++)
                yield return resultSelector(iteratorVariable1,
                                            grouping.elements[i]);
        }
    }
}`

[清单 12-20](#list_12_20) 显示 CLR 将使用`CreateForJoin`方法初始化一个`Lookup`类，该方法保存默认的`Grouping`类型的初始化分组数组。CLR 将遍历原始的内部序列，并基于内部序列`keySelector`，将迭代的项添加到`Lookup`类的分组数组中。`CreateForJoin`方法的实现是:

`internal static Lookup<TKey, TElement> CreateForJoin(
    IEnumerable<TElement> source,
    Func<TElement, TKey> keySelector,
    IEqualityComparer<TKey> comparer)
{
    **/* It will initialize an array of Grouping into the groupings**
     *** with the default size 7 */**
    Lookup<TKey, TElement> lookup = new Lookup<TKey, TElement>(comparer);
    foreach (TElement local in source)
    {
        TKey key = keySelector(local);
        if (key != null)
        {
            **/* Add the relevant key into the groupings array */**    
            lookup.GetGrouping(key, true).Add(local);
        }
    }
    return lookup;
}`

*3。第 3 步*:CLR 将遍历外部序列，并使用外部键选择器，从为内部序列创建的分组表中获取相关项目。

*4。第 4 步*:CLR 产生`resultSelector`来得到结果。

##### GroupJoin

`GroupJoin`与`Join`操作符的作用相同，但它产生层次输出。`GroupJoin`的签名方法是:

`public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(     this IEnumerable<TOuter> outer, IEnumerable<TInner> inner,
    Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector,
    Func<TOuter, IEnumerable<TInner>, TResult> resultSelector)

public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(
    this IEnumerable<TOuter> outer, IEnumerable<TInner> inner,
    Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector,
    Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer)`

一个`Join`例子的修改版本用于演示`GroupJoin`操作符的使用，如[清单 12-21](#list_12_21) 所示。

***清单 12-21。**群加入的例子*

`static void Main(string[] args)
{` `    List<Person> persons;
    List<Address> addresses;
    InitializeData(out persons, out addresses);

    **/* persons - Outer Sequence */**
    var result = persons.GroupJoin(
        **/*addresses - Inner Sequence*/**
        addresses,
        **/* Outer Key Selector */**
        person => person,
        **/* Inner Key Selector */**
        address => address.AddressOf,
        **/* Result Selector */**
        (person, address) =>
            new
            {
                PersonName = person.PersonName,
                AddressDetails =
                address.Select(innerAddress=>innerAddress.AddressDetails)
            }
        );

    var rr = result.ToList();
    foreach (var item in result)
    {
        Console.WriteLine("{0}", item.PersonName);
        item.AddressDetails.ToList().ForEach(
            address => Console.WriteLine(address));
    }
}`

它将产生输出:

`A
Mystery Street,Jupiter
Dark Street,Mars
B
Sun Street,Jupiter
C
Dry Street,Neptune`

##### 群组依据

`GroupBy`方法根据指定的键选择器对序列的元素进行分组。此方法有八个重载方法，其中之一是:

`public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(     this IEnumerable<TSource> source, Func<TSource, TKey> keySelector,
    Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector,
    IEqualityComparer<TKey> comparer)`

`GroupBy`方法的一个例子显示在[清单 12-22](#list_12_22) 中。

***清单 12-22。**group by 方法的例子*

`using System;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            List<Person> persons;
            InitializeData(out persons);

            var result = persons.GroupBy(
                person => person.PersonAge,
                person => person.PersonID,
                (Age, Id) =>
                    new
                    {
                        PersonAge = Age,
                        PersonID = Id
                    }
                );

            Console.WriteLine("Age group \t No of person \t Persons are");
            result.ToList().ForEach(item =>
                Console.WriteLine(
                    string.Format("{0,5} \t {1,15} \t {2,-33}",
                        item.PersonAge,
                        item.PersonID.Count(),
                        string.Join(",", item.PersonID))));
        }

        private static void InitializeData(
            out List<Person> persons)
        {
            persons = new List<Person>
            {
                new Person { PersonID = "PA_01", PersonAge = 6 },
                new Person { PersonID = "PB_01", PersonAge = 7 },
                new Person { PersonID = "PC_01", PersonAge = 7 },
                new Person { PersonID = "PD_01", PersonAge = 4 },
                new Person { PersonID = "PE_01", PersonAge = 7 },
                new Person { PersonID = "PF_01", PersonAge = 5 },
                new Person { PersonID = "PG_01", PersonAge = 5 },
                new Person { PersonID = "PH_01", PersonAge = 9 },
                new Person { PersonID = "PI_01", PersonAge = 9 }` `            };
        }
    }

    public class Person
    {
        public string PersonID { get; set; }
        public int PersonAge   { get; set; }
    }
}`

该程序将产生以下输出:

`Age group        No of person    Persons are
    6                  1         PA_01
    7                  3         PB_01,PC_01,PE_01
    4                  1         PD_01
    5                  2         PF_01,PG_01
    9                  2         PH_01,PI_01`

GroupBy 执行方法的内部操作

让我们分析[清单 12-22](#list_12_22) 来帮助我们理解当 CLR 执行`GroupBy`方法时发生了什么。[图 12-8](#fig_12_08) 展示了关于`GroupBy`方法的细节。

![images](img/-08.jpg)

***图 12-8。**分组方式的工作细节*

图 12-8 中的每个步骤将在以下讨论中详细探讨。

*1。第一步*:C #编译器会用匿名方法`person => person.PersonAge.Name`构造方法`<Main>b__1`，用匿名方法`person => person.PersonID`构造`<Main>b__2`，用匿名方法构造`<Main>b__3`，如下所示。

`(Age, Id) =>
new
{
    PersonAge = Age,
    PersonID = Id
}`

CLR 将使用`<Main>b__1`、`<Main>b__2`和`<Main>b__3`方法实例化`MulticastDelegate`对象的三个实例，并将其作为`keySelector,` `elementSelector`和`GroupBy`方法的`resultSelector`的输入传递给`GroupedEnumerable`类:

`public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(
    this IEnumerable<TSource> source,` `    Func<TSource, TKey> keySelector,
    Func<TSource, TElement> elementSelector,
    Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
{
    return new GroupedEnumerable<TSource, TKey, TElement, TResult>(
        source,
        keySelector,
        elementSelector,
        resultSelector, null);
}`

*2。第二步*:CLR 在构造函数中实例化`GroupedEnumerable`类的同时，会初始化 source(原始序列)、`keySelector`、`elementSelector`和`resultSelector`等相关数据结构，并保存来自构造函数输入的`keySelector`、`elementSelector`和`resultSelector`。

*3。第 3 步*:由于`GroupBy`方法遵循延迟执行模式，CLR 调用`ToList`方法，该方法将通过调用第 1 步中实例化的`GroupedEnumerable`类中的`GetEnumerator`来使用枚举器初始化一个新列表。`GetEnumerator`的实施方法是:

`public IEnumerator<TResult> GetEnumerator()
{
**/* source**              **- refers the Original sequence**
 *** keySelector**         **- refers The Key selector**
 *** elementSelector**     **- refers The Element selector**
 *** comparer**            **- refers The comparer**
 *** ApplyResultSelector - apply the result selector to extract the result */**
    return Lookup<TKey, TElement>.Create<TSource>(
        this.source,                     
        this.keySelector,             
        this.elementSelector,      
        this.comparer).               
        **/* Apply the result selector to extract the result */**
        ApplyResultSelector<TResult>(this.resultSelector).GetEnumerator();
}`

`GetEnumerator`方法表明在执行`Create`和`ApplyResultSelector`后，`Lookup`类将保存分组结果。

*4。步骤 4* :在内部，`Lookup`类的`Create`方法将实例化`Lookup`类的一个实例，该实例将初始化一个类型为`Grouping`的数据结构`groupings`(默认大小为 7 的数组)，如`Lookup`类构造函数的部分代码所示:

`private Lookup(IEqualityComparer<TKey> comparer)
{
   **/* Code removed */**
   this.groupings = new Grouping<TKey, TElement>[7];
}` 

这个`groupings`数组最初会保存指定类型的默认值。然后 CLR 遍历原始列表。基于`KeySelector`和`ElementSelector`，它将从原始列表中提取数据，并将这些迭代的项添加到`groupings`数组中:

`foreach (TSource local in source)
{
    lookup.GetGrouping(keySelector(local), true).Add(elementSelector(local));
}`

在返回`Create`方法时，CLR 将返回保存原始序列的`Lookup`表的`Lookup`类的实例。在`Lookup`类中`Create`方法的代码实现是:

`internal static Lookup<TKey, TElement> Create<TSource>(     IEnumerable<TSource> source,
    Func<TSource, TKey> keySelector,
    Func<TSource, TElement> elementSelector,
    IEqualityComparer<TKey> comparer)
{
    Lookup<TKey, TElement> lookup = new Lookup<TKey, TElement>(comparer);
    foreach (TSource local in source)
    {
        lookup.GetGrouping(keySelector(local),
                           true).Add(elementSelector(local));
    }
    return lookup;
}`

#### 基于集合的方法

本节将探讨不同的基于集合的方法，如`Distinct`、`Except`、`Union`和`Intersect`。

##### 明显的

方法从序列中返回不同的元素。这个扩展方法的签名是:

`public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource>
                                                     source)
public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource>
                                   source, IEqualityComparer<TSource> comparer)`

这些扩展方法使用默认的相等比较器来比较值。第一种方法从序列中返回不同的元素，第二种方法通过使用指定的`IEqualityComparer<T>`来比较值，从序列中返回不同的元素。

`Distinct`扩展方法从列表中返回相同的项目，例如清单 12-23 中的[程序从序列`{1,1,1,2,2,2,3,3,3}`中确定`Distinct`项目。](#list_12_23)

***清单 12-23。**独特方法的例子*

`using System;
using System.Collections;` `using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> numbers = new List<int>()
            {
                1,1,1,2,2,2,3,3,3
            };

            var distinctedNumbers = numbers.Distinct().ToList();
            distinctedNumbers.ForEach(x => Console.Write(string.Format("{0}\t", x)));
        }
    }
}`

该程序将产生以下输出:

`1       2       3`

不同执行方法的内部操作

让我们分析[清单 12-23](#list_12_23) 来帮助我们理解当 CLR 执行`Distinct`方法时发生了什么。[图 12-9](#fig_12_09) 展示了 Linq 中`Distinct`方法的细节。

![images](img/-09.jpg)

***图 12-9。**截然不同的方法工作细节*

图 12-9 中的每一步都将在下面的讨论中详细探讨。

*1。步骤 1*:CLR 将原始列表作为输入传递给`Distinct`方法，该方法稍后将通过封装原始列表来实例化`DistinctIterator`的实例。

*2。步骤 2* :从`ToList`方法中，CLR 通过传递在步骤 1 中实例化的`DistinctIterator`实例作为输入来调用`List`类。在`List`类中，它将实例化`Set<TSource>`的一个实例，该实例将用于临时序列存储，并通过`DistinctIterator`对其进行迭代，如[清单 12-24](#list_12_24) 所示。

***清单 12-24。**Distinct 方法的实现代码*

`private static IEnumerable<TSource> DistinctIterator<TSource>(
    IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)` `{
    Set<TSource> iteratorVariable0 = new Set<TSource>(comparer);
    foreach (TSource iteratorVariable1 in source)
    {
        if (iteratorVariable0.Add(iteratorVariable1))
        {
           **/* Only execute this line when able to add item in the Set */**
            yield return iteratorVariable1;
        }
    }
}`

当 CLR 遍历原始列表时，它会在之前创建的`Set<TSource>`实例中添加迭代项。在内部，`Set<TSource>`类使用`Add`和`Find`方法，只有在`slots`数组中没有重复的项目时，才会将来自给定序列的项目添加到内部数组槽中。

`slots`是一个`Slot`类型的数组，它是在`System.Core.dll`程序集的`System.Linq`命名空间中定义的。以下代码是通过`ildasm.exe`提取的:

`.class sequential ansi sealed nested assembly beforefieldinit
    Slot<TElement>
    extends [mscorlib]System.ValueType
{
    .field assembly int32 hashCode
    .field assembly int32 next
    **/* This field will hold the value */**
    .field assembly !TElement value
}`

当在`Set`中有一个重复的项目时，`Add`方法不会将该项目添加到`slots`中，它将继续，直到 CLR 到达列表迭代的末尾，并产生一个具有不同项目的列表。

##### 除...之外

`Except`扩展方法用于从一个项目列表中移除另一个项目列表。它产生两个序列的集合差。例如，如果你有一个物品列表`{1,2,3,4,5,6,7}`和一个带有`{1,2,3}`的物品列表，这两个列表的`Except`将产生`{4,5,6,7}`。

这个扩展方法的签名是:

`public static IEnumerable<TSource> Except<TSource>(
    this IEnumerable<TSource> first, IEnumerable<TSource> second)
public static IEnumerable<TSource> Except<TSource>(
    this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)`

这两个扩展方法将使用默认的相等比较器来比较值。第一个版本产生两个序列的集合差，第二个版本通过使用指定的`IEqualityComparer<T>`比较值产生两个序列的集合差。

清单 12-25 中的程序演示了`Except`方法的使用。

***清单 12-25。**Except 方法的例子*

`using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> firstNumbers = new List<int>()
            {
                1,2,3,4,5,6,7
            };
            IList<int> secondNumbers = new List<int>()
            {
                1,2,3
            };

            var result = firstNumbers.Except(secondNumbers).ToList();
            result.ForEach(x => Console.Write(string.Format("{0}\t",x)));
        }
    }
}`

清单 12-25 中的程序将产生输出:

`4       5       6       7`

Except 执行方法的内部操作

让我们分析一下[清单 12-25](#list_12_25) 来帮助我们理解执行`Except`方法时发生了什么。[图 12-10](#fig_12_10) 展示了`Except`方法的内部细节。

![images](img/-10.jpg)

***图 12-10。**除法工作细节*

图 12-10 中的每个步骤将在以下讨论中详细探讨。

*1。步骤 1*:CLR 将原始列表传递给`Except`方法，该方法将通过将原始列表封装在迭代器内部来在内部实例化`ExceptIterator<TSource>`。由于延迟执行，这个迭代器不会执行，直到它调用应用于迭代器对象的`ToList`方法或`ForEach`方法。

*2。步骤 2* :当 CLR 执行`ToList`方法时，它通过将步骤 1 中创建的`ExceptIterator`实例作为输入来调用`List`类。`List`类在遍历列表时调用`ExceptIterator`方法。

`ExceptIterator`方法创建了一个`Set<TSource>`的新实例，并添加了第二个列表中的所有条目，如[清单 12-26](#list_12_26) 所示。

***清单 12-26。**异常程序的实现代码*

`private static IEnumerable<TSource> ExceptIterator<TSource>(
    IEnumerable<TSource> first,
    IEnumerable<TSource> second,
    IEqualityComparer<TSource> comparer)
{
    Set<TSource> iteratorVariable0 = new Set<TSource>(comparer);
    foreach (TSource local in second)
        iteratorVariable0.Add(local);
    foreach (TSource iteratorVariable1 in first)
    {
        **if (!iteratorVariable0.Add(iteratorVariable1))**
            continue;
        **yield return iteratorVariable1;**
    }
}`

在第二个循环中，CLR 遍历第一个列表，并尝试在集合中添加迭代的项。如果第二个列表中的项目在集合中不存在(`!iteratorVariable0.Add(iteratorVariable1))`)，那么它将返回该项目并继续，直到它完成第一个列表。

##### 联盟

`Union`方法(表示为`∪`)在两个序列中设置并集。`Union`方法从输出序列中排除重复项。例如，如果你有两个集合，`A = {1,2,3,4,5,6,7}`和`B = {5,6,7,8,9},`，这两个集合的并集是`A ∪ B = {1,2,3,4,5,6,7,8,9}`，如图 12-11 中的[所示。](#fig_12_11)

![images](img/-11.jpg)

***图 12-11。**联合作战*

`Union`方法的签名是:

`public static IEnumerable<TSource> Union<TSource>(
    this IEnumerable<TSource> first, IEnumerable<TSource> second)` `public static IEnumerable<TSource> Union<TSource>(
    this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)`

清单 12.27 中的程序演示了`Union`操作的用法。

***清单 12-27。**使用联合方法的联合操作示例*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> firstList = new List<int>()
            {
                1,2,3,4
            };

            IList<int> secondList = new List<int>()
            {
               7,9,3,4,5,6,7
            };

            var result = firstList.Union(secondList);
            result.ToList().ForEach(x =>
                            Console.Write(string.Format("{0}\t",x)));
        }
    }
}`

清单 12-27 中的程序将产生输出:

`1       2       3       4       7       9       5       6`

Union 执行方法的内部操作

为了执行`Union`方法，CLR 将遵循以下步骤:

*1。第 1 步*:`Union`方法返回`UnionIterator<TSource>`，它保存了`firstList`和`secondList`，对于`IEqualityComparer`为空，因为[清单 12-27](#list_12_27) 中的程序没有使用比较器来比较项目。

*2。步骤 2* :由于延迟执行，当 CLR 开始执行`ToList`方法时，`UnionIterator<TSource>`将被执行。在`UnionIterator<TSource>`中，`Set<TSource>`类的一个新实例被实例化，它将被用来从两个列表中查找不同的条目，如清单 12-28 中的[所示。](#list_12_28)

***清单 12-28。**union iterator 的实现代码*

`private static IEnumerable<TSource> UnionIterator<TSource>(
    IEnumerable<TSource> first,
    IEnumerable<TSource> second,
    IEqualityComparer<TSource> comparer)
{
    Set<TSource> iteratorVariable0 = new Set<TSource>(comparer);

    foreach (TSource iteratorVariable1 in first)
    {
        **/* If the CLR able to add the iterated item from the first List**
         *** in the Set it will yield that iterated item and keep continue**
         *** the loop. This will make sure only the identical items from the**
         *** first list is being returned.*/**
        if (iteratorVariable0.Add(iteratorVariable1))
            yield return iteratorVariable1;
    }
    foreach (TSource iteratorVariable2 in second)
    {
        **/* If the CLR not able to add iterated item from the second list**
         *** (to make sure  there is no duplicate between first list and second**
         *** list) it will continue the loop until able to add the iterated**
         *** item from the second list into the Set. If so then that item will**
         *** be returned and it will continue the iteration until finish**
         *** the Second List.*/**
        if (!iteratorVariable0.Add(iteratorVariable2))
            continue;
        yield return iteratorVariable2;
    }
}`

##### 横断

`Intersect`扩展方法产生两个序列的交集。例如，如果你有一个带有项目`{1,2,3,4,5}`的列表`A`和一个带有`{4,5}`的列表`B`，这两个列表`A`和 B 的交集就是`{4,5}`，如图[图 12-12](#fig_12_12) 所示。

![images](img/-12.jpg)

***图 12-12。**相交操作*

此扩展方法的方法签名是:

`public static IEnumerable<TSource> Intersect<TSource>(
    this IEnumerable<TSource> first, IEnumerable<TSource> second)
public static IEnumerable<TSource> Intersect<TSource>(
    this IEnumerable<TSource> first, IEnumerable<TSource> second,IEqualityComparer<TSource> comparer)`

这个扩展方法通过使用默认的相等比较器比较值来产生两个序列的集合交集，并且它将通过使用指定的`IEqualityComparer<T>`比较值来产生两个序列的集合交集。

[清单 12-29](#list_12_29) 中的程序创建了两个列表:`listA`带`1,2,3,4,5`和`listB`带`4,5`。它显示了这两个列表之间的交集操作。

***清单 12-29。**相交方法的例子*

`using System;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> listA = new List<int>() { 1, 2, 3, 4, 5 };
            IList<int> listB = new List<int>() { 4, 5 };

            var intersectResult = listA.Intersect(listB);

            intersectResult.ToList().ForEach(x => Console.Write("{0}\t",x));
        }
    }
}`

该程序产生了以下输出:

`4       5`

Intersect 执行方法的内部操作

在执行`Intersect`方法时，CLR 遵循以下步骤:

*1。步骤 1*:CLR 用原始列表初始化`IntersectIterator<TSource>`，并将`IntersectIterator<TSource>`的实例返回给调用者。由于延迟执行，这个迭代器在调用`ToList`方法之前不会执行。

*2。步骤 2* :当执行`IntersectIterator<TSource>`时，CLR 实例化一个用于保存第二个列表的`Set<TSource>`的实例，在[清单 12-30](#list_12_30) 中展示了`IntersectIterator`的实现。

***清单 12-30。**interseciterator 方法的实现代码*

`private static IEnumerable<TSource> IntersectIterator<TSource>(
    IEnumerable<TSource> first,
    IEnumerable<TSource> second,
    IEqualityComparer<TSource> comparer)
{
    Set<TSource> iteratorVariable0 = new Set<TSource>(comparer);

    **/* The CLR will add all the items from the second list to the Set.*/**
    foreach (TSource local in second)
        iteratorVariable0.Add(local);

    **/* Iterate though the first list */**
    foreach (TSource iteratorVariable1 in first)
    {
    **/* If the CLR able to remove based on the iterated item from the first**
     *** list i.e. there is a same item in the second list and that will**
     *** return otherwise continue the operation.*/**
        if (!iteratorVariable0.Remove(iteratorVariable1))
            continue;

        yield return iteratorVariable1;
    }
}`

然后，CLR 将遍历第一个列表，并尝试从保存第二个列表的条目的`Set<TSource>`中移除第一个列表的每个条目，如前所述。如果可以移除，它将返回第一个列表中的项目，否则它将继续遍历第一个列表，直到完成第一个列表。

#### 基于聚合的方法

本节将详细探讨不同的基于聚合的方法，如`Sum`、`LongCount`、`Max`、`Min`、`Count`、`Average`和`Aggregate`。

##### 总额

要对列表中的项目进行求和操作，可以使用`Sum`方法。`Sum`方法有 20 个重载方法，其中 10 个是 instance 和 rest 静态方法。`Sum`的签名方法是:

`public static int Sum( this IEnumerable<int> source)
public static int Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)`

清单 12-31 中的[给出了一个`Sum`扩展方法的例子。](#list_12_31)

***清单 12-31。**求和法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;` `namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> numbers = new List<int>()
            {
                1,2,3,4,5,6,7,8,9,10
            };

            Console.WriteLine("Sum of the numbers :{0}", numbers.Sum());

            Console.WriteLine("Sum of the original numbers x 2 :{0}",
                numbers.Sum(x => x * 2));
        }
    }
}`

该程序产生以下输出:

`Sum of the numbers :55
Sum of the original numbers x 2 :110`

执行总和法的内部运算

为了执行清单 12-31 中使用的第一个重载的`Sum`扩展方法，CLR 遵循以下步骤:

*1。步骤 1*:CLR 将原始列表作为输入传递给`Sum`扩展方法。

*2。步骤 2*:`Sum`方法遍历列表，对每一项进行求和，并产生结果，如下面的实现代码所示:

`public static int Sum(this IEnumerable<int> source)
{
    int num = 0;
    foreach (int num2 in source)
        num += num2;
    return num;
}`

让我们分析[清单 12-31](#list_12_31) 来帮助我们理解当 CLR 执行第二个重载`Sum`扩展方法时发生了什么。[图 12-13](#fig_12_13) 展示了`Sum`方法的细节。

![images](img/-13.jpg)

***图 12-13。**总和法的工作原理*

图 12-13 中的每个步骤将在以下讨论中详细探讨。

*1。步骤 1*:C #编译器为匿名方法块`(x => x * 2)`构造方法`<Main>b__1`，如以下 IL 代码所示:

`.method private hidebysig static int32 <Main>b__1(int32 x) cil managed
{
    **/* Code removed  */**
    L_0000: ldarg.0
    L_0001: ldc.i4.2
    **/* Multiply the argument at position 0 of the evaluation stack by 2*/**
    L_0002: mul
    L_0003: stloc.0
    L_0004: br.s L_0006
    L_0006: ldloc.0
    L_0007: ret
}`

CLR 使用方法`<Main>b__1`创建一个`MulticastDelegate`实例，如下面的 IL 代码所示，这些代码是从清单 12-31 中的[程序的反编译`Main`方法中提取的。网络反射器工具:](#list_12_31)

`L_007f: ldftn
        int32
        Ch12.Program::<Main>b__1(int32)
L_0085: newobj instance
        void
        [mscorlib]System.Func'2<int32, int32>::.ctor(object, native int)`

![images](img/.jpg) **注:**`System.Func<TSource,TResult>`由`MulticastDelegate`衍生而来。

*2。第 2 步*:CLR 将第 1 步中创建的原始列表和`MulticastDelegate`实例作为输入传递给`Sum`方法，后者以原始列表和`MulticastDelegate`实例作为输入调用`Select`方法。CLR 实例化来自`Select`方法的相关迭代器，例如、`WhereSelectListIterator<TSource, TResult>`，并将其返回给`Sum`方法，例如`WhereSelectListIterator<TSource, TResult>`。然后 CLR 调用重载的`Sum`方法。这个重载`Sum`的实现应该是:

`public static float Sum(
    this IEnumerable<float> source)
{
    double num = 0.0;
    foreach (float num2 in source)
        num += num2;
    return (float) num;
}`

*3。步骤 3*:CLR 从传递给`Sum`方法的`IEnumerable`对象中获取迭代器，例如`WhereSelectListIterator`的实例，如下面反编译的`Sum`方法代码所示:

`.method public hidebysig static int32 Sum(
    class [mscorlib]System.Collections.Generic.IEnumerable'1<int32> source)
    cil managed
{
    **/* Code removed   */**
    **/* Load the argument which is the IEnumerable passed one evaluation**
     *** stack from the caller */**
    L_0010: ldarg.0

    L_0011: callvirt instance
            **/* return type of the GetEnumerator method */**
            class [mscorlib]System.Collections.Generic.IEnumerator'1<!0>
            [mscorlib]System.Collections.Generic.IEnumerable'1<int32>::
            GetEnumerator()
    **/* Code removed  */**
}`

*4。步骤 4* :使用这个`Enumerator`，CLR 遍历原始列表中的条目。当 CLR 执行迭代器时，它通过从相关的枚举器调用`MoveNext`方法来遍历每个项目，并执行作为输入传递给它的相关选择器方法。下面的匿名方法用于在从原始列表中检索该项时，以及在提交该项的总和之前修改该项:

`( x => x * 2 )  **/* compiled as <Main>b__1 used in the MoveNext method**
                 *** as Selector*/**`

`WhereSelectListIterator<TSource, TResult>`类的 MoveNext 方法的实现是:

`public override bool MoveNext()
{
    while (this.enumerator.MoveNext())
    {
        TSource current = this.enumerator.Current;
        if ((this.predicate == null) || this.predicate(current))
        {
            **/* selector(current) will actually execute as**` `             *** <Main>b__1(current) */**
            base.current = this.selector(current);
            return true;
        }
    }
    return false;
}`

从那里您会发现,`this.selector(current)`语句为原始列表中的当前项目执行选择器，并且继续执行，直到它完成了原始列表的迭代。

##### 长计数

`LongCount`方法可用于返回一个表示序列中元素数量的`Int64`。此扩展方法的方法签名是:

`public static long LongCount<TSource>(this IEnumerable<TSource> source)
public static long LongCount<TSource>(this IEnumerable<TSource> source,
                                      Func<TSource, bool> predicate)`

这个扩展方法将返回一个表示序列中元素总数的`Int64`,它将返回一个表示序列中有多少元素满足条件的`Int64`。

清单 12-32 给出了一个`LongCount`方法的例子。

***清单 12-32。**long count 方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> firstList = new List<int>()
            {
                1,2,3,4
            };

            Console.WriteLine(firstList.LongCount());
        }
    }
}`

该程序将产生以下输出:

`4`

执行 LongCount 方法的内部操作

第一个版本的`LongCount`方法的实现显示，CLR 将遍历原始列表，对每个条目求和，并将结果存储在`num`变量中:

`public static long LongCount<TSource>(this IEnumerable<TSource> source) {
    long num = 0L;
    using (IEnumerator<TSource> enumerator = source.GetEnumerator())
    {
        while (enumerator.MoveNext())
        {
            num += 1L;
        }
    }
    return num;
}`

`LongCount`扩展方法的第二个版本的实现显示，CLR 遍历原始列表，并根据提供的谓词从列表中选择项目(它将返回那些满足条件的项目),然后将其汇总并存储在`num`变量中:

`public static long LongCount<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate) {
    long num = 0L;
    foreach (TSource local in source)
    {
        if (predicate(local))
            num += 1L;
    }
    return num;
}`

##### 最大

`Max`扩展方法用于确定列表中的最大数量。`Max`方法的签名有 22 个重载方法，其中两个是:

`public static int Max(this IEnumerable<int> source)
public static decimal Max<TSource>(this IEnumerable<TSource> source,
                                   Func<TSource, decimal> selector)`

清单 12-33 给出了一个`Max`方法的例子。

***清单 12-33。**最大值法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12` `{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> numbers = new List<int>()
            {
                1,2,3,4,5,6,7,8,9,10
            };

            Console.WriteLine("Max of the numbers :{0}", numbers.Max());
            Console.WriteLine("Max of the original numbers x2 :{0}",
                numbers.Max(x => x * 2));
        }
    }
}`

该程序产生以下输出:

`Max of the numbers :10
Max of the original numbers x2 :20`

Max 执行方法的内部操作

CLR 执行以下步骤来执行`Max`操作:

*1。步骤 1*:CLR 将原始列表作为输入传递给`Max`方法。

*2。步骤 2*:`Max`方法循环遍历列表并执行`Max`操作，如这里的`Max`实现所示:

`public static int Max(
    this IEnumerable<int> source)
{
    int num = 0;
    bool flag = false;
    foreach (int num2 in source)
    {
        if (flag)
        {
            if (num2 > num)
                num = num2;
        }
        else
        {
            num = num2;
            flag = true;
        }
    }
    return num;
}`

`Max`扩展方法的第二个重载方法如图 12-14 所示。

![images](img/-14.jpg)

***图 12-14。**Max 方法的工作原理*

CLR 在执行`Max`方法时遵循以下步骤:

*1。步骤 1*:C #编译器使用匿名方法(`x => x * 2`)构造一个方法`<Main>b__1`。CLR 将这个`<Main>b__1`方法传递给`MulticastDelegate`类来实例化它的一个实例，并调用 list 的`Select`方法，该方法将原始 list 和`MulticastDelegate`的实例作为输入，并将 list 的相关迭代器实例(例如`WhereSelectListIterator<TSource,TResult>`)作为输出返回。

*2。步骤 2*:CLR 然后调用重载`Max`方法，该方法只接受从步骤 1 返回的迭代器。在这个重载`Max`方法中，一个`ForEach`方法被强制遍历列表，并根据`Selector`条件执行`Max`操作。

##### 福建话

`Min`扩展方法将决定列表的最小值。扩展方法`Min`(22 个重载方法中的)的两个签名是:

`public static int Min(this IEnumerable<int> source) public static int Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)`

清单 12-34 中的程序演示了`Min`扩展方法的用法。

***清单 12-34。**最小法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {` `            IList<int> numbers = new List<int>()
            {
                1,2,3,4,5,6,7,8,9,10
            };

            Console.WriteLine("Min of the numbers :{0}", numbers.Min());

            Console.WriteLine("Min of the original numbers x2 :{0}",
                numbers.Min(x => x * 2));
        }
    }
}`

该程序将产生以下输出:

`Min of the numbers :1
Min of the original numbers ×2 :2`

Min 执行方法的内部操作

当 CLR 找到第一个版本的`Min`扩展方法时，如[清单 12-34](#list_12_34) 所示，它按照步骤执行操作。CLR 将原始列表作为输入传递给`Min`扩展方法。然后，`Min`方法遍历列表并执行最小计算操作。

`Min`扩展方法的第二个版本在[图 12-15](#fig_12_15) 中演示。

![images](img/-15.jpg)

***图 12-15。**敏法工作细节*

CLR 遵循以下步骤:

*1。步骤 1*:C #编译器使用匿名方法(`x => x * 2`)构造了一个方法`<Main>b__1`，并将这个`<Main>b__1`方法传递给`MulticastDelegate`类来实例化它的一个实例。然后，它将调用`Select`方法，将原始列表和`MulticastDelegate`的实例作为输入，返回列表的相关迭代器实例，例如`WhereSelectListIterator<TSource,TResult>`，作为输出。

*2。步骤 2*:CLR 将调用重载的`Min`方法，该方法只接受步骤 1 中返回的迭代器。在这个重载`Min`方法中，`ForEach`方法使用提供的`Selector`强制它迭代列表，并执行`Min`操作。

##### 计数

`Count`方法返回序列中元素的数量。此方法的方法签名是:

`public static int Count<TSource>(this IEnumerable<TSource> source)
public static int Count<TSource>(this IEnumerable<TSource> source,
                                 Func<TSource, bool> predicate)`

第一个版本返回序列中元素的数量。第二个版本返回一个数字，表示指定序列中满足条件的元素的数量。

方法确定列表中有多少项。例如，清单 12-35 中的[程序决定了`listOne`中有多少项，也决定了`listOne`中有多少项具有三个以上的字符。](#list_12_35)

***清单 12-35。**计数方法示例*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<string> listOne = new List<string>()
            {
                "One","Two","Three"
            };

            var result = listOne.Count();

            var fourOrMoreCharacters = listOne.Count(item => item.Length > 3);
            Console.WriteLine("{0}\n{1}", result,fourOrMoreCharacters);
        }
    }
}`

清单 12-35 中的程序将产生输出:

`3
1`

执行计数方法的内部操作

让我们分析一下[清单 12-35](#list_12_35) 中的代码，帮助我们理解当我们使用`Count`方法时发生了什么。

当 CLR 找到`Count`方法的第一个重载实例时，它会尝试确定给定列表的枚举器，并遍历项目(使用列表的迭代器)，除非枚举器的`MoveNext`方法返回 false。

在使用`Count`方法时，[清单 12-36](#list_12_36) 中显示的`Count`方法的实现返回迭代次数作为列表的输出。

***清单 12-36。**计数方法示例*

`public static int Count<TSource>(this IEnumerable<TSource> source)
{
    int num = 0;
    using (IEnumerator<TSource> enumerator = source.GetEnumerator())
    {
        while (enumerator.MoveNext())
        {
          **/* num will be increased as per the iteration of the while*/**
           num++;
      }
    }
    return num;
}`

[图 12-16](#fig_12_16) 展示了`Count`方法的第二个版本。

![images](img/-16.jpg)

***图 12-16。**计数法工作细节*

第二个版本的`Count`方法将使用原始列表和一个谓词来过滤列表中的项目，并根据过滤的项目进行计数。谓词将在编译时基于所提供的匿名方法创建(`item => item.Length > 3`)。CLR 循环遍历列表中的各项，并对每一项执行谓词。如果谓词在迭代中满足项目的条件，它将增加项目计数。

最后，它返回项目计数，作为满足条件的项目总数。`Count`方法的实现是:

`public static int Count<TSource>(     this IEnumerable<TSource> source,
    Func<TSource, bool> predicate)
{
    foreach (TSource local in source)
        if (predicate(local))
            num++;
    return num;
}`

##### 平均值

`Average`方法计算一系列数值的平均值。此扩展方法的两个签名(总共 11 个重载方法)是:

`public static double Average(this IEnumerable<int> source)
public static decimal Average<TSource>(
    this IEnumerable<TSource> source, Func<TSource, decimal> selector)`

清单 12-37 给出了一个`Average`方法的例子。

***清单 12-37。**平均法示例*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> numbers = new List<int>()
            {
                1,2,3,4,5,6,7,8,9,10
            };
            Console.WriteLine("Average of the numbers :{0}",
                numbers.Average());

            Console.WriteLine("Average of the original numbers x2 :{0}",
                numbers.Average((x => x * 2)));
        }
    }
}`

该程序产生以下输出:

`Average of the numbers :5.5
Average of the original numbers :11`

平均执行法的内部运算

[清单 12-37](#list_12_37) 显示 CLR 将列表`numbers`作为输入传递给`Average`方法。该方法通过遍历原始列表来处理它，并计算`numbers`的项目的平均值，并将项目的平均值作为输出返回。CLR 使用以下步骤执行第一个版本的`Average`方法:

*1 步骤 1*:CLR 传递原始列表，例如`numbers`为[列表 12-37](#list_12_37) ，作为`Average`方法的输入。

2*。第 2 步*:`Average`方法遍历列表并执行平均。`Average`方法的实现如[清单 12-38](#list_12_38) 所示。

***清单 12-38。**平均法的内部运算*

`public static double Average(this IEnumerable<int> source)
{
    long num = 0L;
    long num2 = 0L;
    foreach (int num3 in source)
    {
    num += num3;
    num2 += 1L;
    }

   **/* total of the numbers / to no of items in list */**
    return (((double) num) / ((double) num2));
}`

`Average`扩展方法的第二个版本遵循图 12-17 中[概述的步骤来执行操作。](#fig_12_17)

![images](img/-17.jpg)

***图 12-17。**平均延伸法工作细节*

[图 12-17](#fig_12_17) 显示 CLR 将列表`numbers`连同编译时使用匿名方法`(x=>x*2)`实例化的`MulticastDelegate`类的实例一起传递给了`Average`方法。CLR 将把这个`MulticastDelegate`的实例传递给`Select`方法，适当的迭代器将从该方法实例化。对于[清单 12-37](#list_12_37) 中的程序，`WhereSelectListIterator<int,int>`迭代器将被实例化，它将保存原始列表和选择器。CLR 将遍历列表，并根据选择器中提供的筛选条件计算平均值。

让我们分析清单 12-37 中的[来理解当 CLR 执行第二个版本的`Average`方法时会发生什么。](#list_12_37)

*1。步骤 1*:CLR 使用`<Main>b__1`方法将原始列表和`MulticastDelegate`的实例(由 C#编译器使用`Anonymous`方法(`x=>x*2`)在编译时生成)作为输入传递给`Average`方法。

*2。步骤 2* :在执行`Average`方法时，CLR 调用`Select`方法，该方法实例化从`Select`方法返回的`WhereSelectListIterator<int, int>`迭代器。

*3。步骤 3*:CLR 然后通过传递步骤 2 中实例化的`WhereSelectListIterator<int, int>`作为输入来调用重载的`Average`方法。这个迭代器包含原始列表和作为选择器的`MulticastDelegate`的实例。

*4。步骤 4* :在`Average`方法中，`ForEach`方法遍历列表并执行平均值计算，如`foreach`块的实现代码所示，并执行平均值计算:

`foreach (int num3 in source)
{
   num += num3;
   num2 += 1L;
}`

##### 总计

`Aggregate`方法组合了序列中的一系列项目，例如，如果你有一个包含一、二、三、四的序列，并对该序列应用`Aggregate`方法，CLR 然后执行如图[图 12-18](#fig_12_18) 所示的操作。

![images](img/-18.jpg)

***图 12-18。**聚合操作基础*

这种方法的特征是:

`public static TSource Aggregate<TSource>(
     this IEnumerable<TSource> source, Func<TSource, TSource, TSource> func)
public static TAccumulate Aggregate<TSource, TAccumulate>(
     this IEnumerable<TSource> source,
     TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func)
public static TResult Aggregate<TSource, TAccumulate, TResult>(
     this IEnumerable<TSource> source, TAccumulate seed,
     Func<TAccumulate, TSource, TAccumulate> func, Func<TAccumulate, TResult> resultSelector)`

清单 12-39 展示了一个`Aggregate`方法的例子。

***清单 12-39。**汇总方法示例*

`using System;
using System.Collections.Generic;
using System.Linq;` `namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {

            List<string> numbers = new List<string>()
            {
                "One", "Two", "Three", "Four"
            };

            var result = numbers.Aggregate(
                (aggregatedValue, nextItem) =>
                nextItem + aggregatedValue);

            Console.WriteLine("Aggregated value : {0}", result);
        }
    }
}`

该程序产生以下输出:

`Aggregated value : FourThreeTwoOne`

由于`nextItem + aggregatedValue`的原因，输出与原列表不同。换句话说，输出将如下所示:

`Aggregated value : OneTwoThreeFour`

聚合执行方法的内部操作

[图 12-19](#fig_12_19) 展示了`Aggregate`方法的内部操作。

![images](img/-19.jpg)

***图 12-19。**聚合方法的工作原理*

让我们分析[清单 12-39](#list_12_39) 中的代码，以理解当我们启动`Aggregate`方法时发生了什么。

*1。第一步*:C #编译器创建`<Main>b__1`方法，将匿名方法体`(aggregatedValue, nextItem) => nextItem + aggregatedValue)`封装为`<Main>b__1`，作为`Aggregate`方法的`Aggregator` `func`。CLR 使用这个匿名方法来执行`Aggregate`。编译后的`<Main>b__1`方法的内容应该是:

`.method private hidebysig static string <Main>b__1
    (string aggregatedValue, string nextItem) cil managed
{
    /* Code removed  */
    L_0000: ldarg.1
    L_0001: ldarg.0
    L_0002: call string [mscorlib]System.String::Concat(string, string)
    L_0007: stloc.0
    L_0008: br.s L_000a
    L_000a: ldloc.0
    L_000b: ret
}`

*2。步骤 2* :当 CLR 执行`Aggregate`函数时，它将步骤 1 中创建的原始列表和匿名方法作为输入。它遍历列表中的每一项，并将列表中的第一项用作当前的聚合值:

`TSource current = enumerator.Current;`

列表中的第二项(使用`enumerator.Current`)被用作匿名方法的输入(即聚合器生成新的聚合值)。这个新值将被用作下一次迭代的新聚合值，并继续迭代，直到完成列表。在[清单 12-39](#list_12_39) 中使用的`Aggregate`方法的实现在[清单 12-40](#list_12_40) 中显示。

***清单 12-40。**聚合方法的实现代码*

`public static TSource Aggregate<TSource>(
    this IEnumerable<TSource> source,
    Func<TSource, TSource, TSource> func)
{
    using (IEnumerator<TSource> enumerator = source.GetEnumerator())
    {
        **/* current as the initial seed */**
        TSource current = enumerator.Current;
        **/* enumerator will move forward and start looping from the**
         *** second item */**
        while (enumerator.MoveNext())
        **/* seed and iterated item will be passed to the Aggregator which**
         *** is func to generate new seed. */**
            current = func(current, enumerator.Current);

        return current;
    }
}`

下面的讨论将探索`Aggregate`的重载方法，它将一个值作为初始聚合值的输入。因此，CLR 不会像前面讨论的第一个版本的`Aggregate`方法那样，将列表中的第一项作为初始聚合值。[清单 12-41](#list_12_41) 展示了使用`Aggregate`方法，该方法接受一个聚合值作为输入。

***清单 12-41。**修改版[清单 12-39](#list_12_39)T5】*

`using System;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            List<string> items = new List<string>()
            {
                "One", "Two", "Three", "Four"
            };
            var result = items.Aggregate(
                   **/* Zero as seed, to use as the initial aggregate value */**
                    "Zero",
                    (temporaryAggregatedValue, nextItem) =>
                    {
                        Console.WriteLine(temporaryAggregatedValue);
                        return nextItem + temporaryAggregatedValue;
                    },
                    aggregatedResult =>
                    string.Format("Final result : {0}",
                                  aggregatedResult.ToUpper())
                );
            Console.WriteLine(result);
        }
    }
}`

该程序将产生以下输出:

`Zero
OneZero
TwoOneZero
ThreeTwoOneZero
Final result : FOURTHREETWOONEZERO`

`Aggregate`方法使用基于初始种子和迭代项的`Aggregator`方法生成种子。最终结果将以特定的格式产生，例如对于[清单 12-41](#list_12_41) 中的代码，聚合方法的匿名方法`<Main>b__2`格式产生最终结果，如图[图 12-20](#fig_12_20) 所示。

![images](img/-20.jpg)

***图 12-20。**汇总方法的工作原理*

CLR 会将初始的聚合值作为输入，并将原始列表的第一项(第一次)传递给`<Main>b__1`来创建聚合值，如[清单 12-41](#list_12_41) 所示。执行初始聚合操作后，`<Main>b__1`将返回新的聚合值。在第一次遍历列表后，CLR 将使用使用`<Main>b__1`创建的新值替换旧的聚合值，并继续迭代，直到完成对原始列表的迭代。`Aggregate`方法的实现如[清单 12-42](#list_12_42) 所示。

***清单 12-42。**聚合方法的实现代码*

`public static TAccumulate Aggregate<TSource, TAccumulate>(
    this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func)
{
    TAccumulate local = seed;
    foreach (TSource local2 in source)
        local = func(local, local2);
    return local;
}`

使用初始种子生成的聚合种子为:

`(temporaryAggregatedValue, nextItem) =>
{
    Console.WriteLine(temporaryAggregatedValue);
    return nextItem + temporaryAggregatedValue;
}`

这段代码被编译成`<Main>b__1`:

`.method private hidebysig static string <Main>b__1(
    string temporaryAggregatedValue, string nextItem) cil managed
{
    **/* Code removed  */**
    L_000a: call string [mscorlib]System.String::Concat(string, string)
    L_000f: stloc.0
    L_0013: ret
}`

结果选择器方法`aggregatedResult =>string.Format("Final result : {0}", aggregatedResult.ToUpper())`被编译为:

` .method private hidebysig static string <Main>b__2(string aggregatedResult) cil managed
{
    **/* Code removed  */**
    L_000b: call string [mscorlib]System.String::Format(string, object)
    L_0014: ret
}`

#### 基于量词的方法

本节将详细探讨`All`、`Any`和`Contains`扩展方法。

##### 全部

`All`扩展方法确定一个序列的所有元素是否满足一个条件，源序列的每个元素是否通过指定谓词中的条件，或者序列是否为空并返回 true 否则为假。这个扩展方法的签名是:

`public static bool All<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)`

清单 12-43 显示了如何从序列中找到至少有三个字符的项目。

***清单 12-43。**All 方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<string> numbers = new List<string>()
            {
                "One", "Two", "Three", "Four", "Five", "Six", "Seven"
            };

            if (numbers.All<string>(x => x.Length >= 3))
                Console.WriteLine(
                        "All numbers have at least three characters.");
        }
    }
}`

清单 12-43 中的程序将产生输出:

`All numbers have at least three characters.`

执行 All 方法的内部操作

`All`方法将匹配指定的过滤条件，从序列中查找项目。[图 12-21](#fig_12_21) 展示了 Linq 中`All`方法的细节。

![images](img/-21.jpg)

***图 12-21。**所有方法的工作细节*

从[图 12-21](#fig_12_21) 中，你可以看到 CLR 将`numbers`列表作为输入传递给`All`方法，以及使用匿名方法实例化的`MulticastDelegate`类的实例(`x=>x.Length >= 3`)。在 All 方法中，CLR 处理列表以查找每个项目是否满足作为谓词提供的条件。

让我们分析一下[清单 12-43](#list_12_43) 中的代码，以理解当 CLR 对一个列表使用`All`方法时发生了什么。

*1。步骤 1*:CLR 使用方法`<Main>b__1` ( `x => x.Length >= 3`)实例化`MulticastDelegate`的实例。CLR 将原始列表和在这一步中创建的`MulticastDelegate`类的实例作为输入传递给扩展方法`All`。

*2。步骤 2*:`All`方法将遍历列表，并尝试确定序列中是否有元素不满足条件，然后返回 false，否则返回 true 值，作为操作的结果。`All`方法的实现是:

`public static bool All<TSource>(
    this IEnumerable<TSource> source,
    Func<TSource, bool> predicate)
{
    foreach (TSource local in source)
        if (!predicate(local))
            return false;
    return true;
}`

##### 任何的

`Any`方法确定序列中的任何元素是否存在或满足作为谓词提供的条件。此扩展方法的方法签名是:

`public static bool Any<TSource>(this IEnumerable<TSource> source)
public static bool Any<TSource>(this IEnumerable<TSource> source,
                                Func<TSource, bool> predicate)`

`Any`扩展方法的第一个版本将确定项目序列中是否包含任何元素。`Any`扩展方法的第二个版本将确定序列中是否有任何元素匹配谓词中提供的标准。

清单 12-44 展示了`Any`方法的使用。

***清单 12-44。**任意扩展方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<string> numbers = new List<string>()
            {
                "One", "Two", "Three", "Four", "Five", "Six", "Seven"
            };

            if (numbers.Any<string>())
                Console.WriteLine("Contains");

            if (numbers.Any<string>(x => x.Length >= 3))
                Console.WriteLine("Contains");
        }
    }
}`

该程序产生了以下输出:

`Contains
Contains`

Any 执行方法的内部操作

当 CLR 执行第一个版本的`Any`方法时，它执行以下步骤:

*1。第 1 步*:CLR 将原始序列或列表(在本例中是数字)作为输入发送给`Any<TSource>(this IEnumerable<TSource> source)`方法。

*2。步骤 2* :该方法通过从数字列表返回的`Enumerator`对象遍历列表，并在调用枚举器的`MoveNext`方法时检查枚举器是否返回真值，返回真，否则返回假(即序列中没有任何元素)。`Any`方法的实现如[清单 12-45](#list_12_45) 所示。

***清单 12-45。**任意扩展方法的例子*

`public static bool Any<TSource>(this IEnumerable<TSource> source)
{
    using (IEnumerator<TSource> enumerator = source.GetEnumerator())
    {
        if (enumerator.MoveNext())
            return true;` `    }
    return false;
}`

`Any`方法的重载版本将如图 12-22 中的[所示执行。](#fig_12_22)

![images](img/-22.jpg)

***图 12-22。**Any 语句的例子*

CLR 在执行`Any`方法时遵循以下步骤:

*1。第 1 步*:CLR 使用方法`<Main>b__1`(在编译时使用匿名方法(`x => x.Length >= 3`)构造)作为谓词，以及`Any`扩展方法的原始列表，实例化`MulticastDelegate`的实例。

*2。第 2 步*:CLR 遍历列表，使用每个条目作为谓词的输入来执行谓词。谓词在迭代列表时返回 true，否则它将继续，直到找到匹配。`Any`方法的实现如清单 12-46 中的[所示。](#list_12_46)

***清单 12-46。**任意方法的实现*

`public static bool Any<TSource>(
    this IEnumerable<TSource> source,
    Func<TSource, bool> predicate)
{
    foreach (TSource local in source)
    {
        if (predicate(local))
            return true;
    }
    return false;
}`

##### 包含

`Contains`方法确定序列中是否包含指定的元素，例如，如果序列包含`1,2,3,4`并且您使用了`Contains(4)`，那么它将返回列表中的可用性 4。该方法通过使用默认的相等比较器来确定序列是否包含指定的元素，并通过使用指定的`IEqualityComparer<T>`来确定序列是否包含指定的元素。

此扩展方法的方法签名是:

`public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value)
public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value,
    IEqualityComparer<TSource> comparer)`

[清单 12-47](#list_12_47) 演示了`Contains`方法的使用。

***清单 12-47。**列表中包含方法的例子< int > Type*

`using System;
using System.Collections;
using System.Collections.Generic;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> listOne = new List<int>()
            {
                1,2,3,4,5
            };

            var resultAsTrue = listOne.Contains(2);
            var resultAsFalse = listOne.Contains(200);
            Console.WriteLine("{0}\n{1}", resultAsTrue, resultAsFalse);
        }
    }
}`

该程序将产生以下输出:

`True
False`

Contains 执行方法的内部操作

当执行`Contains`方法时，CLR 将从列表中搜索特定的项目。这个搜索将有两个方向:如果输入是一个空值，那么它将遍历列表以匹配列表中的空值，如果列表中的一个项目为空，则返回 true 否则，它将返回 false。除了 null 值之外，CLR 还会将该值(作为输入提供用于匹配)与列表中的每一项进行比较，根据匹配情况，它将返回一个布尔答案。`Contains`方法的实现如[清单 12-48](#list_12_48) 所示。

***清单 12-48。**包含方法的实现*

`public bool Contains(T item)
{
    **/* First way of search */**
    if (item == null)
    {
        for (int j = 0; j < this._size; j++)
        {
            if (this._items[j] == null)
                return true;
        }` `        return false;
    }

   **/* Second way of search when the First does not execute */**
    EqualityComparer<T> comparer = EqualityComparer<T>.Default;
    for (int i = 0; i < this._size; i++)
    {
        if (comparer.Equals(this._items[i], item))
            return true;
    }
    return false;
}`

#### 基于元素的方法

本节将研究不同的基于元素的扩展方法，例如`First`、`FirstOrDefault`、`Last`、`LastOrDefault`、`SingleOrDefault`、`ElementAt`、`ElementAtOrDefault`和`DefaultIfEmpty`。

##### 第一

`First`方法返回序列的第一个元素。该扩展的方法签名是:

`public static TSource First<TSource>(this IEnumerable<TSource> source) public static TSource First<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)`

这个扩展方法的第一个版本从项目序列中查找第一个项目。这个扩展方法的第二个版本查找满足谓词条件的列表的第一项。

清单 12-49 展示了`First`方法的使用。

***清单 12-49。**第一种扩展方法的例子*

`using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> numbers = new List<int>()
            {
                1,2,3,4,5,6,7
            };

            var firstItem = numbers.First();
            var firstItemBasedOnConditions = numbers.First(item => item > 3);` `            Console.WriteLine("{0}\n{1}",
                firstItem,
                firstItemBasedOnConditions);
        }
    }
}`

该程序产生以下输出:

`1
4`

第一种执行方法的内部操作

当 CLR 执行第一个版本的`First`方法时，它按照以下步骤执行操作:

*1。步骤 1*:CLR 将原始列表作为输入参数发送给`First <TSource>(this IEnumerable<TSource> source)`方法。

*2。步骤 2* :该方法将返回原始列表的第一项，或者遍历原始列表，返回迭代的第一项。

`First`方法的实现如[清单 12-50](#list_12_50) 所示。

***清单 12-50。**实施第一种方法*

`public static TSource First<TSource>(this IEnumerable<TSource> source)
{
    IList<TSource> list = source as IList<TSource>;
    if (list != null)
    {
        if (list.Count > 0)
            return list[0];
    }
    else
    {
        using (IEnumerator<TSource> enumerator = source.GetEnumerator())
        {
            if (enumerator.MoveNext())
                return enumerator.Current;
        }
    }
}`

为了执行`First`方法的重载方法，该方法使用一个谓词来过滤列表，CLR 将使用方法`<Main>b__1` ( `item => item > 3`)实例化`MulticastDelegate`的一个实例。然后，它将遍历列表，并根据谓词匹配序列中的每个元素。这在第一次匹配时返回，否则它将继续，直到找到一个匹配。

`First`方法的实现应该是:

`public static TSource First<TSource>(
    this IEnumerable<TSource> source,
    Func<TSource, bool> predicate)` `{
    foreach (TSource local in source)
    {
        if (predicate(local))
            return local;
    }
}`

##### 第一默认

`FirstOrDefault`方法返回序列的第一个元素，如果没有找到元素，则返回默认值。`FirstOrDefault`方法的签名是:

`public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source) public static TSource FirstOrDefault<TSource>(
    this IEnumerable<TSource> source, Func<TSource, bool> predicate)`

这两个方法将返回序列的第一个元素，如果序列不包含元素，则返回默认值。默认值将是将为其实例化列表的泛型类型的值。例如，如果列表是类型`int`，如果列表中没有元素，默认值将为零。它返回序列中满足条件的第一个元素，如果没有找到这样的元素，则返回默认值。

清单 12-51 给出了一个例子来演示`FirstOrDefault`方法的使用。

***清单 12-51。**第一顺序默认方法示例*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> firstNumbers = new List<int>();

            IList<int> secondNumbers = new List<int>()
            {
                1,2,3,4,5,6,7
            };

            var firstItemOfFirstList = firstNumbers.FirstOrDefault();
            var firstItemIfFirstListBasedOnConditions =
                firstNumbers.FirstOrDefault(item => item > 3);

            var firstItemOfSecondList = secondNumbers.FirstOrDefault();
            var firstItemOfSecondListBasedOnConditions =
                secondNumbers.FirstOrDefault(item => item > 3);` `            Console.Write(string.Format("{0}\t{1}\t{2}\t{3}",
                firstItemOfFirstList,
                firstItemIfFirstListBasedOnConditions,
                firstItemOfSecondList,
                firstItemOfSecondListBasedOnConditions
                ));
        }
    }
}`

清单 12-51 中的程序产生了输出:

`0       0       1       4`

FirstOrDefault 执行方法的内部操作

第一个重载的`FirstOrDefault`方法的实现如清单 12-52 中的[所示。](#list_12_52)

***清单 12-52。**第一种优先默认方法的实现*

`public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source)
{

    IList<TSource> list = source as IList<TSource>;
    if (list != null)
    {
        if (list.Count > 0)
            return list[0];
    }
    else
    {
        using (IEnumerator<TSource> enumerator = source.GetEnumerator())
        {
            if (enumerator.MoveNext())
                return enumerator.Current;
        }
    }
    return default(TSource);
}`

第二个重载的`FirstOrDefault`方法的实现如[清单 12-53](#list_12_53) 所示。

***清单 12-53。**第二种先订后默认方法的实现*

`public static TSource FirstOrDefault<TSource>(
    this IEnumerable<TSource> source,
    Func<TSource, bool> predicate)
{
    foreach (TSource local in source)
    {
        if (predicate(local))
            return local;` `    }
    return default(TSource);
}`

##### 最后的

`Last`方法用于查找序列的最后一个元素。此扩展方法的方法签名是:

`public static TSource Last<TSource>(this IEnumerable<TSource> source)
public static TSource Last<TSource>(this IEnumerable<TSource> source, Func<TSource, bool>
predicate)`

此方法的第一个版本将从项目序列中找到最后一个项目。该方法的第二个版本将从列表中找到满足谓词条件的最后一项。

清单 12-54 中的程序演示了`Last`扩展方法的使用。

***清单 12-54。**最后一个扩展方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> numbers = new List<int>()
            {
                1,2,3,4,5,6,7
            };

            var lastItem = numbers.Last();
            Console.WriteLine(lastItem);
            var lastItemBasedOnConditions = numbers.Last(item => item > 3);
            Console.WriteLine(lastItemBasedOnConditions);
        }
    }
}`

代码产生了输出:

`7
7`

最后一个执行方法的内部操作

当 CLR 执行第一个重载的`Last`方法时，原始列表将作为输入传递给`Last <TSource> (this IEnumerable<TSource> source)`方法。该方法将通过从原始列表中获取的`Enumerator`对象遍历列表，保留来自`Enumerator`的当前项，并在调用`MoveNext`时检查枚举器是否返回 true 值。只要这个`MoveNext`返回，迭代将继续，并且来自枚举器的当前项将在本地保存。如果`MoveNext`返回 false，迭代将结束，当前值将作为列表的最后一项返回。这个构造函数的实现如[清单 12-55](#list_12_55) 所示。

***清单 12-55。**最后一种方法的实现*

`public static TSource Last<TSource>(this IEnumerable<TSource> source)
{
    IList<TSource> list = source as IList<TSource>;
    if (list != null)
    {
        int count = list.Count;
        if (count > 0)
            return list[count - 1];
    }
    else
    {
        using (IEnumerator<TSource> enumerator = source.GetEnumerator())
        {
            if (enumerator.MoveNext())
            {
                TSource current;
                do
                {
                   **/* Hold the Current item from the original list */**
                    current = enumerator.Current;
                }while (enumerator.MoveNext());
                return current;
            }
        }
    }
    throw Error.NoElements();
}`

为了执行`Last`方法的重载版本，如[清单 12-55](#list_12_55) 中所用，C#编译器将在编译时使用匿名方法(`item => item > 3`)构造一个方法`<Main>b__1`，CLR 将使用`<Main>b__1`实例化`MulticastDelegate`的一个实例。CLR 将这个实例传递给`Last`方法。CLR 将遍历列表，并根据谓词中提供的条件匹配序列中的每个元素。这将返回满足条件的最后一个元素，否则该类型的默认值将作为泛型类型提供，如清单 12-56 中`Last`方法的实现所示。

***清单 12-56。**最后一种方法的实现*

`public static TSource Last<TSource>(
    this IEnumerable<TSource> source,
    Func<TSource, bool> predicate)
{
    TSource local = default(TSource);
    bool flag = false;` `    foreach (TSource local2 in source)
    {
        if (predicate(local2))
            local = local2;
            flag = true;
    }
    return local;
}`

##### lastor 默认

`LastOrDefault`方法返回序列的最后一个元素，如果没有找到元素，则返回默认值。此扩展方法的方法签名是:

`public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source)
public static TSource LastOrDefault<TSource>(
    this IEnumerable<TSource> source, Func<TSource, bool> predicate)`

清单 12-57 演示了`LastOrDefault`方法的使用。

***清单 12-57。**lastor default 方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> firstNumbers = new List<int>();

            IList<int> secondNumbers = new List<int>()
            {
                1,2,3,4,5,6,7
            };

            var lastItemOfFirstList = firstNumbers.LastOrDefault();
            var lastItemIfFirstListBasedOnConditions =
                firstNumbers.LastOrDefault(item => item > 3);

            var lastItemOfSecondList = secondNumbers.LastOrDefault();
            var lastItemOfSecondListBasedOnConditions =
                secondNumbers.LastOrDefault(item => item > 3);

            Console.Write(string.Format("{0}\t{1}\t{2}\t{3}",
                lastItemOfFirstList,
                lastItemIfFirstListBasedOnConditions,` `                lastItemOfSecondList,
                lastItemOfSecondListBasedOnConditions
                ));
        }
    }
}`

该程序将产生以下输出:

`0       0       7       7`

LastOrDefault 执行方法的内部操作

第一个版本的`LastOrDefault`方法的实现代码是:

`public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source)
{
    IList<TSource> list = source as IList<TSource>;
    if (list != null)
    {
        int count = list.Count;
        if (count > 0)
            return list[count - 1];
    }
    else
    {
        using (IEnumerator<TSource> enumerator = source.GetEnumerator())
        {
            if (enumerator.MoveNext())
            {
                TSource current;
                do
                {
                    current = enumerator.Current;
                }
                while (enumerator.MoveNext());
                return current;
            }
        }
    }
    return default(TSource);
}`

LastOrDefault 扩展方法的第二个版本的实现是:

`public static TSource LastOrDefault<TSource>(
    this IEnumerable<TSource> source,
    Func<TSource, bool> predicate)
{
    TSource local = default(TSource);
    foreach (TSource local2 in source)
    {` `        if (predicate(local2))
            local = local2;
    }
    return local;
}`

##### 单个和单个或默认

`Single`方法返回一个序列的单个特定元素。扩展方法的方法签名是:

`public static TSource Single<TSource>(this IEnumerable<TSource> source) public static TSource Single<TSource>(this IEnumerable<TSource> source,
                                      Func<TSource, bool> predicate)
public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource>
                                               source)
public static TSource SingleOrDefault<TSource>(
    this IEnumerable<TSource> source, Func<TSource, bool> predicate)`

此方法返回序列中的唯一元素，如果序列中没有恰好一个元素，则引发异常。它返回序列中满足指定条件的唯一元素，如果存在多个这样的元素，则引发异常。

[清单 12-58](#list_12_58) 展示了一个使用`Single`扩展方法的程序。在这个程序中，`Single`方法处理只包含一个项目的数字，并返回一个作为输出。

***清单 12-58。**使用单一延伸方式*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<string> numbers = new List<string>
            {
                "One"
            };
            var result = numbers.Single();
            Console.WriteLine("{0}", result);
        }
    }
}`

清单 12-58 中的程序将产生输出:

`One`

单个和单个默认执行方法的内部操作

如果你修改了清单 12-58 中的代码，并在`numbers`列表中增加了一个条目，那么 CLR 将抛出一个异常:

`Unhandled Exception: System.InvalidOperationException: Sequence contains more than one element    at System.Linq.Enumerable.Single[TSource](IEnumerable'1 source)
   at Ch12.Program.Main(String[] args) in J:\Book\ExpertC#2012\SourceCode\BookExamples\Ch12\Program.cs:line 16`

让我们看看这在幕后是如何运作的。在执行`Single`方法时，CLR 将使用原始列表的副本创建一个新的`List<string>`,并检查新列表是否为空。如果它不为空，那么它将检查列表中的项目数。如果列表中的项数是零，那么 CLR 将抛出一个异常，否则如果是一，它将返回列表中的第一个也是唯一的一个项。`Single`方法的实现如[清单 12-59](#list_12_59) 所示。

***清单 12-59。**实施单一方法*

`public static TSource Single<TSource>(this IEnumerable<TSource> source)
{
    IList<TSource> list = source as IList<TSource>;
    if (list != null)
    {
        switch (list.Count)
        {
            case 0:
                throw Error.NoElements();

            case 1:
                return list[0];
        }
    }
    else
    {
        using (IEnumerator<TSource> enumerator = source.GetEnumerator())
        {
            TSource current = enumerator.Current;
            if (!enumerator.MoveNext())
                return current;
        }
    }
    throw Error.MoreThanOneElement();
}`

让我们用谓词函数来尝试一下`Single`扩展方法，如[清单 12-60](#list_12_60) 所示。

***清单 12-60。**单一方法的用法*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;` `namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<string> numbers = new List<string>
            {
                "One","Four"
            };
            var result = numbers.Single(x => x.Length > 3);
            Console.WriteLine("{0}", result);
        }
    }
}`

该程序产生以下输出:

`Four`

让我们分析[清单 12-60](#list_12_60) 来理解当我们执行`Single`方法时发生了什么，如图[图 12-23](#fig_12_23) 所示。

![images](img/-23.jpg)

***图 12-23。**单一方法如何工作*

如果你修改清单 12-60 中的程序，增加一个长度超过三个字符的条目，程序会抛出一个异常而失败。

`SingleOrDefault`的工作方式与`Single`扩展方法非常相似，但是它不是在没有条目时抛出异常，而是返回方法调用中定义的类型的默认值作为泛型类型。让我们看看清单 12-61 中使用`SingleOrDefault`方法的例子。

***清单 12-61** 。SingleOrDefault 方法示例*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<string> listStringWithoutItem = new List<string>();
            IList<string> listStringWithItem = new List<string>() { "One" };` `            IList<int> listInt = new List<int>();
            IList<char> listChar = new List<char>();
            IList<long> listLong = new List<long>();
            IList<double> listDouble = new List<double>();

            Console.WriteLine("string   : {0}",
                              listStringWithoutItem.SingleOrDefault());
            Console.WriteLine("string   : {0}",  
                              listStringWithItem.SingleOrDefault());
            Console.WriteLine("int      : {0}", listInt.SingleOrDefault());
            Console.WriteLine("char     : {0}", listChar.SingleOrDefault());
            Console.WriteLine("long     : {0}", listLong.SingleOrDefault());
            Console.WriteLine("double   : {0}", listDouble.SingleOrDefault());
        }
    }
}`

清单 12-61 中的程序将产生输出:

`string      :
string      : One
int         : 0
char        :
long        : 0
double      : 0`

让我们分析清单 12-61 中的代码，以理解当 CLR 执行`SingleOrDefault`方法时发生了什么。

CLR 在临时列表中制作原始列表的副本。然后，它检查列表中的项数，如果为零，则 CLR 将返回所提供类型的默认值，例如字符串`listStringWithoutItem.SingleOrDefault<string>()`，或者从列表中推断的类型(例如，`listStringWithoutItem`是`IList<string>`的一种类型，因此推断的类型将是字符串)。在[清单 12-62](#list_12_62) 中演示了`SingleOrDefault`方法的实现。

***清单 12-62。**single order default 方法实施*

`public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source)
{
    IList<TSource> list = source as IList<TSource>;
    if (list != null)
    {
        switch (list.Count)
        {
            case 0:
                return default(TSource);

            case 1:
                return list[0];
        }
    }
    else
    {` `        using (IEnumerator<TSource> enumerator = source.GetEnumerator())
        {
            if (!enumerator.MoveNext())
                return default(TSource);

            TSource current = enumerator.Current;

            if (!enumerator.MoveNext())
                return current;
        }
    }
    throw Error.MoreThanOneElement();
}`

##### 项目在

`ElementAt`扩展方法返回序列中指定索引处的元素。此扩展方法的方法签名是:

`public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, int index)`

清单 12-63 展示了使用`ElementAt`方法的程序。

***清单 12-63。**element at 方法的例子*

`using System;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<string> numbers = new List<string>()
            {
                "One","Two","Three"
            };

            var elementAt = numbers.ElementAt(1);

            Console.WriteLine(elementAt);
        }
    }
}`

该程序产生以下输出:

`Two`

执行方法中元素的内部操作

让我们仔细分析清单 12-63 中的代码，以理解当我们执行`ElementAt`方法时发生了什么。

*1。步骤 1*:CLR 在执行`ElementAt<TSource>()`扩展方法的同时，从`System.Collections.Generic.List'1<T>`调用`get_Item`方法。[清单 12-64](#list_12_64) 是使用`ildasm.exe`从`mscorlib.dll`组件的`System.Linq.Enumerable`类的`ElementAt`方法中提取出来的，如[清单 12-64](#list_12_64) 所示。

***清单 12-64。**element at 方法的例子*

`.method public hidebysig static !!TSource ElementAt<TSource>(
  class [mscorlib]System.Collections.Generic.IEnumerable'1<!!TSource> source,
       int32 index) cil managed
{
  IL_0018: ldloc.0
  **/* Load the argument which is used as the index to retrieve item from**
   *** the array */**
  IL_0019: ldarg.1
  IL_001a: callvirt   instance !0 class
      [mscorlib]System.Collections.Generic.IList'1<!!TSource>::
           get_Item(int32)
  IL_001f: ret
} // end of method Enumerable::ElementAt`

从这段代码中可以看到，CLR 调用了带有索引的`System.Collections.Generic.List'1<T>`类的`get_Item(int32)`方法(`ElementAt`方法的输入)。

*2。步骤 2*:`get_Item(int32)`方法将加载该类的`_items`数组(在下面的 IL 代码中标记为`IL_000f`),并将加载参数(在下面的 IL 代码中标记为`IL_0014`)以获取索引，该索引稍后将用于根据索引从`_items`数组中访问项目。使用`ildasm.exe`从`mscorlib.dll`的`System.Collections.Generic.List'1<T>`类中提取出`get_Item(int32)`方法的[清单 12-65](#list_12_65) 中的 IL 代码。

***清单 12-65。**element at 方法的例子*

`.method public hidebysig newslot specialname virtual final
        instance !T  get_Item(int32 index) cil managed
{
  IL_000e:  ldarg.0
  **/* It will load the _items array */**
  IL_000f:  ldfld      !0[] class System.Collections.Generic.List'1<!T>::_items
  IL_0014:  ldarg.1

  **/* CLR will load an item based on the index value provided into !T  */**
  IL_0015:  ldelem     !T
  IL_001a:  ret
} // end of method List'1::get_Item` 

在[清单 12-65](#list_12_65) 中，`IL_000f`中使用的`ldfld` IL 指令将加载`List<T>`类的`_items`字段，并且在`IL_0014`标签上，它将加载参数 1，这是使用`IL_0015`中使用的 IL 指令`ldelem`从`_items`数组中访问项目所使用的数组的索引。

![images](img/.jpg) `ldfld filedName`:将指定的字段的值推送到方法的(`get_item`)栈。

![images](img/.jpg) `ldelem indexPosition:`它将从数组的`indexPosition`中指定的位置加载一个元素。

##### elemontatordefault

`ElementAtOrDefault`方法返回序列中指定索引处的元素，如果索引超出范围，则返回默认值。方法签名是:

`public static TSource ElementAtOrDefault<TSource>(this IEnumerable<TSource> source, int index)`

清单 12-66 给出了一个`ElementAtOrDefault`方法的例子。

***清单 12-66。**elementator default 方法的例子*

`using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
namespace Ch12
{
    public struct MyStruct
    {
        public string Name { get; set; }
    }
    public class Person
    {
        public string PersonID { get; set; }
        public int PersonAge { get; set; }
    }
    class Program
    {
        static void Main(string[] args)
        {
            List<string> series = new List<string> { "One", "Two", "Three" };
            List<MyStruct> names = new List<MyStruct>
            {
                new MyStruct{ Name="A"},
                new MyStruct{ Name="B"},
            };
            List<Person> persons = new List<Person>
            {
                 new Person { PersonID = "PA_01", PersonAge = 6 },
                new Person { PersonID = "PB_01", PersonAge = 7 },` `            };
            // output will be null
            var item = series.ElementAtOrDefault(8);
            // Output contain an instnce of MyStruct in where Name will be null
            var name = names.ElementAtOrDefault(8);
            //Output will be null
            var person = persons.ElementAtOrDefault(8);
        }
    }
}`

ElementAtOrDefault 执行方法的内部操作

对于`ElementAtOrDefault`方法，CLR 会将原始列表和索引传递给`ElementAtOrDefault`方法。然后它会从指定的索引中找到该项，或者返回默认值，例如，引用和可空类型的默认值是 null，或者值类型的默认值(参见[第 1 章](01.html#ch1))。

##### DefaultIfEmpty

如果序列为空，`DefaultIfEmpty`方法返回`IEnumerable<T>`或缺省值单例集合的元素。此扩展方法的签名是:

`public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source) public static IEnumerable<TSource> DefaultIfEmpty<TSource>(
    this IEnumerable<TSource> source, TSource defaultValue)`

第一个版本返回指定序列的元素，如果序列为空，则返回 singleton 集合中的类型参数的默认值。第二个版本返回指定序列的元素，如果序列为空，则返回单一集合中的指定值。

此方法可用于不包含项目的列表。如果我们在这个列表上调用扩展方法，它将返回该项的默认值。清单 12-67 展示了一个使用`DefaultIfEmpty`方法的程序。

***清单 12-67。**使用默认方法*

`using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {

            IList<Person> persons = new List<Person>();
            IList<int> numbers = new List<int>();
            IList<string> names = new List<string>();
           /* Output: A list with 1 item with the null value */
            var defaultPersons = persons.DefaultIfEmpty();` `           /*Output: A list with 1 item with the 0 value */
            var defaultNumbers = numbers.DefaultIfEmpty().ToList();       
           /* Output: A list with 1 item with the null value */
            var defaultNames = names.DefaultIfEmpty();
        }
    }

    class Person
    {
        public string Name
        {
            get;
            set;
        }

        public string Address
        {
            get;
            set;
        }

        public int Age
        {
            get;
            set;
        }
    }
}`

DefaultIfEmpty 执行方法的内部操作

[清单 12-67](#list_12_67) 有三个清单，分别为`Person`、`int`、`string`类型的`persons`、`numbers`、`names`。这三个列表没有任何条目，因为这个列表的`Count`属性返回零。当对这个列表中的任何一个调用`DefaultIfEmpty`方法时，CLR 将会:

*   将列表复制到这个`DefaultIfEmpty`方法中。从这个方法中，CLR 将返回`DefaultIfEmptyIterator<TSource>`迭代器的实例，它将保存相关类型的默认值和源值。`defaultvalue`属性将包含它正在处理的列表类型的默认值，源将是原始列表。
*   将`DefaultIfEmptyIterator`传递给`ToList`方法，该方法将调用将`DefaultIfEmptyIterator`的对象作为输入传递的`List`类。在这个类中，CLR 将遍历原始列表并处理结果。

清单 12-68 中的[显示了`DefaultIfEmptyIterator`的实现。](#list_12_68)

***清单 12-68。**defaultifemptyerator 方法的实现*

`private static IEnumerable<TSource> DefaultIfEmptyIterator<TSource>(
    IEnumerable<TSource> source,
    TSource defaultValue)` `{
    using (IEnumerator<TSource> iteratorVariable0 = source.GetEnumerator())
    {
        if (iteratorVariable0.MoveNext())
            do
            {
                yield return iteratorVariable0.Current;
            }
            while (iteratorVariable0.MoveNext());
        else
            yield return defaultValue;
    }
}`

从[清单 12-68](#list_12_68) 中，你可以看到迭代器无法遍历，因此，CLR 将返回`DefaultIfEmptyIterator`的值`defaultValue`。在这种情况下，`persons.DefaultIfEmpty()`的`DefaultIfEmptyIterator`的`defaultValue`将为空(因为`persons`是类型`IList<Person>`)，数字为 0(因为它是`IList<int>`的类型)，名字为空(因为它是`IList<string>`的类型)。

#### 基于世代的方法

本节将研究`Empty`、`Range`和`Repeat`扩展方法。

##### 空的

`Empty`方法返回空的`IEnumerable<T>`。该扩展的方法签名是:

`public static IEnumerable<TResult> Empty<TResult>()`

清单 12-69 展示了`Empty`方法的使用。

***清单 12-69。**空法的例子*

`using System;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            var emptyList = Enumerable.Empty<int>();

            Console.WriteLine(emptyList.Count());
        }
    }
}`

清单 12-69 中的程序产生输出:

`0`

执行空方法的内部操作

当 CLR 执行`Empty`方法时，如[清单 12-69](#list_12_69) 所示，它创建一个空的`int`列表。让我们分析一下[清单 12-69](#list_12_69) 中的代码，帮助我们理解执行这个程序时发生了什么。

*1。步骤 1*:CLR 在执行`Empty<TResult>`方法时调用`EmptyEnumerable'1<!!TResult>`(来自`System.Core.dll`程序集的`System.Linq`命名空间的内部类)的`get_Instance`方法。这个类有一个给定类型的数组字段(`!!TResult`)和一个返回数组字段的属性实例。[清单 12-70](#list_12_70) 中的 IL 代码展示了`get_Instance`方法是如何被调用的。

***清单 12-70。**空法的例子*

`.method public hidebysig static class
  [mscorlib]System.Collections.Generic.IEnumerable'1<!!TResult>
        Empty<TResult>() cil managed
{
  IL_0000:  call class [mscorlib]System.Collections.Generic.IEnumerable'1<!0>
       class System.Linq.EmptyEnumerable'1<!!TResult>::get_Instance()
  IL_0005:  ret
} // end of method Enumerable::Empty`

*2。步骤 2* :来自`System.Linq.EmptyEnumerable'1<!!TResult>`的实例属性将调用`get_Instance`方法。`get_Instance`方法将创建一个零元素的数组。CLR 将首先使用标签`IL_0007`中的`ldc.i4.0` IL 指令将零作为`int32`类型压入堆栈，如[清单 12-71](#list_12_71) 所示。使用`newarr` IL 指令，CLR 将创建一个包含零项的新数组，并将其推送到堆栈上。在标签`IL_000d`中，CLR 将使用`stsfld`替换字段值的值(即，实例字段的值使用堆栈中的值)。

***清单 12-71。**get _ Instance 方法的内部操作*

`.method public hidebysig specialname static
        class [mscorlib]System.Collections.Generic.IEnumerable'1<!TElement>
        get_Instance() cil managed
{
  // code size       24 (0x18)
  .maxstack  8
  IL_0000:  ldsfld    !0[] class  
            System.Linq.EmptyEnumerable'1<!TElement>::'instance'
  IL_0005:  brtrue.s   IL_0012
  IL_0007:  ldc.i4.0
  IL_0008:  newarr    !TElement
  IL_000d:  stsfld    !0[] class
            System.Linq.EmptyEnumerable'1<!TElement>::'instance'
  IL_0012:  ldsfld    !0[] class
            System.Linq.EmptyEnumerable'1<!TElement>::'instance'
  IL_0017:  ret
} // end of method EmptyEnumerable'1::get_Instance`

##### 范围

`Range`方法生成指定范围内的整数序列，通过使用延迟执行来实现。立即返回值是相关迭代器实例的一个实例，它存储了执行操作所需的所有信息。此方法的方法签名是:

`public static IEnumerable<int> Range(int start, int count)`

该方法将根据开始编号创建一个`int`项目列表，直到在计数中定义了次数。[清单 12-72](#list_12_72) 演示了`Range`方法的使用。

***清单 12-72。**范围法的例子*

`using System;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            Enumerable.Range(1, 10).ToList().ForEach(x =>
                       Console.Write("{0}\t", x));
        }
    }
}`

清单 12-72 中的程序将产生输出:

`1       2       3       4       5       6       7       8       9       10`

范围执行方法的内部操作

[图 12-24](#fig_12_24) 展示了 CLR 如何执行`Range`方法。

![images](img/-24.jpg)

***图 12-24。**范围方法的工作原理*

CLR 按照以下步骤执行`Range`操作:

*1。步骤 1*:CLR 将开始元素和生成序列的长度作为输入传递给`Range`方法。[清单 12-73](#list_12_73) 中的代码演示了 CLR 将返回`RangeIterator<int>`，它将保存所有相关信息，比如开始元素和序列长度。

***清单 12-73。**实施范围法*

`public static IEnumerable<int> Range(int start, int count)
{
    long num = (start + count) - 1L;
    return RangeIterator(start, count);
}`

在 CLR 调用`ToList`方法之前,`RangeIterator<int>`不会被执行(由于延迟执行)。

*2。第 2 步*:CLR 将把这个`RangeIterator<int>`传递给`ToList`方法，再传递给`List`类，并根据在`RangeIterator<int>`类中实现的迭代逻辑处理操作，产生范围序列作为输出。`RangeIterator<int>`的实现如[清单 12-74](#list_12_74) 所示。

***清单 12-74。**range iterator 方法的实现*

`private static IEnumerable<int> RangeIterator(int start, int count)
{
    int iteratorVariable0 = 0;
    while (true)
    {
        if (iteratorVariable0 >= count)
            yield break;

        yield return (start + iteratorVariable0);
        iteratorVariable0++;
    }
}`

##### 重复

`Repeat`方法生成一个序列，该序列包含一个通过使用延迟执行实现的重复值。立即返回值是相关迭代器类型的对象，它存储了执行操作所需的所有信息。这个扩展方法的方法签名是:

`public static IEnumerable<TResult> Repeat<TResult>(TResult element, int count)`

它将生成一个由`TResult`类型定义的数字序列，该序列由 count 测量的次数组成，如[清单 12-75](#list_12_75) 所示。

***清单 12-75。**重复方法的例子*

`using System;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)` `        {
            Enumerable.Repeat(1, 5).ToList().
                       ForEach(x=>Console.Write("{0}\t",x));
        }
    }
}`

`Enumerable`类的`Repeat`方法将生成一个 1 的序列五次。它将产生输出:

`1       1       1       1       1       `

重复执行方法的内部操作

CLR 在执行`Repeat`方法时将遵循以下步骤:

*1。步骤 1*:CLR 将把要重复的元素和重复元素的次数作为输入传递给`Repeat`方法。在`Repeat`方法中，它将构造`RepeatIterator<TResult>`迭代器，迭代器将保存生成序列的相关信息。

*2。步骤 2*:CLR 将把这个`RepeatIterator<TResult>`实例传递给`ToList`方法，后者将把这个迭代器传递给`List`类，并根据在`RepeatIterator<TResult>`中实现的迭代逻辑处理操作，产生重复的序列作为输出。`Repeat`的实施方法是:

`private static IEnumerable<TResult> RepeatIterator<TResult>(TResult element, int count)
{
    int iteratorVariable0 = 0;
    while (true)
    {
        if (iteratorVariable0 >= count)
            yield break;

        yield return element;
        iteratorVariable0++;
    }
}`

#### 基于转换的方法

本节将研究不同的基于转换的扩展方法，如`Cast`、`ToArray`、`OfType`、`ToDictionary`、`ToList`和`ToLookup`。

##### 演员阵容

方法将序列的元素转换成指定的类型。此方法通过使用延迟执行来实现。[清单 12-76](#list_12_76) 给出了一个`Cast`方法的例子。

***清单 12-76。**施法方法示例*

`using System;
using System.Collections;
using System.Linq;
namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            ArrayList numbers = new ArrayList();
            numbers.Add("One");
            numbers.Add("Two");
            numbers.Add("Three");
            numbers.Cast<string>().Select(number => number).ToList().ForEach(
                number => Console.Write("{0}\t", number));
        }
    }
}`

该程序将产生输出:

`One     Two     Three   `

强制转换执行方法的内部操作

让我们分析[清单 12-76](#list_12_76) 中的代码，以理解当 CLR 执行`Cast`方法时发生了什么。[图 12-25](#fig_12_25) 展示了`numbers`将在内部作为输入传递给`Cast`方法。

![images](img/-25.jpg)

***图 12-25。**施法方法的内部操作*

CLR 在执行`Cast`方法时遵循几个步骤:

*1。步骤 1* :它将原始列表`numbers`封装到`CastIterator`中，并将其传递给`Select`方法。

*2。第二步*:`Select`方法将构造`WhereSelectEnumerableIterator`并将其传递给`ToList`方法，这将通过枚举器进行迭代，并将迭代的项转换为推断的类型，例如对于[清单 12-76](#list_12_76) 中的代码，它是`string`。`CastIterator`的实施是:

`private static IEnumerable<TResult> CastIterator<TResult>(IEnumerable source)
{
    IEnumerator enumerator = source.GetEnumerator();
    while (enumerator.MoveNext())
    {
        object current = enumerator.Current;
        **yield return (TResult) current;**
    }
}`

##### toaarray(阵列)

方法将从给定的列表中创建一个数组。清单 12-77 中的程序展示了`ToArray`方法的使用。`ToList<TSource>`有类似的行为，但是它返回一个`List<T>`而不是一个数组。方法签名是:

`public static TSource[] ToArray<TSource>(this IEnumerable<TSource> source)`

***清单 12-77** 。ToArray 方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> firstList = new List<int>()
            {
                1,2,3,4
            };

            var result = firstList.ToArray();
            result.ToList().ForEach(x =>
                            Console.Write(string.Format("{0}\t",x)));
        }
    }
}`

该程序将产生以下输出:

`1       2       3       4       `

to array 执行方法的内部操作

让我们分析清单 12-77 中的代码，以理解当 CLR 执行`ToArray`方法时发生了什么。

*1。步骤 1*:CLR 将原始列表作为输入传递给`ToArray<TSource>`方法。在`ToArray`方法中，它将通过传递原始列表对象作为输入来创建一个`Buffer<TSource>`类型的实例。

*2。步骤 2*:CLR 会将原始列表中的每一项复制到一个名为`items`的内部数组中。`ToArray`方法的实现是:

`public static TSource[] ToArray<TSource>(this IEnumerable<TSource> source)
{
    Buffer<TSource> buffer = new Buffer<TSource>(source);

    return buffer.ToArray();
}`

`Buffer<TSource>`的内部结构是:

`internal struct Buffer<TElement>
{
    internal TElement[] items;
    internal int count;
    internal Buffer(IEnumerable<TElement> source)
    {
        TElement[] array = null;
        int length = 0;
        ICollection<TElement> i.= source as ICollection<TElement>;
        if (i.!= null)
        {
            length = i..Count;
            if (length > 0)
            {
                array = new TElement[length];
                i..CopyTo(array, 0);
            }
        }
        else
        {
            foreach (TElement local in source)
            {
                if (array == null)
                {
                    array = new TElement[4];
                }
                else if (array.Length == length)
                {
                    TElement[] destinationArray = new TElement[length * 2];
                    Array.Copy(array, 0, destinationArray, 0, length);
                    array = destinationArray;
                }` `                array[length] = local;
                length++;
            }
        }
        this.items = array;
        this.count = length;
    }   
}`

*3。第三步*:当 CLR 调用`ToArray`方法时，它将返回项目。

`ToArray`方法的实现是:

`internal TElement[] ToArray()
{
    if (this.count == 0)
        return new TElement[0];

    if (this.items.Length == this.count)
        return this.items;

    TElement[] destinationArray = new TElement[this.count];
    Array.Copy(this.items, 0, destinationArray, 0, this.count);
    return destinationArray;
}`

从这个源代码中我们可以看到，`items`数组的副本作为`ToArray`方法的输出返回。

##### 类型

`OfType`扩展方法使用延迟执行基于指定的类型过滤`IEnumerable`的元素。立即返回值是迭代器类的一个对象，它存储了执行操作所需的所有信息。这个扩展方法的签名是:

`public static IEnumerable<TResult> OfType<TResult>(this IEnumerable source)`

清单 12-78 给出了一个使用`OfType`方法的例子。

***清单 12-78。**of type<t result>方法*的例子

`using System;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<object> numbers = new List<object>()
            {` `                "One",
                "Two",
                1,
                2,
                "Three",
                new Person
                {
                     Name="A Person"
                }
            };

            var filteredNumbers = numbers.OfType<string>();

            filteredNumbers.ToList().ForEach(x => Console.Write("{0}\t", x));
            Console.WriteLine();
        }
    }

    public class Person
    {
        public string Name { get; set; }
    }
}`

该程序将从数字列表中过滤字符串值，作为在`OfType`方法中使用的字符串类型。该程序将产生输出:

`One     Two     Three`

OfType 执行方法的内部操作

让我们分析清单 12-78 中的代码，以真正理解当 CLR 执行`OfType`方法时发生了什么。

*1。步骤 1*:CLR 会将序列(例如，本例中的数字)作为输入传递给`OfType`方法。在`OfType`方法中，CLR 将实例化`OfTypeIterator`，它将在其中保存原始序列。`OfType`方法的实现是:

`public static IEnumerable<TResult> OfType<TResult>(this IEnumerable source)
{
    return OfTypeIterator<TResult>(source);
}`

*2。步骤 2*:CLR 将把`OfTypeIterator<TResult>`类的实例传递给`ToList`方法，后者将把这个迭代器传递给`List`类，并根据在`OfTypeIterator`中实现的迭代逻辑处理操作，产生范围序列作为输出。`RangeIterator`的实施是:

`private static IEnumerable<TResult> OfTypeIterator<TResult>(IEnumerable source)
{
    IEnumerator enumerator = source.GetEnumerator();` `    while (enumerator.MoveNext())
    {
        object current = enumerator.Current;
        if (current is TResult)
            yield return (TResult) current;
    }
}`

##### ToDictionary

`ToDictionary`方法从一个`IEnumerable<T>`创建一个`Dictionary<TKey, TValue>`。如果您想基于列表中的数据创建一个 dictionary 对象，这个方法会自动完成，但是您需要从列表数据中指定一个字段作为键。这种方法的特征是:

`public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(     this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(
    this IEnumerable<TSource> source,
    Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(
    this IEnumerable<TSource> source,
    Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(
    this IEnumerable<TSource> source, Func<TSource, TKey> keySelector,
    Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)`

清单 12-79 给出了一个例子来解释`ToDictionary`方法的使用。

***清单 12-79。**诊断方法示例*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<Person> persons = new List<Person>()
            {
                new Person(){ Name="Person A", Address= "Address of A",
                              Id= 111111},
                new Person(){ Name="Person B", Address= "Address of B",
                              Id= 111112},
                new Person(){ Name="Person C", Address= "Address of C",
                              Id= 111113},
                new Person(){ Name="Person D", Address= "Address of D",
                              Id= 111114},` `            };

            var result = persons.ToDictionary(person => person.Id);

            foreach (KeyValuePair<double, Person> person in result)
            {
                Console.WriteLine("{0,-15} {1,-20}{2,-20}{3,-20}",
                    person.Key,
                    person.Value.Name,
                    person.Value.Address,
                    person.Value.Id);
            }
        }
    }

    public class Person
    {
        public string Name
        {
            get;
            set;
        }

        public string Address
        {
            get;
            set;
        }

        public double Id
        {
            get;
            set;
        }
    }
}`

清单 12-79 中的程序产生输出:

`111111          Person A           Address of A        111111
111112          Person B           Address of B        111112
111113          Person C           Address of C        111113
111114          Person D           Address of D        111114`

ToDictionary 执行方法的内部操作

从[清单 12-79](#list_12_79) 中的代码你可以看到一个`Person`对象的列表被创建并存储在`persons`中，然后使用`ToDictionary`方法将`persons`转换成一个字典。`ToDictionary`采用匿名方法作为输入。这个匿名方法实际上是一个键选择器，它将从列表中选择键，并将其设置为 dictionary 对象中的键。例如，`Person`中的`Id`被选为字典中结果的键，其值为`person`对象本身。有趣的是，`Id`属性将被用作字典的键，并且在初始化时，它也将被存储为`person`对象的一部分。让我们分析[清单 12-79](#list_12_79) 来帮助我们理解当 CLR 执行`ToDictionary`方法时发生了什么。

*1。步骤 1* :如果我们使用`ildasm.exe`从`System.core.dll`程序集打开`System.Linq.Enumerable`名称空间，您可以看到`ToDictionary`方法在内部调用内部的`ToDictionary`方法，其签名为:

`public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(
    this IEnumerable<TSource> source, Func<TSource, TKey> keySelector,
    Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)`

在 CLR 从`ToDictionary`扩展方法调用内部`ToDictionary`方法之前，它将创建一个元素选择器函数。尽管我们没有在[清单 12-79](#list_12_79) 中提供任何元素选择器，CLR 将使用默认的元素选择器，即`IdentityFunction<TSource>.Instance`，它是一个内部类，将被用作`ToDictionary`方法的元素选择器。[图 12-26](#fig_12_26) 显示了来自`System.Core.dll`组件的该类。

![images](img/-26.jpg)

***图 12-26。**系统中的身份识别功能。Linq*

清单 12-80 中的[给出了`ToDictionary`方法的实现。](#list_12_80)

***清单 12-80。**实施 ToDictionary 方法*

`public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(
    this IEnumerable<TSource> source,
    Func<TSource, TKey> keySelector)
{
    return source.ToDictionary<TSource, TKey, TSource>(
        keySelector, IdentityFunction<TSource>.Instance, null);
}`

*2。第二步*:当 CLR 执行上述方法时，它调用重载的`ToDictionary`，如清单 12-81 中的[所示。](#list_12_81)

***清单 12-81。**实施 ToDictionary 方法*

`public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(
    this IEnumerable<TSource> source, Func<TSource, TKey> keySelector,
    Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
{
    Dictionary<TKey, TElement> dictionary =
              new Dictionary<TKey, TElement>(comparer);

    foreach (TSource local in source)
        dictionary.Add(keySelector(local), elementSelector(local));
    return dictionary;
}`

这将实例化一个`Dictionary<TKey, TElement>`类的实例。然后，它将遍历原始列表，每个迭代值都将传递给`KeySelector`和`ElementSelector`函数，以从迭代值中提取`Key`和`Value`。匿名方法(`person => person.Id`)将被用作`KeySelector`。C#编译器将生成一个匿名方法`<Main>b_5`并将其传递给`KeySelector`，该方法将从`person`对象返回`Id`，编译器将编译`ElementSelector`(如`IdentityFunction<TElement>`中的`x=>x`，其中`x=>x`将被转换为`<get_Instance>b__0`)，该方法将返回值本身(即内部带有`Name`、`Address`和`Id`值的`person`对象)。

##### 托利斯

`ToList`方法从一个`IEnumerable<T>`创建一个`List<T>`。此扩展方法的方法签名是:

`public static List<TSource> ToList<TSource>(this IEnumerable<TSource> source)`

清单 12-82 提供了`ToList`方法的工作细节。

***清单 12-82。**to list()扩展方法的例子*

`using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> numbers = new List<int>()
            {
                1,2,3,4,5,6,7,8,9,10
            };

            var result = numbers.Where(x => x > 3).ToList();

            result.ForEach(x => Console.Write("{0}\t", x));` `            Console.WriteLine();
        }
    }
}`

该程序将产生以下输出:

`4       5       6       7       8       9       10`

ToList 执行方法的内部操作

让我们分析清单 12-82 中的代码，以真正理解当 CLR 执行`ToList`方法时发生了什么。

*1。步骤 1*:`ToList`方法将接受一个`IEnumerable<TSource>`对象作为输入。它将把这个`IEnumerable`对象作为输入传递给`List<TSource>`类型:

`public static List<TSource> ToList<TSource>(this IEnumerable<TSource> source)
{
    return new List<TSource>(source);
}`

*步骤 2*:`List<IEnumerable<TSource>`>类型将接受一个`IEnumerable<TSource>`集合作为构造函数的输入。在构造函数内部，CLR 将初始化类型为`TSource`的`_items`数组，默认情况下用`4`定义数组的初始大小。然后它将遍历输入列表的枚举器，如[清单 12-83](#list_12_83) 所示。

***清单 12-83。**清单构造器的实现*

`public List(IEnumerable<T> collection)
{
    ICollection<T> i. = collection as ICollection<T>;
    if (i. != null)
    {
        int count = i..Count;
        this._items = new T[count];
        i..CopyTo(this._items, 0);
        this._size = count;
    }
    else
    {
        this._size = 0;
        this._items = new T[4];
        using (IEnumerator<T> enumerator = collection.GetEnumerator())
        {
            while (enumerator.MoveNext())
                this.Add(enumerator.Current);
        }
    }
}`

*3。步骤 3*:CLR 将步骤 2 中迭代阶段的每一项传递给`Add(TSource item)`方法，将它们添加到步骤 2 中初始化的`_items`数组中。`Add`的实施方法是:

`public void Add(T item) {
    if (this._size == this._items.Length)
        this.EnsureCapacity(this._size + 1);

    this._items[this._size++] = item;
    this._version++;
}`

在`Add`方法中，最重要的代码是第`this.EnsureCapacity(this._size + 1).`行，这个`_items`数组的大小是动态的，它将由`EnsureCapacity`方法来保证。

*4。第四步*:完成迭代后，CLR 将返回 list 对象作为`ToList`方法的输出，它将包含从`_items`数组中给定的`IEnumerable<TSource>`对象返回的元素。

##### ToLookup

`ToLookup`方法基于指定的键选择器创建一个查找。此扩展方法的方法签名是:

`public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(
  this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(
  this IEnumerable<TSource> source,
  Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(
  this IEnumerable<TSource> source,
  Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(
  this IEnumerable<TSource> source, Func<TSource, TKey> keySelector,
  Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)`

`ToLookup`方法将为一个给定的列表创建一个`Key`和`Value`的映射。与`Dictionary`相比，该方法将映射一对多(即`Dictionary`映射一个键对一个值)，而`ToLookup`方法映射一个键对多个值。例如，如果您有一个列表，如:

`**/* Before: applying the ToLookup Key and Data combination */**
{ A, { A1.1,    A1.1  } }
{ A, { A2.2,    A2.2  } }
{ A, { A3.3,    A3.3  } }

{ B, { B1.1,    B1.1  } }

{ C, { C1.1,    C1.1  } }
{ C, { C2.1,    C2.2  } }`

`ToLookup`将产生输出:

`**/* After: applying the ToLookup Key and Data combination */**
{ A,    { A1.1,     A1.1 } }
{       { A2.2,     A2.2 } }
{       { A3.3,     A3.3 } }

{ B,    { B1.1,     B1.1 } }

{ C,    { C1.1,     C1.1 } }

{       { C2.1,     C2.2 } }`

所以在`ToLookup`方法组中，整个项目集都是基于键的:

*   一个类别中的所有数据都归入一个
*   B 类别组中的所有数据都在 B 下
*   C 类别组中的所有数据都在 C 下

[图 12-27](#fig_12_27) 展示了`ToLookup`方法的基本原理。

![images](img/-27.jpg)

***图 12-27。**to lookup 方法的基本操作*

清单 12-84 给出了一个`ToLookup`方法的例子。

***清单 12-84。**ToLookup 方法的例子*

`using System;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            List<Person> persons = CreatePersonList();` `            var result = persons.ToLookup(
                (key) => key.Name,
                (groupItem) => groupItem.Address);

            result.ToList().ForEach(item =>
            {
                Console.Write("Key:{0,11}\nValue:\t{1,12}\n",
                    item.Key,
                    string.Join("\n\t", item.Select(groupItem =>
                        groupItem).ToArray()));
            });
        }

        private static List<Person> CreatePersonList()
        {
            return new List<Person>()
            {
                new Person{ Name="APerson",    Address="APerson's Address"},
                new Person{ Name="AAPerson",   Address="AAPerson's Address"},
                new Person{ Name="APerson",     
                            Address="APerson's Second Address"},
                new Person{ Name="BPerson",    Address="BPerson's Address"},
                new Person{ Name="BBPerson",   Address="BBPerson's Address"},
                new Person{ Name="BPerson",     
                            Address="BPerson's Second Address"},
                new Person{ Name="CPerson",    Address="CPerson's Address"},
                new Person{ Name="CCPerson",   Address="CCPerson's Address"},
                new Person{ Name="CPerson",     
                            Address="CPerson's Second Address"},           
            };
        }
    }

    public class Person
    {
        public string Name { get; set; }
        public string Address { get; set; }
    }
}`

该程序将产生以下输出:

`Key:    APerson
Value:  APerson's Address
        APerson's Second Address
Key:   AAPerson
Value:  AAPerson's Address
Key:    BPerson
Value:  BPerson's Address
        BPerson's Second Address
Key:   BBPerson` `Value:  BBPerson's Address
Key:    CPerson
Value:  CPerson's Address
        CPerson's Second Address
Key:   CCPerson
Value:  CCPerson's Address`

查找执行方法的内部操作

让我们分析清单 12-84 中的代码，以理解当 CLR 执行`ToLookup`方法时发生了什么。

*1。步骤 1*:C #编译器将使用匿名方法`(key) => key.Name`构造方法`<Main>b__1`，使用匿名方法`(groupItem) => groupItem.Address`构造`<Main>b__2`。CLR 将使用`<Main>b__1`和`<Main>b__2`方法实例化`MulticastDelegate`对象的两个实例，将它们作为`keySelector`和`elementSelector`的输入传递给`Lookup`类:

`public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(
        this IEnumerable<TSource> source,
        Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)  
{
        return (ILookup<TKey, TElement>) Lookup<TKey, TElement>.Create<TSource>(
                source,            **/* Original list */**
                keySelector,       **/* <Main>b__1 */**
                elementSelector,   **/* <Main>b__2 */**
                null);             **/* Comparer */**
}`

*2。步骤 2* :在内部，`Lookup`类的`Create`方法将实例化`Lookup`类的一个实例，该实例将初始化一个类型为`Grouping`的数据结构分组(一个默认大小为 7 的数组)以及`Lookup`类的构造函数，如部分代码所示:

`private Lookup(IEqualityComparer<TKey> comparer)
{
            **/* Code removed */**
            this.groupings = new Grouping<TKey, TElement>[7];
}`

该分组数组最初将保存指定类型的默认值。然后，CLR 将遍历原始列表，并根据`KeySelector`和`ElementSelector`，将迭代的项目添加到 groupings 数组中:

`foreach (TSource local in source)
{
    lookup.GetGrouping(keySelector(local), true).Add(elementSelector(local));
}`

在返回`Create`方法时，CLR 将返回`Lookup`类的实例，它将保存原始序列的查找表。`Lookup`类中`Create`方法的实现代码是:

`internal static Lookup<TKey, TElement> Create<TSource>(
    IEnumerable<TSource> source, Func<TSource, TKey> keySelector,
    Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
{
    Lookup<TKey, TElement> lookup = new Lookup<TKey, TElement>(comparer);
    foreach (TSource local in source)
    {
        lookup.GetGrouping(keySelector(local),  
                           true).Add(elementSelector(local));
    }
    return lookup;
}`

#### 杂项方法

本节探讨了`Zip`方法。

##### 活力

`Zip`方法将指定的函数应用于两个序列的相应元素，产生一个结果序列。该方法遍历两个输入序列，将函数`resultSelector`应用于两个序列的相应元素。该方法返回一系列值，这些值由`resultSelector`返回。如果输入序列不具有相同数量的元素，则该方法组合元素，直到到达其中一个序列的末尾。例如，如果一个序列有三个元素，另一个有四个元素，那么结果序列只有三个元素。此方法通过使用延迟执行来实现。立即返回值是一个存储执行操作所需的所有信息的对象。

`Zip`扩展方法将根据提供的组合逻辑组合两个列表项。查看提供的方法签名，我们可以看到它是`IEnumerable<TFirst>`类型的扩展，并接受`IEnumerable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector`项作为输入:

`public static IEnumerable<TResult> Zip<TFirst, TSecond, TResult>(
    this IEnumerable<TFirst> first, IEnumerable<TSecond> second,
    Func<TFirst, TSecond, TResult> resultSelector)`

因此，第一个和第二个列表的项目将根据`resultSelector` `Func`中提供的组合逻辑被逐项组合以产生一个新的列表。所以你可以在图 12-28 中看到`Zip`方法将组合列表中的每一项。

![images](img/-28.jpg)

***图 12-28。**Zip 方法的基本操作*

从[图 12-28](#fig_12_28) 中可以看到，`Zip`方法将第一个列表中的项目(包含`{1, 2, 3, 4}`)与第二个列表中的项目(包含`{"One","Two","Three","Four"}`)进行组合，组合逻辑为:第一个列表中的项目+ `":\t"` +第二个列表中的项目。清单 12-85 给出了一个使用`Zip`方法的例子。

***清单 12-85。**Zip 方法的例子*

`using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ch12
{
    class Program
    {
        static void Main(string[] args)
        {
            IList<int> firstList = new List<int>()
            {
                1,2,3,4
            };

            IList<string> secondList = new List<string>()
            {
                "One","Two","Three","Four"
            };

            var result = firstList.Zip(secondList, (x, y) => x + ":\t" + y);

            result.ToList().ForEach(x => Console.WriteLine(x));
        }
    }
}`

该程序将产生以下输出:

`1:      One
2:      Two
3:      Three
4:      Four`

Zip 执行方法的内部操作

当 C#编译器找到`Zip`方法时，它将遵循以下步骤:

*1。步骤 1*:C #编译器将使用匿名方法`(x, y) => x + ":\t" + y`构造一个方法`<Main>b__2`。CLR 会将这个`<Main>b__2`方法传递给`MulticastDelegate`类来实例化它的一个实例。C#编译器将`(x, y) => x + ":\t" + y`代码块编译成方法，如[清单 12-86](#list_12_86) 所示。

***清单 12-86。** <主要> b__2 方法内容*

`.method private hidebysig static string  '<Main>b__2'(int32 x,
                                                      string y) cil managed
{
  // code size       22 (0x16)
  .maxstack  3
  .locals init ([0] string CS$1$0000)
  IL_0000:  ldarg.0
  IL_0001:  box        [mscorlib]System.Int32
  IL_0006:  ldstr      ":\t"
  IL_000b:  ldarg.1
  IL_000c:  call       string [mscorlib]System.String::Concat(object,
                                                              object,
                                                              object)
  IL_0011:  stloc.0
  IL_0012:  br.s       IL_0014
  IL_0014:  ldloc.0
  IL_0015:  ret
} // end of method Program::'<Main>b__2'`

*2。步骤 2*:CLR 将把步骤 1 中创建的`MulticastDelegate`的实例传递给`Zip`方法，后者将在内部完成一些基本检查后返回`ZipIterator<TFirst, TSecond, TResult>`实例。`ZipIterator<TFirst, TSecond, TResult>`实例将在其中保存第一个和第二个列表以及`resultSelector`(步骤 1 中创建的`MulticastDelegate`的实例)，如图[图 12-29](#fig_12_29) 所示。

![images](img/-29.jpg)

***图 12-29。**Zip 方法的操作细节*

*3。步骤 3* :因为这个`Zip`扩展方法将使用延迟执行模式执行，每当 CLR 执行`ToList`方法时，它将遍历`ZipIterator`枚举器。在`ZipIterator`枚举器中，CLR 将遍历每个列表，并从每个列表中获取`Current`项。它将把那个`Current`项作为输入传递给`resultSelector` `Func`作为输入。

*4。第四步*:然后`resultSelector`会将提供的每一个条目组合成一个单项(例如，`firstList`的`1`和`secondList`的`One`会组合成`1: One`)并返回。这将持续到两个列表都完成。

在这个迭代过程中，如果一个列表中的条目比另一个少，那么这个方法将只从两个列表中返回相同数量的条目。例如，如果列表`A`有`{A1, B1, C1, D1}`项，而`B`有`{A2, B2, C2}`项，那么结果将基于组合逻辑(`+`)处理，结果 `{A1A2, B1B2, C1C2}.`将从`A`列表中扣除`D1`。清单 12-87 中给出了`Zip`扩展的实现。

***清单 12-87。**实施 Zip 扩展*

`private static IEnumerable<TResult> ZipIterator<TFirst, TSecond, TResult>(
    IEnumerable<TFirst> first,
    IEnumerable<TSecond> second,
    Func<TFirst, TSecond, TResult> resultSelector)
{
    using (IEnumerator<TFirst> iteratorVariable0 = first.GetEnumerator())
    {
        using (IEnumerator<TSecond> iteratorVariable1 = second.GetEnumerator())
        {
            while (iteratorVariable0.MoveNext() &&
                   iteratorVariable1.MoveNext())
            {
                yield return resultSelector(
                    iteratorVariable0.Current,
                    iteratorVariable1.Current);
            }
        }
    }
}`

### 总结

在这一章中，我们已经学习了 C#中的 Linq，以及 Linq 的`Enumerable`类提供的不同扩展方法。本章中讨论的所有方法都是基于查询语法委派的。对每个扩展方法的内部操作的检查，提供了对这些方法的更好理解，并将帮助您更有效地使用这些方法。下一章将讨论异常管理。