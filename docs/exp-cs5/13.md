# 十三、异常管理

本章将讨论中的异常和异常处理 .NET 使用 C#。本章从异常的定义开始，然后解释 CLR 如何在中管理异常 .NET，讨论方法说明表中的异常处理信息以及 CLR 如何使用这些异常处理信息来管理异常。然后我将讨论异常处理。然后，本章通过讨论 CLR 如何在整个方法调用链中使用 throw 语句以及异常匹配来管理异常，从而探究堆栈覆盖。

### 什么是例外？

程序由一系列指令组成，这些指令用于根据给定的数据(如果有的话)执行特定的操作，以产生操作的预期结果。如果在执行时间内，指令不能根据所提供的数据进行操作，它将为该操作引发一个错误或异常，让用户知道这种意外的行为。对于系统来说，引发操作异常有许多可能的情况。在系统中，应该有一个适当的机制来处理这种意外的行为。在我们继续之前，让我们检查一下清单 13-1 中的例子，以便更好地理解 .NET 应用。

***清单 13-1。**除法运算的一个例子*

`using System;

namespace Ch13
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 10, b = 5;
            Division div = new Division();
            Console.WriteLine("{0}/{1}={2}", a, b, div.Divide(a, b));
        }

        public class Division
        {` `            public int Divide(int a, int b)
            {
                return a / b;
            }
        }
    }
}`

[清单 13-1](#list_13_1) 中的程序正在根据通过参数`a`、`b`传递的数据进行除法运算。例如，如果`a = 10`和`b = 5`，那么它将返回 2 作为运算结果，以此类推。让我们用[表 13-1](#tab_13_1) 中给出的一组值来测试[清单 13-1](#list_13_1) 。

![images](img/.jpg)

这个程序在使用值`(10, 5)`和`(100, 50).`时将正常工作。当这个程序使用`(100, 0)`作为输入来执行除法运算时，它将不起作用，因为任何被零除的东西都返回无穷大。因此，在运行时，CLR 将无法处理无穷大，因此它将发出一个通知，说明这种意外行为的原因。这种行为被称为*一种类型的例外行为*，并且在的角度来看 .NET，它是一个*异常*。例如，当你以值`(100, 0)`作为输入运行[清单 13-1](#list_13_1) 中的除法程序时，CLR 将产生一个错误通知来描述除法程序的意外行为，如图[图 13-1](#fig_13_1) 所示。

![images](img/-01.jpg)

***图 13-1。**清单 13-1T5[中给出的除法程序出现异常的例子](#list_13_1)*

因此，异常类型*已处理*或*未处理*是定义中程序异常或意外行为的关键概念 .NET，如图[图 13-1](#fig_13_1) 所示。当 CLR 用值 100 和 0 执行来自[清单 13-1](#list_13_1) 的除法程序时，它不能处理该操作，它向显示关于该程序意外行为的详细信息，让用户知道该程序的意外行为。

英寸 NET 中，您使用异常处理机制来管理应用的意外行为。这种机制基于一个简单的规则，例如，将相关代码标记为受保护块，并定义一些与受保护块相关联的处理程序，当受保护块引发任何意外行为时，这些处理程序将被激活(即，处理程序块将处理应用的任何意外行为)。可以使用`try`语句声明受保护的块，使用`catch`和`finally`语句声明处理程序块。

当异常的实例被实例化时，它包含关于异常的信息。在运行时，CLR 将程序控制从引发异常的位置转移到与被实例化的异常对象类型最匹配的程序的适当处理程序块。CLR 执行匹配的处理程序块。如果 CLR 在方法中找不到任何匹配的处理程序块，程序控制将返回到方法的调用方，以查找相关的处理程序块。它将继续搜索，直到方法链的顶端。如果没有找到处理程序块，CLR 会将该异常记录到 Windows 日志中(可以通过事件查看器看到)。它会将程序控制留给 Windows 错误报告，该报告还会将其写入 Windows 日志。

### 例外和 .NET 框架

英寸 NET 中，`Exception`类是在`mscorlib.dll`程序集的`System`命名空间中定义的，如图 13-2 中的[所示。](#fig_13_2)

![images](img/-02.jpg)

***图 13-2。**系统。mscorlib.dll 汇编中的异常类*

`Exception`类有如下定义:

`public class Exception : ISerializable, _Exception
{
    public Exception()                                                    {}
    public Exception(string message)                                      {}
    protected Exception(SerializationInfo info, StreamingContext context) {}
    public Exception(string message, Exception innerException)            {}` `    public virtual Exception GetBaseException()                           {}
    public virtual void
        GetObjectData(SerializationInfo info, StreamingContext context)   {}
    public Type GetType()                                                 {}
    public override string ToString()                                     {}
    public virtual IDictionary Data                                       {}
    public virtual string HelpLink                                        {}
    public Exception InnerException                                       {}
    public virtual string Message                                         {}
    public virtual string Source                                          {}
    public virtual string StackTrace                                     {}
    public MethodBase TargetSite                                          {}
}`

`System.Exception`是所有其他`Exception`类的基类，例如`DivisionByZeroException`或`NullReferenceException`。`Exception`类的定义表明，它是通过`ISerializable`和`_Exception`接口(在`mscorlib.dll`的`System.Runtime.InteropService`名称空间中定义)实现的，并且继承自`System.Object`(中的所有类都是如此。网)。`_Exception`接口包含了`Exception`类的大多数重要属性，这将在下一节讨论。

#### _ 异常接口

让我们检查一下`_Exception`接口，如清单 13-2 中的[所示，它是通过`ildasm.exe`从`mscorlib.dll`中提取的。](#list_13_2)

***清单 13-2。**_ Exception 接口的定义*

`.class public interface abstract auto ansi _Exception
{
**    /* Code removed */**
**    /* Defined property in the _Exception interface*/**
    .property instance string HelpLink                                             {}
    .property instance class System.Exception InnerException                       {}
    .property instance string Message                                              {}
    .property instance string Source                                               {}
    .property instance string StackTrace                                           {}
    .property instance class System.Reflection.MethodBase TargetSite               {}
}`

`System.Exception`类有几个重要的属性，用于在 CLR 引发异常时管理异常细节。在[表 13-2](#tab_13_2) 中，这些属性显示了 CLR 在哪里存储这些属性来管理异常。

T2】

[表 13-2](#tab_13_2) 展示了`that _message`、`_stackTraceString`、`_remoteStackTraceString`、`_helpURL`、`_source`、`_innerException`、`_exceptionMethod`和`_data`是`Exception`类的内部字段，CLR 使用这些字段来封装与引发的异常相关的所有信息。

#### C# 编译器如何处理编译时的异常

在 C# 程序的编译时，C# 编译器为程序的类中定义的每个方法创建一个`Method State Description`表。在`Method State Description`表中，编译器设置一个空条目或者可能是一个`Exception Handling Information Block`的数组块(取决于代码中`try...catch`块的存在)，`Method State Description`表中的每个方法都将与该类的`Method`表链接。[图 13-3](#fig_13_3) 展示了`Method`表、`Method State Description`表和`Exception Handling Information Block`或`Exception Entry`表之间的关联。

![images](img/-03.jpg)

***图 13-3。**异常对象由 C# 编译器处理*

[图 13-3](#fig_13_3) 展示了 C# 编译器如何将异常处理信息(如果方法中的代码块已经使用`try...catch`保护)包含在类的方法的`Method State Description`表中。在`Method State Description`表中，将会有一个空条目或者一个异常条目的数组。这些项目(异常条目)中的每一个都包含关于受保护、受保护或`try`块、关联过滤器及其处理程序的信息，例如`catch`处理程序、`filter`处理程序、`finally`处理程序或`fault`处理程序。

英寸 NET 中，类型(类)的每个方法都可能有一个异常条目(如果代码中有一个`try...catch`块，或者如果代码中没有定义`try...catch`块，则什么都没有)，它将包含关于该方法的异常处理信息。使用`trystart`和`trylength`属性定义`protected`或`guarded`块，使用`handlerstart`和`handlerlength`定义过滤器/处理程序块。表 13-3 给出了程序中处理程序数据结构和不同异常处理程序区域的定义。

![images](img/.jpg)

下一节将探讨 CLR 如何在运行时处理异常。

#### 探索运行时的异常细节

让我们做一些研究来确定 C# 编译器如何生成和使用`Method State Description`表来存储程序中使用的异常处理信息。您可以使用`windbg.exe`来探索在[清单 13-3](#list_13_3) 中给出的代码中使用的方法的异常处理信息。

***清单 13-3。**一个例子演示一个类中的方法描述表信息*

`using System;

namespace Ch13
{
    class MainClass
    {
        static void Main(string[] args)
        {
            ExceptionInMethodStateDescription exInMSD =
                new ExceptionInMethodStateDescription();
            exInMSD.MethodOne();
            exInMSD.MethodTwo();
            exInMSD.MethodThree();
        }
    }

    public class ExceptionInMethodStateDescription
    {
        public void MethodOne()
        {
            try                                                                   {}
            catch (IndexOutOfRangeException indexOutOfRangeException)             {}
        }
        public void MethodTwo()
        {
            try                                                                   {}
            catch (ArgumentException argumentException)                           {}
        }
        public void MethodThree()
        {
            try                                                                   {}
            catch (Exception exception)                                           {}
        }
    }
}`

当 C# 编译器编译清单 13-3 中给出的代码时，`MainClass`和`ExceptionInMethodStateDescription`类将有一个`Method`表。`MainClass`的`Method`表将保存`MainClass`和`ExceptionInMethodStateDescription`类的`Method Description`表信息。`MethodDescription`表中方法的数量取决于类中定义的方法数量。来自该类的`Method Description`表中的这些方法中的每一个都可以用于确定在[清单 13-3](#list_13_3) 中给出的代码中演示的方法的相关异常处理信息。

让我们使用`windbg.exe`来调试可执行文件(由[清单 13-3](#list_13_3) 产生),以探索 C# 编译器在编译时定义的异常处理信息。

从[清单 13-3](#list_13_3) 产生的可执行文件(`Ch13.exe`)可以在`windbg.exe`中使用，以确定关于`Method`表和方法描述的相关信息，并找出异常处理信息是如何存储在可执行程序的方法描述表中的(例如，`Ch13.exe`)。当您使用`windbg.exe`运行可执行程序时，您会发现以下信息。

> 1.  You will extract `Method Table` addresses of `MainClass` and `ExceptionInMethodStateDescription` classes from the executable file.
> 2.  You will extract the `Method Description Table` information of each method defined in the type, and use the `Method Table` address information extracted in step 1.
> 3.  Using `Method Description Address` obtained in step 2, you will get the exception handling information (if any) related to each method defined in the class used in [Listing 13-3](#list_13_3) .

让我们使用`windbg.exe`程序调试可执行文件。

> *1。* *第一步*:使用`windbg.exe`中的`Name2EE`命令提取`MainClass`和`ExceptionInMethodStateDescription`的`MethodTable`地址。

`!Name2EE Ch13.exe Ch13.MainClass
!Name2EE Ch13.exe Ch13.ExceptionInMethodStateDescription`

这些命令将返回此处显示的`MainClass`和`ExceptionInMethodStateDescription`类的`MethodTable`地址信息(在本地运行时，输出可能会有所不同):

`Module:         00142e9c
Assembly:       Ch13.exe
Token:          02000003
**MethodTable:    00143834**
EEClass:        0014145c
Name:           Ch13.MainClass

Module:         00142e9c
Assembly:       Ch13.exe
Token:          02000004
**MethodTable:    001438b8**
EEClass:        001414c8
Name:           Ch13.ExceptionInMethodStateDescription`

`MainClass`的`MethodTable`地址是 00143834，001438b8 是在步骤 2 中用于确定`MainClass`和`ExceptionInMethodStateDescription`类的关联`Method Description`表信息的`ExceptionInMethodStateDescription`类的地址。

> *2。步骤 2* :使用`windbg.exe`中的`dumpmt`命令，使用步骤 1 中的`MethodTable`地址检索`MainClass`和`ExceptionInMethodStateDescription`类的`Method Description`表信息。您可以使用 00143834 作为`MainClass`的`MethodTable`的地址，来确定`MainClass`中定义的每个方法的方法描述表(在本地运行时，输出可能会有所不同)。

`**!dumpmt -MD 00143834**
EEClass:        0014145c
Module:         00142e9c
Name:           Ch13.MainClass
mdToken:        02000003
File:           J:\Book\ExpertC#2012\SourceCode\BookExamples\Ch13\bin\Debug\Ch13.exe
BaseSize:               0xc
ComponentSize:          0x0
Slots in VTable:        6
Number of IFaces in IFaceMap: 0
--------------------------------------
MethodDesc Table
Entry           MethodDesc      JIT      Name
54efa7e0        54cd4934        PreJIT   System.Object.ToString()
54efe2e0        54cd493c        PreJIT   System.Object.Equals(System.Object)
54efe1f0        54cd495c        PreJIT   System.Object.GetHashCode()
54f81600        54cd4970        PreJIT   System.Object.Finalize()
0014c015        0014382c        NONE     Ch13.MainClass..ctor()
002a0070        **00143820**        JIT      Ch13.MainClass.Main(System.String[])`

这个输出表明`MethodDesc Table`地址 00143820 是用于`MainClass`类的`Main`方法，以此类推。

此外，您可以使用 001438b8 作为`ExceptionInMethodStateDescription`的`MethodTable`的地址，来确定在`ExceptionInMethodStateDescription`类中定义的每个方法的方法描述表(当您在本地运行它时，输出可能会有所不同)。

`**!dumpmt -MD 001438b8**
EEClass:        001414c8
Module:         00142e9c
Name:           Ch13.ExceptionInMethodStateDescription
mdToken:        02000004
File:           J:\Book\ExpertC#2012\SourceCode\BookExamples\Ch13\bin\Debug\Ch13.exe
BaseSize:               0xc
ComponentSize:          0x0
Slots in VTable:        8
Number of IFaces in IFaceMap: 0
--------------------------------------
MethodDesc Table
Entry     MethodDesc  JIT       Name
54efa7e0  54cd4934    PreJIT    System.Object.ToString()
54efe2e0  54cd493c    PreJIT    System.Object.Equals(System.Object)
54efe1f0  54cd495c    PreJIT    System.Object.GetHashCode()
54f81600  54cd4970    PreJIT    System.Object.Finalize()
002a00f0  001438b0    JIT       Ch13.ExceptionInMethodStateDescription..ctor()
002a0130  **0014388c**    JIT       Ch13.ExceptionInMethodStateDescription.MethodOne()
002a01a0  **00143898**  JIT         Ch13.ExceptionInMethodStateDescription.MethodTwo()
002a0210  **001438a4**    JIT       Ch13.ExceptionInMethodStateDescription.MethodThree()`

输出显示对于`ExceptionInMethodStateDescription`类，`MethodOne`、`MethodTwo`和`MethodThree`的方法描述表地址分别是 0014388c、00143898 和 001438a4，这将在后面的步骤 3 中用于确定与`ExceptionInMethodStateDescription`类的每个方法相关联的异常处理信息。

> *3。步骤 3* :使用各自的方法描述表地址获取与`MainClass`和`ExceptionInMethodStateDescription`类相关联的每个方法的异常处理块信息。例如，00143820 是步骤 2 中检索到的`MainClass`的`Main`方法的方法描述表地址。

`**!EHInfo 00143820**`

`EHInfo`命令将返回关于`MainClass`类的`Main method`的异常处理块信息，如图 13-4 中的[所示。](#fig_13_4)

![images](img/-04.jpg)

***图 13-4。**Main class 中 Main 方法的异常处理信息*

[图 13-4](#fig_13_4) 显示，在`Main`方法中，没有像[清单 13-3](#list_13_3) 中那样，由 C# 编译器在编译时关联的异常处理块信息。`Main`方法没有在`MainClass`中定义任何异常处理代码(`try...catch`块)。对于`ExceptionInMethodStateDescription`类，0014388c、00143898 和 001438a4 分别是在步骤 2 中检索到的`MethodOne`、`MethodTwo`和`MethodThree`的地址。

`!EHInfo 0014388c
!EHInfo 00143898
!EHInfo 001438a4`

`EHInfo`命令将返回`ExceptionInMethodStateDescription`类的`MethodOne`、`MethodTwo`和`MethodThree`的异常处理块信息，如图 13-5 中[所示。](#fig_13_5)

![images](img/-05.jpg)

***图 13-5。**ExceptionInMethodStateDescription 类*的方法一、方法二和方法三的异常处理信息

[图 13-5](#fig_13_5) 展示了 C# 编译器为`MethodOne`添加了异常处理信息，其中`IndexOutOfRangeException`为异常类型，`MethodTwo`为异常类型，`ArgumentException`为异常类型，`Exception`为`ExceptionInMethodStateDescription`类的`MethodThree`添加了异常类型。

在 .NET 应用中，如果你在一个类的方法中定义了任何异常处理程序块，那么 C# 编译器会为这个类中定义的每个方法添加一个异常处理信息块，如图[图 13-6](#fig_13_6) 所示。它显示了与异常处理信息相关的`MainClass`和`ExceptionInMethodStateDescription`类的每个方法。

![images](img/-06.jpg)

***图 13-6。**main class 和 ExceptionInMethodStateDescription 类的异常处理信息*

### 中的异常处理。网

当程序中发生异常时，CLR 将以三种方式之一处理该异常:

> *   It searches the array of exception handling information associated with this method (if it exists) to determine the relevant catch block or handler block. If CLR finds a matching method in the current method, it will execute the code in the handler block.
> *   Otherwise, it will continue to search for the handler blocks related to the calling method, and so on.
> *   Finally, if the CLR does not find any matching exception handling blocks in the program, it will record the stack trace information contained in the exception to the Windows log and stop the program, as shown in Figure [and Figure 13-7](#fig_13_7) . If an exception occurs at `MethodA`, the CLR will search for exception handling information from `MethodA` and continue to search `MethodB` to `MethodC` until any information is found. If an exception is found, it will be executed and returned from the program, or the exception information will be dumped into the Windows log as an unhandled exception.

![images](img/-07.jpg)

***图 13-7。**从方法状态到方法状态的异常处理信息搜索*

到目前为止，我们已经看到了 CLR 在程序中异常发生的地方处理异常的方式。在很多情况下，您不希望在异常发生的地方处理异常，而是希望将该异常信息传递回该方法的调用方。[图 13-8](#fig_13_8) 显示了当一个方法调用序列(`MethodA`调用`MethodB`而 MethodB 调用`MethodC`)发生时会发生什么。

![images](img/-08.jpg)

***图 13-8。**发生异常时方法调用冒泡*

让我们修改[清单 13-1](#list_13_1) 中的代码来做以下事情:

> *   The exception is handled by the method itself.
> *   Exception handled by CLR.

因此，这个修改后的 division 程序的第一个版本将使用异常处理程序块自己处理异常，第二个版本将不会自己处理异常，而是让应用或窗口处理异常，如清单 13-4 所示。

***清单 13-4。**第一版异常处理*

`**/* First version of the Exception handling */**

using System;

namespace Ch13
{
    class MainClass
    {
        static void Main(string[] args)
        {
            Division div = new Division();
            div.Divide(100, 0);
        }
    }
    public class Division
    {
        public int Divide(int a,
            int b)
        {
            try
            {
                return a / b;
            }
**            /* Exception is handled in here by catching all the exception. */**
            catch (Exception exception)
            {
                Console.WriteLine(
                    exception.StackTrace);
                 return -1;
            }
        }
    }
}`

这将是异常处理的第二个版本:

`using System;

namespace Ch13
{
    class MainClass
    {
        static void Main(string[] args)
        {
            Division div = new Division();
            div.Divide(100, 0);
        }
    }

    public class Division` `    {
        public int Divide(int a,
            int b)
        {
            return a / b;
        }
    }
}`

当来自清单 13-4 的[程序的第一个版本被编译时，C# 编译器将为`Division`类的`Divide`方法的`Method State Description`表创建一个异常条目。在执行](#list_13_4)[清单 13-4](#list_13_4) 中的第一个程序时，如果在`Divide`方法中出现任何异常，CLR 将搜索该方法的`Method State Description`表，以确定异常处理程序块信息(如果存在的话)。它将执行它，并通过访问异常对象显示异常的`StackTrace`信息，返回并完成程序执行，如图[图 13-9](#fig_13_9) 所示。

![images](img/-09.jpg)

***图 13-9。**程序自身处理的异常*

对于[清单 13-4](#list_13_4) 中程序的第二个版本，编译器不会为`Division`类的`Divide`方法的`Method State Description`表创建任何 ExceptionEntry(它会为异常处理创建一个空数组)。此方法没有定义的异常处理程序。在执行清单 13-4 中的第二个程序时，如果出现任何异常，CLR 将在`Method State Description`表中搜索该方法，但不会找到与之相关的异常处理程序。该程序将崩溃，并让 Windows 通过将异常信息写入事件查看器来处理该异常，如图 13-10 所示。

![images](img/-10.jpg)

***图 13-10。** Windows 登录事件查看器*

从[图 13-10](#fig_13_10) 可以看到，CLR 将异常详细信息写入 Windows 日志，Windows 错误报告也通过将异常详细信息写入 Windows 日志来处理它。

#### 异常处理和冒泡

如图 13-8 所示，CLR 将搜索方法链中的每一个方法，以匹配一个合适的异常处理程序块。如果找到一个，它将执行它或者继续搜索。[清单 13-5](#list_13_5) 给出了一个这样的例子。

***清单 13-5。**薪资计算示例*

`using System;

namespace Ch13
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Salary salary = new Salary();
                salary.CalculateSalary(10, 0);` `            }
            catch (Exception exception)
            {
                Console.WriteLine("An error occured.");
            }
        }
    }

    public class Salary
    {
        public int CalculateSalary(int week, int rate)
        {
            try
            {
                Calculator calculator = new Calculator();
                return week * calculator.Divide(week, rate);
            }
            catch (DivideByZeroException divideByZeroException)
            {
                throw;
            }
        }
    }

    public class Calculator
    {
        public int Divide(int a, int b)
        {
            try
            {
                return a / b;
            }
            catch
            {
                throw;
            }
        }
    }
}`

在[清单 13-5](#list_13_5) 中，`Calculator`和`Salary`类中定义的每个处理程序块通过将异常细节从`Divide`方法返回到`Salary`类的`CalculateSalary`方法来处理异常，最终返回到`Program`类的`Main`方法。这整个概念被称为 *bubble up* ，其中异常一直返回到引发异常的方法的调用者。[图 13-11](#fig_13_11) 说明了使用运行时提取的堆栈跟踪信息的冒泡概念，而[清单 13-5](#list_13_5) 中的代码正在执行。

![images](img/-11.jpg)

***图 13-11。**异常冒泡*

当异常发生在[清单 13-5](#list_13_5) 中`Calculator`类的`Divide`方法中时，CLR 产生了一个`DivideByZeroException`类型的实例，详细信息如图[图 13-11](#fig_13_11) 所示。然后 CLR 将这些异常细节传递回`Salary`类的`CalculateSalary`方法。CLR 修改`StackTrace`来组合它从 divide 方法的`Exception`对象 DivideByZeroException 获得的信息，并将其传递回`Program`类的`Main`方法。CLR 将修改`Exception`对象的`StackTrace`来捕获关于异常的最新信息，并像定义了处理程序块一样处理异常。

当 CLR 执行清单 13-5 中的[程序时，程序指针将移动到`Calculator`类的`Divide`方法中。一旦引发异常，CLR 就会将该异常一路冒泡到`Program`类的`Main`方法，这可以通过使用`windbg.exe`查看该调用的堆栈跟踪来看到，如下所示:](#list_13_5)

`**0:000> !clrstack -a**
OS Thread Id: 0xd08 (0)
Child SP IP       Call Site
0039ee08 00400295 Ch13.Calculator.Divide(Int32, Int32) [J:\Book\ExpertC#2012\SourceCode\
BookExamples\Ch13\Program.cs @ 40]
    PARAMETERS:
        this (0x0039ee10)       = 0x0153b688
        a (0x0039ee0c)          = 0x0000000a
        b (0x0039ee3c)          = 0x00000000
    LOCALS:` `        0x0039ee08              = 0x00000000

0039ee40 004001d4 Ch13.Salary.CalculateSalary(Int32, Int32) [J:\Book\ExpertC#2012\SourceCode
\BookExamples\Ch13\Program.cs @ 28]
    PARAMETERS:
        this (0x0039ee60)        = 0x0153b67c
        week (0x0039ee5c)        = 0x0000000a
        rate (0x0039ee8c)        = 0x00000000
    LOCALS:
        0x0039ee4c               = 0x0153b688
        0x0039ee48               = 0x00000000
        0x0039ee58               = 0x00000000

0039ee90 004000d7 Ch13.Program.Main(System.String[]) [J:\Book\ExpertC#2012\SourceCode\
BookExamples\Ch13\Program.cs @ 12]
    PARAMETERS:
        args (0x0039eea0)       = 0x0153b63c
    LOCALS:
        0x0039ee9c              = 0x0153b67c
        0x0039ee98              = 0x00000000

0039f0fc 5a8a21db [GCFrame: 0039f0fc]`

这个`windbg.exe`输出显示了 CLR 执行清单 13-5 中的程序时的堆栈信息。每个方法的栈都是一个接一个堆叠起来的，例如，`CalculateSalary`在`Main`方法的上面，`Divide`在`CalculateSalary`方法的上面。如果出现任何异常，例如在`Divide`方法中，CLR 将在该方法中搜索异常处理信息，如果找不到，它将在它们堆叠时搜索`CalculateSalary`和最后的`Main`。[图 13-12](#fig_13_12) 展示了`Calculator`类的`Divide`方法发生异常后的异常搜索和冒泡。

![images](img/-12.jpg)

***图 13-12。**代码*中出现异常的例子

[图 13-12](#fig_13_12) 展示了程序指针已经从`Calculator`类的`Divide`方法回到了`Program`类的`Main`方法的异常处理程序部分。

### 受保护的块

使用关键字`try`声明受保护或受保护的块；使用`catch`或`finally`关键字定义处理程序块。catch 块是使用`catch`关键字声明的。这指定了子句将要处理的异常对象的类型以及处理程序代码本身。finally 块是使用`finally`关键字声明的。使用这些`try`、`catch`和`finally`语句，您可以处理 .NET 应用。使用. NET 程序时`try...catch`语句的一般结构如图[图 13-13](#fig_13_13) 所示。

![images](img/-13.jpg)

***图 13-13。**类*中定义的处理程序和保护块

从[图 13-13](#fig_13_13) 可以看到，保护块是用`try`块定义的，`handler`块是用`catch`和`finally`块定义的。清单 13-6 中显示了`protected`和`handler`程序块的声明示例。

***清单 13-6。**试一试的例子。网*

`using System;

namespace Ch13
{
    class MainClass
    {
        static void Main(string[] args)
        {
            ExampleOfExceptionUsage eeu = new ExampleOfExceptionUsage();
        }
    }

    public class ExampleOfExceptionUsage
    {` `        public void DoSomething()
        {
            try
            {
**                /* Do some operation */**
            }

            catch (ArgumentException argumentException)
            {
**                /* handle ArgumentException exception */**
            }

            catch (IndexOutOfRangeException indexOutOfRangeException)
            {
**                /*handle IndexOutOfRangeException */**
            }

            catch (Exception exception)
            {   
**                /* handle exception in general in here if ArgumentException**
**                 * and IndexOutOfRangeException did not occurred. */**
            }

            finally
            {
                Console.WriteLine("It will execute all the time");
            }
        }
    }
}`

在[清单 13-6](#list_13_6) 中的代码中，`try`块是我们需要放置整个操作块的地方，它将完成方法的实际功能操作。这被称为受保护或受保护的块。在受保护的块中，如果有任何未提供参数的情况，数组的索引不在范围内，或任何其他类型的意外行为，程序将使用称为处理程序块的`catch`块或`finally`块来处理该意外行为。然而，不管方法中引发的异常行为如何，`finally`块都将执行。为了解释[清单 13-6](#list_13_6) 中的代码是如何工作的，让我们看看[清单 13-7](#list_13_7) 中反编译的 IL 代码，使用`ildasm.exe`从[清单 13-6](#list_13_6) 产生的可执行文件中提取。

***清单 13-7。**清单 13-6T5[中定义的 DoSomething 方法的 IL 代码](#list_13_6)*

`.method public hidebysig instance void  DoSomething() cil managed
{
  // Code size       39 (0x27)
  .maxstack  1
  .locals init (
    [0] class [mscorlib]System.ArgumentException
              argumentException,
    [1] class [mscorlib]System.IndexOutOfRangeException
              indexOutOfRangeException,` `    [2] class [mscorlib]System.Exception
              exception)
  IL_0000:  nop
**  .try**
  {
    .try
    {
      IL_0001:  nop
      IL_0002:  nop
      IL_0003:  leave.s    IL_0014
    }  // end .try
    catch [mscorlib]System.ArgumentException
    {
      IL_0005:  stloc.0
      IL_0006:  nop
      IL_0007:  nop
      IL_0008:  leave.s    IL_0014
    }  // end handler
    catch [mscorlib]System.IndexOutOfRangeException
    {
      IL_000a:  stloc.1
      IL_000b:  nop
      IL_000c:  nop
      IL_000d:  leave.s    IL_0014
    }  // end handler
    catch [mscorlib]System.Exception
    {
      IL_000f:  stloc.2
      IL_0010:  nop
      IL_0011:  nop
      IL_0012:  leave.s    IL_0014
    }  // end handler
    IL_0014:  nop
    IL_0015:  leave.s    IL_0025
  }  // end .try

  **finally**
  {
    IL_0017:  nop
    IL_0018:  ldstr      "It will execute all the time"
    IL_001d:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0022:  nop
    IL_0023:  nop
    IL_0024:  endfinally
  }  // end handler

  IL_0025:  nop
  IL_0026:  ret
} // end of method ExampleOfExceptionUsage::DoSomething`

在这段 IL 代码中，可以看到有两块`try`...`catch`，一个用于内部执行块和异常处理程序块，另一个用于外部`try`...`catch`，由`finally`块执行，不管是否出现异常。让我们仔细分析代码，以真正理解这个 IL 代码中发生了什么。

如果程序中没有出现意外行为，CLR 将执行 IL 代码，如下所述:

> *   The program will execute the IL instruction from the label `IL_0000` until `IL_0003`, where the instruction `leave.s` `IL_0014` will be found, which will move the program control to the label `IL_0014` and find the surrounding `finally` block. However, no, so it will move the program control to the `IL_0014` tab.
> *   The program control will move to `IL_0014` and continue to `IL_0015`, where the instruction `leave.s IL_0025` will be found. When executing the `leave.s IL_0025` instruction, it will try to determine whether there are any matching `finally` blocks. In this case, there is one, so it will execute that first, then move the program pointer to the `IL_0025` tab and continue the program from there.

当程序中出现异常时，CLR 将执行上述 IL 代码，如下所述:

> *   Execute the IL instruction from the tag `IL_0000` of the program until `IL_0003`. When the instructions from `IL_0000` to `IL_0003` are being executed, if the CLR causes any unexpected behavior, it will instantiate a related exception object and try to determine whether any matching handler part is accepting the type of exception object that the CLR is trying to match. If so, the program will move to that point. For example, if the CLR instantiates an object of `ArgumentException`, the program pointer will move to `IL_0005` and start executing instructions from that point to `IL_0008`. In this position, the CLR will find the `leave.s IL_0014` instruction, and then find the relevant `finally` block from here to execute, or move the program control to `IL_0014`. Or, if the matching exception object is not defined in the exception handler part of the program, it will execute the `catch` (`Exception exception`) handler part and continue execution from there.
> *   When the program finishes executing the processing section of the program, it will continue to execute the instruction and find the `IL_0015: leave.s IL_0025` instruction. The `leave.s` instruction will try to determine whether there is any matching `finally` block. If so, it will first execute the block, then move the program pointer to `IL_0025` and continue the program from there.

在这两种情况下，无论异常处理程序的`finally`块如何执行，CLR 都将结束执行`IL_0025`和`IL_0026`标签。

### 投掷和再投掷

C# 代码中的`throw`语句和 C# 编译器生成的`rethrow` IL 指令在 .NET 应用来重新引发异常。抛出和再抛出指令可以定义为:

> `throw`
> 
> *   `rethrow` instruction is allowed in the body of `catch` handler, and the exception it throws is the same as the exception it catches. `rethrow` The IL instruction does not change the stack trace in the object.

到目前为止给出的所有示例都使用了 CLR 在执行程序时引发的异常来确定运行程序时没有预料到的任何异常行为。让我们看看如何使用`throw`和`rethrow`语句在程序中引发异常，这在[清单 13-8](#list_13_8) 和[清单 13-9](#list_13_9) 中有演示。

***清单 13-8。**Throw 语句的例子*

`using System;

namespace Ch13
{
    class Program
    {
        static void Main(string[] args)
        {
            throw new Exception("An exception object");
            Console.WriteLine("This will never execute.");
        }
    }
}`

在执行这个程序时，CLR 创建一个带有`An exception object`字符串文字的`Exception`类型的实例。使用`throw`指令，CLR 使用异常对象引发一个异常，实例化一个`Exception`类型的实例。如果您从使用`.NETReflector`程序生成的[清单 13-8](#list_13_8) 中的程序可执行文件中检查以下 IL 代码，您将看到 C# 编译器使用`throw` IL 指令抛出异常，如[清单 13-9](#list_13_9) 所示。

***清单 13-9。** IL 使用 Throw 语句时的代码*

`.class private auto ansi beforefieldinit Program
    extends [mscorlib]System.Object
{
    .method public hidebysig specialname rtspecialname instance void
        .ctor() cil managed                                                {}

    .method private hidebysig static void Main(string[] args) cil managed
    {
        .entrypoint
        .maxstack 8
        L_0000: nop
        L_0001: ldstr "An exception object"
        L_0006: newobj instance void [mscorlib]System.Exception::.ctor(string)

**        /* CLR will raise an Exception using the exception instance**
**         * created in L_0006*/**
        L_000b: throw
    }
}`

在 IL 代码中，`L_000b`标签有`throw` IL 指令，它将指示程序抛出在`L_0006`标签中创建的异常实例。另一方面，`rethrow`不能在 C# 代码中直接使用，或者它不是 C# 关键字，因为它是一条 IL 指令，当编译器为异常处理块编译 C# 代码的特定模式时，它将由 C# 编译器生成，如清单 13-10 中的[所示。](#list_13_10)

***清单 13-10。**除法运算的一个例子*

`using System;

namespace Ch13
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                ExampleOfRethrow();
            }
            catch (Exception exception)
            {
                Console.WriteLine(exception.StackTrace);
            }
        }

        static void ExampleOfRethrow()
        {
            try
            {
                int a = 10, b = 0;
                var result = a / b;
            }
            catch
            {
                throw;
            }
        }
    }
}`

在[清单 13-10](#list_13_10) 中，你会看到在`handler`块中，除了通过使用这个方法的调用者要处理的`throw`语句来捕获异常对象和释放异常之外，没有做任何事情。[清单 13-10](#list_13_10) 的可执行文件的[清单 13-11](#list_13_11) 中显示的反编译 IL 代码演示了 C# 编译器如何使用`rethrow`指令重新抛出现有的异常。

***清单 13-11。** IL 代码为[清单中的代码 13-10](#list_13_10)T5】*

`.class private auto ansi beforefieldinit Ch13.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main(string[] args) cil managed` `{
    .entrypoint
    // Code size       30 (0x1e)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Exception exception)
    IL_0000:  nop
    .try
    {
      IL_0001:  nop
      IL_0002:  call       void Ch13.Program::ExampleOfRethrow()
      IL_0007:  nop
      IL_0008:  nop
      IL_0009:  leave.s    IL_001c

    }  // end .try
    catch [mscorlib]System.Exception
    {
      IL_000b:  stloc.0
      IL_000c:  nop
      IL_000d:  ldloc.0
      IL_000e:  callvirt   instance string  
                [mscorlib]System.Exception::get_StackTrace()
      IL_0013:  call void [mscorlib]System.Console::WriteLine(string)
      IL_0018:  nop
      IL_0019:  nop
      IL_001a:  leave.s    IL_001c

    }  // end handler
    IL_001c:  nop
    IL_001d:  ret
  } // end of method Program::Main

  .method private hidebysig static void  ExampleOfRethrow() cil managed
  {
    // Code size       20 (0x14)
    .maxstack  2
    .locals init ([0] int32 a,
             [1] int32 b,
             [2] int32 result)
    IL_0000:  nop
    .try
    {
      IL_0001:  nop
      IL_0002:  ldc.i4.s   10
      IL_0004:  stloc.0
      IL_0005:  ldc.i4.0
      IL_0006:  stloc.1
      IL_0007:  ldloc.0
      IL_0008:  ldloc.1

**      /* The CLR does the div operation**` `**       * 1\. if successful then it will store the result at position**
**       * 2 of method stack 2\. Or otherwise move the execution in IL_00e */**
      IL_0009:  div

      **/*It stores the result at position 2 of method stack */**
      IL_000a:  stloc.2

      IL_000b:  nop
      IL_000c:  leave.s    IL_0012

    }  // end .try
    catch [mscorlib]System.Object
    {
**      /* If any exception raised by the CLR while doing the div operation**
**       * it creates an Exception (Or relevant type) object with the**
**       * exception details on the Heap and put that exception object**
**       * reference on top of the Evaluation Stack. Following pop**
**       * instruction loads that exception object from the Evaluation Stack and**
**       * rethrow it inIL_0010*/**
      IL_000e:  pop

      IL_000f:  nop

**      /* This rethow instruction does not reset the stack trace of**
**       * the original exception object*/**
      IL_0010:  rethrow

    }  // end handler
    IL_0012:  nop
    IL_0013:  ret
  } // end of method Program::ExampleOfRethrow

  .method public hidebysig specialname rtspecialname
          instance void  .ctor() cil managed
  {
**    /* code removed */**
  } // end of method Program::.ctor

} // end of class Ch13.Program`

从这个 IL 代码中，`IL_0010: rethrow`指令将重新抛出当前异常，而不改变异常对象的起始点。`throw`语句的另一种用法在[清单 13-12](#list_13_12) 给出的代码中给出。

***清单 13-12。**除法运算的一个例子*

`using System;

namespace Ch13
{
    class Program` `    {
        static void Main(string[] args)
        {
            try
            { ExampleOfRethrow(); }

            catch (Exception exception)
            { Console.WriteLine(exception.StackTrace); }
        }

        static void ExampleOfRethrow()
        {
            try
            {
                int a = 10, b = 0;
                var result = a / b;
            }
            catch (Exception ex) { throw; }
        }
    }
}`

在这个例子中，`ExampleOfRethrow`方法执行除法运算，并通过使用`catch`块处理意外行为来保护代码。这个`catch`块将接受一个`Exception`类型的异常对象。在`catch`块中，我使用了`throw`语句，它实际上会重新抛出 CLR 在运行时创建的原始异常实例，而不会改变异常的起始点。让我们分析[清单 13-13](#list_13_13) 中的 IL 代码，使用`ildasm.exe`从[清单 13-12](#list_13_12) 中生成。

***清单 13-13。** IL 抛出 IL 代码的例子*

`.class private auto ansi beforefieldinit Ch13.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    // Code size       30 (0x1e)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Exception exception)
    IL_0000:  nop
    .try
    {
      IL_0001:  nop
      IL_0002:  call       void Ch13.Program::ExampleOfRethrow()
      IL_0007:  nop
      IL_0008:  nop
      IL_0009:  leave.s    IL_001c

    }  // end .try
    catch [mscorlib]System.Exception
    {` `IL_000b:  stloc.0
      IL_000c:  nop
      IL_000d:  ldloc.0
      IL_000e:  callvirt   instance string
                [mscorlib]System.Exception::get_StackTrace()
      IL_0013:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_0018:  nop
      IL_0019:  nop
      IL_001a:  leave.s    IL_001c

    }  // end handler
    IL_001c:  nop
    IL_001d:  ret
  } // end of method Program::Main

  .method private hidebysig static void  ExampleOfRethrow() cil managed
  {
    // Code size       20 (0x14)
    .maxstack  2
    .locals init ([0] int32 a,
             [1] int32 b,
             [2] int32 result,
             [3] class [mscorlib]System.Exception ex)
    IL_0000:  nop
    .try
    {
      IL_0001:  nop
      IL_0002:  ldc.i4.s   10
      IL_0004:  stloc.0
      IL_0005:  ldc.i4.0
      IL_0006:  stloc.1
      IL_0007:  ldloc.0
      IL_0008:  ldloc.1

**      /*  The CLR does the div operation**
**       * 1\. if successful then it will store the result on top of the**
**       * Evaluation Stack**
**       * 2\. Or otherwise move the execution in IL_000e*/**
      IL_0009:  div

**      /* If div operation successful pop the output of the div from**
**       * the Evaluation Stack and store into result (at position 2**
**       * of the Locals section of this method stack) .*/**
      IL_000a:  stloc.2
      IL_000b:  nop
      IL_000c:  leave.s    IL_0012

    }  // end .try
    catch [mscorlib]System.Exception
    {
      IL_000e:  stloc.3` `      IL_000f:  nop

**      /* If any exception raised by the CLR while doing the div operation**
**       * it creates an Exception object (Or relevant type)  with the**
**       * exception details on the Heap and re-throw the original**
**       * exception (without reset the original stack trace) in IL_0010.*/**
      IL_0010:  rethrow

    }  // end handler
    IL_0012:  nop
    IL_0013:  ret
  } // end of method Program::ExampleOfRethrow

  .method public hidebysig specialname rtspecialname
          instance void  .ctor() cil managed
  {
**    /* code removed */**
  } // end of method Program::.ctor
} // end of class Ch13.Program`

CLR 将执行 IL 代码，如下所示:

> *1。步骤 1* :程序将从`Main`方法的`IL_0002`调用`ExampleOfRethrow`方法，程序将移动到方法`ExampleOfRethrow`并从那里继续执行指令。
> 
> *2。步骤 2* :如果在`ExampleOfRethrow`方法中一切正常，那么 CLR 将`div`结果存储在`IL_000a`中，并从该方法返回到`Main`方法以完成程序的执行。
> 
> 3.步骤 3:如果从`IL_0009`开始的执行没有正常进行，那么 CLR 将在堆上实例化一个相关的异常对象，并将该异常引用放在评估堆栈的顶部。程序将到达`IL_0010`，它从评估堆栈的顶部加载当前的异常细节，并重新抛出异常，该异常由该处理程序捕获，而不修改异常的起始点。然后，CLR 会将此异常传递给调用方。

如果你修改[清单 13-12](#list_13_12) 中的代码，如[清单 13-14](#list_13_14) 所示，那么 C# 编译器将会生成不同的 IL 指令，如[清单 13-15](#list_13_15) 所示。

***清单 13-14。**修改版[清单中的代码 13-12](#list_13_12)T5】*

`using System;

namespace Ch13
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            { ExampleOfRethrow(); }` `            catch (Exception exception)
            { Console.WriteLine(exception.StackTrace); }
        }

        static void ExampleOfRethrow()
        {
            try
            {
                int a = 10, b = 0;
                var result = a / b;
            }
            **catch (Exception ex)**
            {
                **throw ex;**
            }
        }
    }
}`

在[清单 13-14](#list_13_14) 的代码中，使用了`throw ex`语句，而不是仅仅使用`throw`语句。当 CLR 执行`throw ex`语句时，它将覆盖异常对象的一些属性，如清单 13-15 所示。

***清单 13-15。** IL 为[清单中的代码 13-14](#list_13_14)T5】*

`.class private auto ansi beforefieldinit Ch13.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    // Code size       30 (0x1e)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Exception exception)
    IL_0000:  nop
    .try
    {
      IL_0001:  nop
      IL_0002:  call       void Ch13.Program::ExampleOfRethrow()
      IL_0007:  nop
      IL_0008:  nop
      IL_0009:  leave.s    IL_001c

    }  // end .try
    catch [mscorlib]System.Exception
    {
      IL_000b:  stloc.0
      IL_000c:  nop
      IL_000d:  ldloc.0
      IL_000e:  callvirt   instance string
                [mscorlib]System.Exception::get_StackTrace()` `IL_0013:  call      void [mscorlib]System.Console::WriteLine(string)
      IL_0018:  nop
      IL_0019:  nop
      IL_001a:  leave.s   IL_001c

    }  // end handler
    IL_001c:  nop
    IL_001d:  ret
  } // end of method Program::Main

  .method private hidebysig static void  ExampleOfRethrow() cil managed
  {
    // Code size       20 (0x14)
    .maxstack  2
    .locals init ([0] int32 a,
             [1] int32 b,
             [2] int32 result,
             [3] class [mscorlib]System.Exception ex)
    IL_0000:  nop
    .try
    {
      IL_0001:  nop
      IL_0002:  ldc.i4.s   10
      IL_0004:  stloc.0
      IL_0005:  ldc.i4.0
      IL_0006:  stloc.1
      IL_0007:  ldloc.0
      IL_0008:  ldloc.1

**      /*  The CLR does the div operation**
**       * 1\. if successful then it will store the result on top of the**
**       * Evaluation Stack**
**       * 2\. Or otherwise move the execution into IL_000e*/**
      IL_0009:  div

**      /* Stores the output of the div operation from the evaluation stack into**
**       * the result (at position 2) of the Locals section of this method**
**       * stack. */**
      IL_000a:  stloc.2
      IL_000b:  nop
      IL_000c:  leave.s    IL_0012

    }  // end .try
    catch [mscorlib]System.Exception
    {
**      /* When any exception occurred, the CLR will store that exception**
**       * from the evaluation stack into the ex object of the Locals**
**       * section of this method stack.  */**
      IL_000e:  stloc.3
      IL_000f:  nop` `**      /* Load the local variable at position 3 from the Local section**
**       * of this method stack which is ex on the top of the evaluation**
**       * stack */**
      IL_0010:  ldloc.3

**      /* The CLR will throw exception using the ex object store**
**       * into the Locals section at position 3 which will reset the**
**       * starting point of the original exception and the CLR will**
**       * set the exception as it raised from here instead of**
**       * the original location.*/**
      IL_0011:  throw

    }  // end handler
    IL_0012:  nop
    IL_0013:  ret
  } // end of method Program::ExampleOfRethrow

  .method public hidebysig specialname rtspecialname
          instance void  .ctor() cil managed
  {
**    /* code removed */**
  } // end of method Program::.ctor
} // end of class Ch13.Program`

CLR 将执行如下所述的 IL 代码:

> *1。步骤 1* :程序将从`Program`类的`Main`方法的`IL_0002`中调用`ExampleOfRethrow`方法，并将移动到`ExampleOfRethrow`方法，并从那里继续执行指令。
> 
> *2。第二步*:如果一切正常，那么从`ExampleOfRethrow`方法开始执行 I `L_000c: leave.s IL_0012`指令。此时，`leave.s`指令将找不到任何`finally`块，所以它将移动到`IL_0012: nop`并从那里继续。
> 
> *3。步骤 3* :如果来自`ExampleOfRethrow`方法的`IL_0009`中的`div`操作没有正常进行，程序将转到`IL_000e`，它将从评估堆栈中加载当前的异常细节，并存储在`ExampleOfRethrow`方法位置 3 的局部变量中。在指令`L_0010: ldloc.3 load`中，位置 3 的局部变量的值被移动到评估堆栈的顶部。然后 CLR 通过重置原始异常引发位置的起点来抛出它(在`IL_0011`)，换句话说，它覆盖了堆栈信息。在下一节中，您将看到一个堆栈覆盖的示例。

[图 13-14](#fig_13_14) 展示了 CLR 在使用以下代码时如何改变异常信息:

`catch(Exception ex)
{
       throw;
}
catch` `{
       throw;
}`

运筹学

`catch(Exception ex)
{
       throw ex;
}` ![images](img/-14.jpg)

***图 13-14。**刚才扔的例子*

CLR 会更改异常的详细信息，并且此方法的调用方将不会获得正确的信息或关于异常的原始起始点的信息，这将使应用调试变得更加困难。所以使用`just throw`语句不会改变异常的起点，而使用`throw exceptionObject`语句会改变异常的起点，如上所述。

### 堆栈覆盖

让我们看一个例子，看看 CLR 是如何覆盖异常细节的。该程序将根据一年中的月份索引给出月份名称，如清单 13-16 中的[所示。](#list_13_16)

***清单 13-16。**栈覆盖的例子*

`using System;

namespace Ch13
{` `class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Year year = new Year();
                year.GetMonth(22);
            }
            catch (Exception exception)
            {
                Console.WriteLine("{0}", exception.StackTrace);
            }
        }
    }

    public class Year
    {
        public string GetMonth(int position)
        {
            try
            {
                MonthNameFinder monthFinder = new MonthNameFinder();
                return monthFinder.Find(position);
            }
**            catch (Exception exception)**
            {
**                throw;**
            }
        }
    }

    public class MonthNameFinder
    {
        private string[] months =
        {
            "January",          "February",
            "March",            "April",
            "May",              "June",
            "July",             "August",
            "September",        "October",
            "November",         "December"
        };

        public string Find(int whichMonth)
        {
            try
            {
                return months[whichMonth];
            }
            catch (Exception exception)` `            {
                throw;
            }
        }
    }
}`

运行该程序将显示[图 13-15](#fig_13_15) 中提供的详细信息。

![images](img/-15.jpg)

***图 13-15。**虽然只使用了一个 throw 语句*

[清单 13-17](#list_13_17) 显示了`Year`类的`GetMonth`方法的修改版本。

***清单 13-17。**修改了 Year 类的 GetMonth(int position)代码*

`public class Year
{
    public string GetMonth(int position)
    {
        try
        {
            MonthNameFinder monthFinder = new MonthNameFinder();
            return monthFinder.Find(position);
        }
        catch (Exception exception)
        {
            throw exception;
        }
    }
}`

程序将产生如图[图 13-16](#fig_13_16) 所示的异常细节。

![images](img/-16.jpg)

***图 13-16。**在使用带有异常对象*的 throw 语句时

### 运行时 CLR 如何匹配异常

当您在程序中定义异常处理块时，您可以使用不同类型的异常类型作为`catch`块的输入。这些被称为*处理器模块*。在运行时，当出现异常时，CLR 将选择应该调用处理程序的哪个块(取决于异常类型),否则 CLR 将选择 catch-handling 块，这在`Exception`中被定义为默认类型。如果在类中没有定义或找到匹配的 catch-handling 块，那么程序控件将一直冒泡到方法的调用方，以确定最匹配的异常类型。这种 catch 块搜索或匹配保持了层次结构(即大多数派生的异常类型)。在[清单 13-18](#list_13_18) 中，`IndexOutOfRangeException`是定义的 catch 块(最佳匹配)，它将是链中的第一个，最顶端的(对于下面的例子，`Exception`)将是最后一个。

***清单 13-18。**异常处理程序块*的异常类型匹配示例

`using System;

namespace Ch13
{
    class Program
    {
        static void Main(string[] args)
        {
            Division div = new Division();
            div.Divide(100, 0);
            Console.ReadLine();
        }

        public class Division
        {
            public int Divide(int a, int b)
            {
                try
                {
                    return a / b;
                }

**               catch (IndexOutOfRangeException indexOutOfRangeException)**
                {
                    Console.WriteLine("IndexOutOfRangeException");
                }
**               catch (ArgumentException argumentException)**
                {
                    Console.WriteLine("ArgumentException");
                }
**               catch (DivideByZeroException divideByZeroException)**
                {
                    Console.WriteLine("{0}\n{1}",
                        "DivideByZeroException",
                        "This handler block will execute.");
                }
**               catch (Exception exception)**` `                {
                    Console.WriteLine("{0}",
                        "It will execute when there is no best matched found.");
                }
                return -1;
            }
        }
    }
}`

因此，尽管 CLR 执行的这个程序会在`Divide`方法中引发异常，如清单 13-18 中的[所示，但它会尝试将其与相关的异常处理程序块匹配，如图 13-17](#list_13_18) 中的[所示。](#fig_13_17)

![images](img/-17.jpg)

***图 13-17。**方法发生异常时的异常匹配*

在[清单 13-18 的程序中](#list_13_18)、`IndexOutOfRangeException`、`ArgumentException`、`DivideByZeroException`和`Exception`类型已经用于处理程序块。例如，当 CLR 在执行值为`10/0`的`a/b`语句的同时在`Divide`方法中引发异常时，它将首先搜索`Divide`方法中定义的处理程序块，以匹配引发的异常类型和处理程序块中定义的异常，从而执行匹配的异常处理程序块中的代码。最佳匹配异常类型是`DivideByZeroException`，因此 CLR 将执行`DivideByZeroException`的处理程序块并显示输出:

`DivideByZeroException This handler block will execute.`

如果您通过删除`DivideByZeroException`处理程序块来修改该程序，然后执行该程序，CLR 将尝试匹配最匹配的处理程序块，并执行最匹配的处理程序块，即`Exception`块，并产生以下输出:

`It will execute when there is no best matched found.`

#### 未处理的异常

如果您删除了处理`Main`方法中的`Exception`类型异常和`Divide`方法中的`Exception`类型和`DivideByZeroException`的 catch 块，当`Divide`方法中出现异常时，CLR 将尝试将引发的异常与 catch 块匹配。但是，它将找不到任何类型，因为在`Divide`方法中不再有`DivideByZeroException`或`Exception`类型的处理程序块。CLR 将尝试为它引发的异常确定一个可能的处理程序块。如果在方法的调用者中定义了任何处理程序块(例如，在这里的`Program`类的`Main`方法中)，CLR 将把执行指针移动到该点，并尝试匹配处理程序块中定义的异常类型。如果没有找到匹配，那么处理程序块将执行，如图[图 13-18](#fig_13_18) 所示。

![images](img/-18.jpg)

***图 13-18。**执行方法中没有匹配时出现异常匹配。*

如果在`Program`类的`Main`方法中没有定义处理程序块，或者在`Program`类的`Main`方法的处理程序块中没有定义最佳匹配的异常类型，那么 CLR 会将异常信息写入 Windows 日志。

### 使用语句

C# 中的`using`语句允许你为 CLR 指定使用资源的对象何时应该释放它们。提供给`using`语句的对象必须实现`IDisposable`接口，这个接口提供了`Dispose`方法。清单 13-19 展示了`using`语句的用法。

***清单 13-19。**使用语句的例子*

`using System;
using System.Text;
using System.IO;

namespace Ch13
{
    class Program
    {
        static void Main(string[] args)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("StringBuilder\n");

            using (StringWriter sw = new StringWriter(sb))
            {
                sw.WriteLine("StringWriter");
            }
            Console.WriteLine("{0}", sb.ToString());
        }
    }
}`

清单 13-19 中的程序的反编译 IL 代码显示在清单 13-20 中的[中。](#list_13_20)

***清单 13-20。** IL 代码为[清单 13-19](#list_13_19)T5】*

`.method private hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // Code size       77 (0x4d)
  .maxstack  2
  .locals init (
           [0] class [mscorlib]System.Text.StringBuilder sb,
           [1] class [mscorlib]System.IO.StringWriter sw,
           [2] bool CS$4$0000)

**  /* Code removed */  **

  IL_0013:  ldloc.0
  IL_0014:  newobj     instance void
            [mscorlib]System.IO.StringWriter::.ctor(
                class [mscorlib]System.Text.StringBuilder)
  IL_0019:  stloc.1` `**   /* using statement has been replaced with the try as protected block**
**    * and finally as the handler block  */  **
  .try
  {
    IL_001a:  nop
    IL_001b:  ldloc.1
    IL_001c:  ldstr      "StringWriter"
    IL_0021:  callvirt   instance void
              [mscorlib]System.IO.TextWriter::WriteLine(string)
    IL_0026:  nop
    IL_0027:  nop
    IL_0028:  leave.s    IL_003a
  }  // end .try
  finally
  {
    IL_002a:  ldloc.1
    IL_002b:  ldnull
    IL_002c:  ceq
    IL_002e:  stloc.2
    IL_002f:  ldloc.2
    IL_0030:  brtrue.s   IL_0039
    IL_0032:  ldloc.1
    IL_0033:  callvirt   instance void
              [mscorlib]System.IDisposable::Dispose()
    IL_0038:  nop
    IL_0039:  endfinally
  }  // end handler

**  /* Code removed */**
}`

标签`IL_0024`的 IL 代码将寻找周围的`finally`代码块，如果找到，它将执行那个`finally`代码块，并从标签`IL_0030`开始继续执行，直到完成执行。

### 总结

在本章中，我们学习了 C# 异常，异常处理机制，以及 CLR 如何在运行时处理异常。C# 编译器将异常处理相关的信息嵌入到`Method State Description`表中，稍后 CLR 将使用该表来处理异常。通过分析类型中定义的方法的运行时方法状态描述信息，您已经详细研究了这些方法。已经深入讨论了`throw`语句和`rethrow` IL 指令，以解释不同的场景，并解释 CLR 如何在不同的环境中以不同的方式工作。本章还探讨了未处理的异常。下一章将讨论使用`async`和`await`的异步编程。