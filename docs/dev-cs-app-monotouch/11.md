## 第十一章

## 多任务处理

很难想象现代计算设备不允许你同时运行多个应用程序；然而，在 iPhone 和 iPod Touch 的 iOS for 版和 iPad 的 4.2 版之前，一次只能运行一个应用程序。正因为如此，多任务处理是 iOS 最意想不到的更新之一。

iOS 中的多任务处理不同于传统的多任务处理概念，在传统的多任务处理概念中，多个应用程序可以同时打开，并且可以平等地访问计算资源。相反，在 iOS 中，当一个应用程序因为另一个应用程序被带到前台而被放到后台时(或者如果设备收到电话)，在后台运行的应用程序有一组严格控制的事情可以做。

这种设计是有意的，有两个目的。首先，由于 iOS 设备的处理能力有限，这确保了前台应用程序获得足够的访问权限，以保持快速响应。其次，它有助于通过降低功耗来保存电池。

由于这种设计，与传统的应用程序不同，您的应用程序有一定的设计准则和责任，它必须遵守，才能在 iOS 领域发挥作用。

iOS 有一个混合模型，允许程序在后台执行任务。在开发需要执行后台处理的 iOS 应用时，有三种不同的模型:

*   **注册为后台必需的应用:**有三种类型的应用允许连续后台处理；位置、音频和 VOIP 应用。
*   **向 iOS 注册需要完成的任务:**您可以告诉 iOS 某个特定的任务需要时间来完成，并请求它在应用程序移至后台时不要将该任务置于睡眠状态。
*   **通知:**您也可以安排一个本地通知，或者发送一个远程通知(从服务器应用程序),让用户选择将应用程序放在前台。

第 18 章中的[涵盖了通知。在这一章中，我们将了解应用程序在后台执行任务的各种方式，以及它在 iOS 框架中的各种职责。](18.html#ch18)

本章中的所有示例都可以在`Example_BackgroundExecution`配套应用程序和代码中找到。

### 应用状态

在多任务 iOS 更新之前，应用程序只有三种状态:

*   `Running/Active`:应用程序在前台运行。
*   `Inactive`:应用程序已被中断并处于“暂停”状态当用户收到电话或短信，或者 iOS 发出警报时，就会发生中断。如果你不接受中断，它会回到活动状态。
*   `Terminated/Not Running`:应用程序要么尚未启动，要么由于接受中断(如电话)而被终止，要么用户通过点击 home 键将其关闭。

然而，随着多任务更新，应用程序获得了一种新的状态，称为`background`或`suspended`。`background`状态意味着应用程序仍然被加载，但是通常不允许做任何处理。然而，正如我们将在本章中探讨的，有一些方法实际上可以防止一个应用程序进入挂起状态，或者甚至继续处理，如果它已经进入挂起状态的话。

![images](images/1101.jpg)

**图 11–1。***iOS 中的多任务应用状态*

这从根本上改变了应用程序的行为。在多任务处理之前，如果用户点击 Home 键或接受中断，应用程序就会完全关闭。

然而，在多任务更新之后，当用户点击 Home 按钮或接受中断时，应用程序将进入后台状态，由此应用程序可以实际上继续处理，如果它从 iOS 获得许可的话。

此外，通过连按主屏幕按钮，您可以在运行的应用程序之间切换。然而，在任何时候，只有一个应用程序可以处于活动状态，并且该指定属于其界面当前显示在窗口中的应用程序，或者当前正在使用的应用程序。

### 了解后台任务

在我们进入如何实际开发后台执行之前，首先我们需要理解选项和限制。关于如何在后台执行，有几种不同的方法。第一种方法是告诉 iOS 您需要后台处理时间来执行特定任务。

通过这样做，iOS 将以某种方式对待您的应用程序，这取决于允许您的应用程序能够完成它需要做的特定任务。

iOS 中提供了以下任务类别:

*   **音频:**只要音频应用程序正在播放音频，它们就可以继续处理。当他们停止播放音频时，iOS 会暂停播放。
*   **位置:**位置应用程序将继续从 iOS 接收位置更新，并且根据应用程序，可以在更新之间暂停，或者保持运行。
*   **VoIP:** 互联网协议语音(VoIP)应用程序有机会在注册的时间间隔内做出响应，以保持与支持它们的 VoIP 服务的连接。此外，许多 VoIP 应用程序还需要扩展到音频应用程序的特权，以便在后台处理音频。

我们将在本章的后面更详细地了解每一个。

#### 检查多任务处理能力

因为多任务支持依赖于操作系统版本和硬件，如果你的应用程序依赖于它，并且在多任务支持不可用时必须改变它的行为，你可以通过`UIDevice`类的`IsMultitaskingSupported`属性查看可用性，如[清单 11–1](#list_11_1)所示。

**清单 11–1。** *确定多任务支持是否可用*

`if(UIDevice.CurrentDevice.IsMultitaskingSupported)
{
        // code dependent on support
}`

#### 应用委托方法

iOS 通过`AppDelegate`类中的事件方法通知您的应用程序更改应用程序状态。您可以像处理其他方法一样处理这些方法，例如`FinishedLaunching`方法。下列应用程序委托方法与状态更改相关:

*   `OnResignActivation`:当应用程序将要进入非活动状态时，调用这个方法，要么是因为它被暂时停用(由于一个事件，比如一个电话)，要么是它将要进入后台状态。如果你的应用程序是一个游戏，这是暂停它并降低你的帧速率的时候，同时应用程序等待再次激活或进入后台。
*   `DidEnterBackground`:如果你的应用程序运行的设备支持多任务，这个方法被调用，而不是`WillTerminate`。您应该使用此方法来停止更新接口，并保存在应用程序终止时恢复应用程序所需的任何状态。您大约有 5 秒钟的时间来完成此方法，否则您的应用程序或您的应用程序进程将被终止。此外，一旦你的应用程序处于后台模式，任何更新界面的尝试(或进行`OpenGL ES`调用)，也会导致进程被终止。
*   `WillEnterForeground`:当你的应用程序要从后台转换到非活动状态时，调用这个方法。您应该使用这个方法来撤销任何拆除操作，并恢复在`DidEnterBackground`状态期间保存的任何状态。
*   `OnActivated`:当应用程序被用户启动而进入活动状态时，或者当中断(比如一个电话或一条短信)被忽略时，这个方法被调用。`OnActivated`是重新开始更新您的应用程序界面的地方；例如，如果你正在构建一个游戏，这是一种控制你的帧速率的方法，并为你的用户提供恢复(取消暂停)的选项。
*   如果运行应用程序的设备不支持多任务处理，当用户关闭应用程序时，这个方法会被调用，因为他们点击了 Home 键，或者他们接受了一个中断。如果设备支持多任务，这种方法很少被调用，但也不是闻所未闻，因为 iOS 可能需要释放资源。你应该用这个方法来保存任何数据，释放任何资源等等。与`DidEnterBackground`一样，您有大约 5 秒的时间来完成这个方法，否则您的应用程序的进程可能会被终止。

正如你所看到的，苹果对应用程序遵守他们的限制是认真的，如果你的应用程序表现不好，它将终止你的应用程序的进程。这是为了确保无论您的应用程序在做什么，设备都会对用户做出响应。

#### 多任务指南和要求

除了前面的注意事项，为了成为 iOS 的好公民，您的应用程序还应该遵守其他行为和要求。在构建依赖后台处理的 iOS 应用程序时，应遵循以下准则:

*   **不要在后台状态下更新你的用户界面或者调用 OpenGL ES:**在后台状态下，如果你试图更新用户界面，你的应用程序可能会在没有警告的情况下被终止。同样，如果您试图在后台状态下进行`OpenGLES`调用，也会发生同样的事情。
*   **在移至后台之前保存应用程序状态:**为了向您的用户提供无缝体验，请确保在移至后台之前保存足够的应用程序状态，以便能够在有意义的状态下恢复应用程序。理想情况下，这意味着当您的应用程序被移回前台时，它就从离开的地方开始。
*   **移至后台时停止使用共享资源:**处于活动状态的应用优先访问共享资源，如通讯录等。如果您的应用程序试图在后台状态下访问共享资源，它很可能会被终止。
*   **从视图中移除敏感信息:**iOS 在进入后台状态时(就在`DidEnterBackground`被调用之后)对窗口进行快照。当应用程序退出后台状态时，系统会短暂显示该快照。在使用`DidEnterBackground`方法时，确保隐藏或掩盖任何敏感信息，如密码。
*   **取消/关闭网络服务调用:**当您的应用程序移动到后台时(在`DidEnterBackground`期间)，它应该关闭任何网络连接并从任何 Bonjour 相关的服务中注销。但是，如果您已经将应用程序注册为音频或 VOIP 后台应用程序，这不是必需的。
*   **为网络连接失败做好准备:**如果您有任何打开的套接字，当您的应用程序进入后台状态时，您不应该指望它们会继续打开。良好的编程实践表明，在使用连接之前，您应该总是检查它；所以只要你坚持那个原则，你的申请应该没问题。
*   **注册并响应外部附件通知:**如果您的应用程序使用外部附件框架，您应该确保注册断开通知，当您的应用程序进入后台状态时，将调用该通知。同样，当您的应用程序转换到活动状态时，如果已注册，它将收到重新连接通知。您应该确保在您的应用程序中适当地处理这些问题，这是基于当应用程序挂起时附件将被断开的概念。
*   **在后台做最少的处理:**如果你的应用程序注册了一个特定的任务，比如播放音频，它应该做足够的工作来完成这个任务，并在你的应用程序处于前台/活动状态时保存不必要的处理。如果您的应用程序请求完成一个长时间运行的任务，它应该完成该任务，然后不再做任何处理。如果 iOS 发现您的应用程序消耗了过多的处理能力，它将被终止。苹果没有定义这个门槛是什么，所以最好尽量少做工作。
*   **处理警报状态:**当应用程序进入非活动状态时，它们的警报和动作表不会被解除。但是，如果应用程序随后转换到后台状态，这些视图将被取消。因此，在`DidEnterBackground`期间，您应该保存足够的状态，以便当应用程序移出后台状态时，您可以显示警告或动作表(如果合适)。

遵循这些指导方针不仅对拥有一个功能良好的应用程序很重要，而且，如果你向应用程序商店提交，你的应用程序也将接受合规性测试，如果没有通过，它将不会被接受。因此，先发制人并在第一时间遵循这些指导方针是一个好主意，而不是被拒绝并不得不重新提交。

### 向 iOS 询问完成任务的时间

如果您希望在应用程序关闭之前完成一个长时间运行的流程，您可以向 iOS 请求时间来完成该任务。要请求在将应用程序置于后台状态之前允许任务完成，您需要调用`UIApplication`对象上的静态`BeginBackgroundTask`方法，该方法会返回一个表示唯一任务标识符的整数。然后，当您的任务完成时，您调用`EndBackgroundTask`方法(再次，在`UIApplication`上)并传递您在开始时收到的任务的 id。

如果你调用`BeginBackgroundTask`来注册你的任务，iOS 通常不会暂停你的应用程序(但是，它会暂停 UI 线程——所以 UI 更新通常是不可能的),直到你所有注册的任务完成。这意味着您可以启动一个任务，如果用户单击 Home 按钮，您的应用程序将变为非活动状态，但不会挂起。

清单 11–2 中的以下代码说明了这种模式。

**清单 11–2。** *注册一个任务，防止应用程序在完成时被挂起*

`int taskID = UIApplication.SharedApplication.BeginBackgroundTask(
        () => { /* code to run when remaining time is low*/ });
// perform your task
//---- tell the iOS you're done
UIApplication.SharedApplication.EndBackgroundTask(taskID);`

**注意**:您必须将任何`BeginBackgroundTask`呼叫与`EndBackgroundTask`呼叫配对。如果你不调用`EndBackgroundTask`，你的应用程序将被终止，而不是进入后台状态。

#### 任务执行到期时间

注意，在前面的例子中，当我们调用`BeginBackgroundTask`时，我们是如何传入一个匿名的`lambda`委托的。这是因为该方法需要一个`expiration`参数，该参数接受一段代码，这段代码将在分配给应用程序完成任务的时间即将结束时执行。这样设置是因为 iOS 只给应用程序有限的时间来完成任务。就在该时间到期之前，它通过执行到期块中的代码让您知道。这允许您取消长时间运行的任务，并清理与之相关的任何资源。

通常，iOS 会给你 600 秒(10 分钟)来完成后台任务，但你不能保证有那么多时间。您可以通过访问`UIApplication` 类的静态`BackgroundTimeRemaining`属性来查看您还剩多少时间。该属性将返回在 iOS 将您的应用程序置于后台状态之前您拥有的秒数。例如，清单 11–3 中的代码将剩余时间写入应用程序输出窗口。

**清单 11–3。** *确定在 iOS 将其置于后台状态之前你的应用程序还有多少时间*

`Console.WriteLine("Background time remaining: "
        + UIApplication.SharedApplication.BackgroundTimeRemaining.ToString());`

#### 任务完成模式

通常有两种情况，您希望告知 iOS 您希望允许您的应用程序完成任务:

*   **在不可中断的进程中:**您正在执行长时间运行的任务，如果应用程序可能会移到后台，例如下载文件，您不希望该任务被中断。
*   **在 DidEnterBackground 期间:**如果你的应用程序正在进入后台状态(你的`DidEnterBackground`方法被调用)，并且你知道你必须做一些需要超过 5 秒的工作(在你的应用程序被终止之前那个方法的执行阈值)，那么你可以注册并调用长时间运行的任务。这种任务的例子可能是释放资源，上传分数到服务器(在游戏的情况下)，或者长时间运行的清理。

第一个场景实现起来相当简单:您只需将您的调用包装在`BeginBackgroundTask` / `EndBackgroundTask`方法中，如[清单 11–4](#list_11_4)所示。第二个场景要求您在一个新线程上生成任务，这样`DidEnterBackground`就可以返回。以下示例说明了这种模式:

**清单 11–4。** *当应用程序即将进入后台状态时调度长时间运行的任务*

`public override void DidEnterBackground (UIApplication application)
{
        //---- register a long running task, and then start it on a new thread so that
            this method can return
        int taskID = UIApplication.SharedApplication.BeginBackgroundTask(
            () => {});
        Thread task = new Thread(new ThreadStart(()=>
            { FinishLongRunningTask(taskID);}));
        task.Start();
}

protected void FinishLongRunningTask(int taskID)
{
        Console.WriteLine("Starting task " + taskID.ToString());

        //---- sleep for 5 seconds to simulate a long running task
        Thread.Sleep(5000);

        Console.WriteLine("Task " + taskID.ToString() + " finished");

        //---- call our end task` `        UIApplication.SharedApplication.EndBackgroundTask(taskID);
}`

如果您将代码放入您的应用程序委托中，启动您的应用程序，并单击 Home 按钮，MonoDevelop 中的`Application Output`窗口应该输出类似下面的内容([清单 11–5](#list_11_5))。

**清单 11–5。** *应用程序输出来自[清单 11–4](#list_11_4)*

`App entering background state.
Thread started:
Starting task 1
Task 1 finished`

如您所见，即使单击了 Home 按钮，将应用程序置于后台状态，注册的任务仍然可以完成。

### 注册您的应用程序以允许执行特定的后台任务类别

注册长时间运行的任务对于某些场景(如一次性任务处理)来说是很好的，但有时您构建的应用程序需要基于特定任务的持续后台处理，而您的应用程序不需要进入后台状态。苹果已经做出让步，允许某些类型的应用程序这样做。

为了让 iOS 知道您希望能够在后台执行哪些任务，您必须向`info.plist`文件添加一个`UIBackgroudnModes`键(数组类型),并至少指定以下值之一:

*   `audio`
*   `voip`
*   `location`

要编辑`info.plist`文件，在项目浏览器中双击它，Xcode 的属性列表编辑器就会打开。点击`Add Child`添加新密钥。您需要手动键入`UIBackgroundModes`键，因为它可能不在您可以选择的值列表中。在您命名了键之后，您需要右键单击它并将值类型更改为`Array` ( [图 11–2](#fig_11_2))。

![images](images/1102.jpg)

**图 11–2。** *将 UIBackgroundModes 键指定为数组类型*

在您创建了键并指定了它的类型之后，您可以添加您的值，方法是单击键左侧的箭头将其展开，然后单击右侧的+按钮。你的`info.plist`应该看起来像[图 11–3](#fig_11_3)。

![images](images/1103.jpg)

**图 11–3。** *指定“音频”类型应用*

属性列表编辑器不是苹果最好的软件产品之一，因此需要复杂的步骤来完成简单的任务。

### 音频应用

只要在`UIBackgroundModes`数组中指定了`audio`，并且你的应用正在播放音频，iOS 就会让你的应用保持在非活动状态运行，不会把它移到后台。这意味着所有的音频回调都将正常运行，对于所有的意图和目的，您的应用程序通常都将正常运行。例如，如果您的应用程序要求从服务器下载音乐，它可以继续这样做。

因此，尤其重要的是不要更新你的用户界面，并遵守前面提到的所有其他准则。

注意:这里有一些注意事项。音频应用程序在允许做什么方面有很大的灵活性。例如，您可以访问网络资源(特别是为了播放网络和互联网位置的音频)。但是，不能用单声道/。网络插座。相反，您必须对网络流使用 NSStream 类。

### 定位应用

`Location applications`是依赖位置更新来运行的应用程序。应用程序可以遵循两大类后台操作行为:

*   **仅当位置发生重大变化时:**只有当位置发生重大变化时，您的申请才会得到通知。这仅在 iOS v4.0 及更高版本的具有蜂窝无线电的设备(iPhone、iPad 3G 等)上可用。).在这种模式下，您不需要在`info.plist`文件中将您的应用程序注册为一个`location`任务应用程序。您的应用程序将正常转移到后台状态，然后在发生重大变化时自动被唤醒，只要您在`CLLocationManager`类上订阅了`StartMonitoringSignificantLocationChanges`方法。有关这方面的更多信息，参见第 13 章(核心位置)。
*   **持续的位置更新:**你的应用程序可以持续接收位置更新，通常不会进入暂停状态。为了利用这种操作模式，您的应用程序必须在`info.plist`文件的`UIBackgroundModes`键中注册一个`location`值。

定位服务是在 iOS 设备上执行的最累人的任务之一；因此，除非您的应用程序需要连续、精确的位置信息，否则推荐的方法是仅在后台订阅有意义的位置变化。这种方法允许设备关闭接收精确位置数据所需的无线电硬件，而是依靠蜂窝塔的变化来指示位置的显著变化。

订阅重大位置更改的主要优势之一是，iOS 实际上会将您的应用程序移动到非活动状态，以便它可以在后台状态下处理位置更新。如果应用程序已经被终止，它将通过应用程序委托中的`FinishedLaunching`方法中的 options 参数，在位置改变时重新启动应用程序。

有关使用定位服务的更多信息。参见[第十三章](13.html#ch13)。

### 网络电话应用

VoIP 应用要求在设备和为其供电的服务之间保持持久连接；这样，即使该应用程序不是活动应用程序，VoIP 帐户也可以保持其“在线”状态。为了促进这一点，iOS 专门为 VoIP 应用程序提供了几项津贴和能力来保持连接开放。

为了让 iOS 知道您的应用程序是一个 VoIP 应用程序，您必须在`info.plist`文件的`UIBackgroundModes`键中指定一个`voip`值。此外，如果您的应用程序需要在后台播放声音(就像一些 VoIP 应用程序一样)，您还应该包含`audio`值。

通过将您的应用程序注册为 VoIP 应用程序，您可以获得另一个好处——当设备重新启动时，iOS 将实际启动您的应用程序，这样您的用户就可以通过您的 VoIP 服务保持在线。

#### VoIP 套接字处理

如果您的应用程序注册为 VoIP 应用程序，系统将在您的应用程序挂起时自动管理底层套接字。这意味着，如果新数据到达，而您的应用程序被挂起，它会将您的应用程序转移到非活动状态，以便您的应用程序可以处理这些数据。通常，如果收到的数据是需要用户通知的电话呼叫或其他消息，您的应用程序应该安排一个立即的本地通知，以便向用户提供一个选项来应答呼叫或处理消息。如果用户接受通知，那么应用程序将被转移到活动状态。

#### VoIP 保活

为了保持 VoIP 服务的“在线”状态，VoIP 应用程序通常需要定期联系该服务以保持连接活动。为了方便起见，iOS 提供了一个您可以调用的方法，称为`SetKeepAliveTimeout`，如果您的应用程序被挂起，它将唤醒您的应用程序(将其移至非活动状态)，并允许您执行代码以保持您的连接在线:

`bool SetKeepAliveTimout (double timeout, NSAction handler);`

当您调用此方法时，您传递两次调用之间的持续时间(以秒为单位)，以及一个匿名委托(它自动转换为一个`NSAction`)，该委托包含时间到时要运行的代码。通常，您会在`DidEnterBackground`方法中调用这个方法，如[清单 11–6](#list_11_6)所示

**清单 11–6。** *指定保活处理程序并对其进行调度*

`public override void DidEnterBackground (UIApplication application)
{
        UIApplication.SharedApplication.SetKeepAliveTimeout(600, () => {
                 /* keep alive handler code*/ });
}`

您应该将超时参数设置为尽可能大的值，该值必须至少为 600 秒(10 分钟)。iOS 保证您的处理程序将在到期超时之前被调用，但它可能会被调用得更快，因为为了节省电池，它通常与许多其他系统调用一起批处理。

此外，您的处理程序有 30 秒的时间来完成，否则您的应用程序将被终止，因此您可能希望将网络调用的超时设置为小于该时间。

### 总结

在这一章中，我们了解到 iOS 中的 mutlittasking 与传统计算有所不同，它带来了我们必须遵守的某些责任和要求，以便与其他应用程序配合良好。我们还讲述了您可以执行的各种类型的后台任务，以及如何向 iOS 注册以便能够执行这些任务。

在下一章中，我们将了解 iOS 中的存储。