## 第六章

## 控件简介

MonoTouch 中控件的概念很有趣。在 ASP.NET 和 WPF 这样的 Windows 框架中，有一个实际的`Control`类，所有的控件都是从这个类派生出来的。在 MonoTouch/CocoaTouch 中并非如此。事实上，有一个`UIControl`类，但是并不是所有的控件都继承了它；有些直接继承自`UIVIew`。

在 MonoTouch 中,“控制”这个术语更具概念性，涵盖了视图、控制器，甚至普通的旧对象类。最终，控件只是一个封装的对象，要么显示内容，要么管理被显示的内容。

在这一章中，我们将介绍一些不同的概念，这些概念将有助于你理解如何在 MonoTouch 中使用控件。其中一些概念在实际使用控件后会更有意义，因此建议您快速通读本章，然后在接下来的三章中作为参考，这三章涵盖了特定的控件。

### 坐标系

您将在 MonoTouch 中使用或创建的许多控件都放在应用视图中的特定位置。放置它们时，它们的位置基于简单的 x，y 欧几里得坐标空间。轴上的每个整数代表一个`point`。

**什么是点？**在 iPhone 4(配备 Retina 显示屏)之前，所有坐标都是基于像素，而不是点。然而，由于 Retina 显示屏的像素密度是以前 iPhone 设备的两倍，因此一个像素在 iPhone 4 和旧款 iPhone 设备之间具有不同的意义。为了方便起见，苹果不再使用像素这个术语，而是使用 point，这是一种与设备/分辨率无关的抽象，将 1:1 映射到 iPhone 4 之前的设备像素。我们马上会看到，点是由浮点数指定的(它们由系统表示。PointF 类)，这意味着如果您需要 Retina 显示屏上的像素精度，您可以使用十进制数，例如 0.5 来指定 Retina 显示屏上的单个像素。

然而，欧几里得坐标空间的一个注意事项是，原点(0，0)不是在左下角，y 轴不是随着它的上升而增加，而是原点实际上在左上角，y 轴随着它的下降而增加。

您可以在下面的屏幕截图中看到这个坐标空间([Figure 6–1](#fig_6_1))。

![images](img/.jpg)

**图 6–1。** *视图空间坐标系*

#### 帧

控件的位置和大小是通过`Frame`属性设置的，该属性接受一个`RectangleF`对象。许多控件在其构造函数中都带有一个`Frame`参数，这样你就不必在以后设置它。例如，下面的代码片段([清单 6–1](#list_6_1))在 x，y 坐标(20，300)处创建一个`UILabel`控件，大小为 280 磅宽，40 磅高。

**清单 6–1。** *实例化标签并设置其框架*

`this._customLabel = new UILabel (new RectangleF (20, 300, 280, 40));`

有些控件，比如`UIPickerView`，可以自己调整大小，所以你可以指定一个`RectangleF.Empty`对象作为它们的初始`Frame`。这将允许您不必指定它们的大小，并且如果您想在以后更改它们的位置，您可以这样做。

### 自动调整大小

当谈到处理旋转时，我们在第 5 章中简单地看了一下自动调整大小的东西。

您可以在界面构建器的**自动调整**部分下的**尺寸检查器**窗口中设置自动调整属性，如图[图 6–2](#fig_6_2)所示。

![images](img/.jpg)

**图 6–2。** *在界面生成器中设置自动调整属性*

您可以单击红线来启用或禁用自动调整大小功能。当您设置它们时，右边的动画将向您展示当包含它的视图被调整大小时，您的控件将如何反应。

外部正方形中的红线表示控件外部的边距。如果它们被启用，控件将尝试保持启用的相应边的固定边距。

内部正方形中的红线表示控件的大小。如果它们被启用，控件将按照启用的方向调整自身的大小。

您也可以通过`UIView`上的`AutoresizingMask`属性在代码中设置这些属性。`AutoresizingMask`采用描述要应用的自动调整大小属性的位掩码。您可以在`UIViewAutoresizing`枚举中找到不同的选项。因为是位掩码，所以可以一次应用几个值；例如，下面的代码，如[清单 6–2](#list_6_2)所示，告诉`myControl`它的上边距应该是灵活的，并且可以调整它的宽度。

**清单 6–2。** *在代码中设置自动调整属性*

`myControl.AutoresizingMask =
        UIViewAutoresizing.FlexibleTopMargin | UIViewAutoresizing.FlexibleWidth;`

### 使用字体

iOS 内置了相当多的高质量字体供您选择。要查看完整的选择，请运行`Example_Fonts`配套应用，它会枚举整个列表，如[Figure 6–3](#fig_6_3)所示。

![images](img/.jpg)

**图 6–3。**iOS 中的*字体*

MonoTouch 中的字体由`UIFont`类表示，它封装了诸如字体、大小等信息。`UIFont`对象是通过静态工厂方法在`UIFont`类本身上创建的。如果你想从默认字体创建一个`UIFont`，你可以调用`SystemFontOfSize`并传递你想要的字体大小。例如，下面的代码，如[清单 6–3](#list_6_3)所示，将创建默认的高度为 20 磅的`UIFont`。

**清单 6–3。** *创建高度为 20 磅的默认系统字体*

`UIFont myFont = UIFont.SystemFontOfSize (20);`

另外，你可以调用`BoldSystemFontOfSize`来创建一个粗体系统字体，或者调用`ItalicSystemFontOfSize`来创建默认的斜体字体。

您也可以通过`FromName`方法创建基于名称的字体。例如，要创建一个 20 像素高的 Helvetica 加粗字体，您可以进行如下调用([清单 6–4](#list_6_4))。

**清单 6–4。** *从已知名称创建字体*

`UIFont myFont = UIFont.FromName ("Helvetica-Bold", 20);`

#### 字体大小

字体大小由文本行的高度指定，以磅为单位。`UIFont`包括许多内置属性，为您提供默认字体大小:

*   `SystemFontSize`:普通文本的默认字体大小
*   `SmallSystemFontSize`:小文本的默认字体大小
*   `ButtonFontSize`:按钮的默认字体大小
*   `LabelFontSize`:文本标签的默认字体大小

这些属性返回`float`值，因此您可以使用这些属性来代替指定特定的浮点大小。例如，下面的代码([清单 6–5](#list_6_5))以默认字体大小创建一个默认字体。

**清单 6–5。** *用默认大小创建默认字体*

`UIFont myFont = UIFont.SystemFontOfSize (UIFont.SystemFontSize);`

#### 枚举字体

字体选择因设备而异，因此在尝试使用字体之前，您应该确保该字体可用。

字体是按照它们所属的系列来分类的。例如，Helvetica 字体系列包括正常版本、粗体版本、倾斜(斜体)版本和粗体-倾斜版本。这些字体中的每一种都有特定的名称。例如，Helvetica 的粗体版本是 Helvetica 粗体。

您可以通过`UIFont`类上的`FamilyNames`属性枚举字体系列，该属性返回每个可用字体系列的字符串数组。

您可以通过`UIFont`上的`FontNamesForFamilyName`属性枚举给定系列中的字体，该属性接受系列名称的字符串参数，并返回该系列中每个字体的字符串数组。

要了解这一点，请查看`Example_Fonts`配套应用。

### 标签

不像传统的 Windows UI 框架，如 ASP.NET WPF，等等，控件没有 ID 属性，你可以用它来识别它们。相反，`UIView`类包含一个名为`Tag`的整数属性，允许您给它们一个标识符。您可以使用它来标识动态生成的控件，如表格视图中的单元格。

### 控制状态

从`UIControl`继承的控件有不同的状态。有些状态是用户交互的直接结果，如触摸控件，而其他状态与交互无关，如被禁用。

各种控制状态是`UIControlState`枚举的一部分，如下所示:

*   `Normal`:控件的默认状态，未选中或未高亮，但已启用
*   `Highlighted`:触摸时控件所处的状态。它的存在是为了让用户知道他们正在触摸控件。如果一个控件处于这种状态，它的`Highlighted`属性将返回`true`。
*   `Disabled`:当一个控件被禁用时，用户不能与之交互。您可以通过`Enabled`属性将控件设置为禁用或启用。
*   对于许多控件来说，这个状态并没有真正实现，也就是说它什么都不做。对于那些使用它的控件，您可以通过`Selected`属性来访问它。

对于许多控件，您可以根据状态自定义它们的行为和外观。例如，如果您正在使用一个`UIButton`，您可以为每个状态设置`Title`和其他属性。在界面构建器中，属性检查器中有一个下拉菜单，允许您指定状态配置，如图[Figure 6–4](#fig_6_4)所示。

![images](img/.jpg)

**图 6–4。** *属性检查器让你在支持它们的控件上指定控件状态属性。*

您也可以通过编程来指定它们，例如，下面的代码([清单 6–6](#list_6_6))为`Normal`控件状态设置按钮的`Title`。

**清单 6–6。** *程序化设置按钮文本*

`button.SetTitle ("My Button", UIControlState.Normal);`

控制状态是一个位标志，因此您也可以将它们组合起来引用多个状态，如[清单 6–7](#list_6_7)所示。

**清单 6–7。** *结合控制状态标志*

`button.SetTitle ("My Button", UIControlState.Normal | UIControlState.Disabled);`

如果你没有为一个状态显式地定义一个属性，默认情况下使用来自`Normal`状态的属性值。

### 处理图像

通常需要通过显示项目中的图像来自定义您的界面。大多数情况下，这意味着加载图像并将其设置为控件的`Image`属性(或类似属性)。这需要创建一个包含您的图像的`UIImage`对象。

为了做到这一点，`UIImage`类有两个静态工厂方法，`FromFile`和`FromBundle`，它们可以直接从文件系统加载您的映像。FromFile 和`FromBundle`都有一个指向你的图像的路径，但是工作方式略有不同，我们稍后会看到。

当从应用加载文件(包括图像)时，您可以通过与它们在项目中相同的路径来引用它们。例如，如果您想从项目中加载`Lightning_Small.png`图像，如下图所示([图 6–5](#fig_6_5)，您可以通过`img/.png`路径加载它。

![images](img/.jpg)

**图 6–5。** *一个带有图像的样本溶液*

例如，下面的代码([清单 6–8](#list_6_8))就使用了`FromFile`方法。

**清单 6–8。** *从文件中加载图像*

`UIImage myImage = UIImage.FromFile(“img/.png”);`

也就是说，有几个问题需要了解:

*   **不要将你的文件夹命名为“Resources”**:这将导致 CocoaTouch 的混乱(它实际上被 iOS 禁止了)，并且你在那个文件夹中的项目实际上是不可访问的。您的应用甚至可能会崩溃。
*   **设备区分大小写:**然而，模拟器不区分大小写。因此，如果您在加载资源时不注意观察自己的情况，它可能在模拟器中工作，但在设备中会失败。
*   **Build Action 必须标记为 content:** 当您添加一个想要在项目中使用的资源(比如图像)时，您必须将`Build Action`设置为`Content`。您可以在“添加文件”对话框中进行设置，或者在添加文件后，右击文件并选择`Build Action` ![images](img/.jpg) `Content`。
*   **图像在界面构建器中不显示:**当您在界面构建器中设置图像的路径时，图像不会显示。不幸的是，这是一个 MonoTouch 限制，可能会在以后的版本中得到解决。

#### 从文件与从捆绑包

如前所述，有两种从文件加载图像的标准方法— `FromFile`和`FromBundle`。它们非常相似，但工作方式略有不同。

##### FromBundle

`FromBundle`是一个同步调用，它将在线程加载图像时阻塞线程。加载后，iOS 会缓存图像。这意味着，如果您使用相同的图像路径再次调用`FromBundle`，它将从缓存而不是磁盘中提取图像。

也有一些小魔术。iPhone 4G 的屏幕分辨率是早期 iPhone 的两倍。为了利用更高的分辨率，当您的应用在 iPhone 4G 上运行时，它应该使用比旧款 iPhone 分辨率高一倍的图像。然而，每次都进行检查并加载适当大小的图像将是乏味的。因此，你可以在你的应用中包含带有`@2x`名称后缀的图像，如果在 iPhone 4G 上被调用，`FromBundle`会自动加载这些图像。例如，您可能有两幅内容相同但大小不同的图像，分别叫做`MyImage.png`和`MyImage@2x.png`。

综上所述，`FromBundle`有一些明显的缺点。

*   首先，它缓存加载的图像，但它没有适当的缓存管理，也不会清除图像，所以即使在您使用完图像后，它也可以将它们保留在内存中。许多 iPhone 开发人员已经看到，由于内存可用性低，这实际上会使他们的应用崩溃。
*   其次，因为它是一个同步(阻塞)调用，一次多次调用它会显著降低应用的速度，尤其是在一次加载多个应用的情况下。
*   第三，它只能加载包含在应用的沙箱中的图像，所以如果内容存储在其他地方，它就不能访问它。

##### FromFile

与`FromBundle`不同的是，`FromFile`是一个异步的、延迟加载的调用，它不会真正加载图像，直到它被请求，比如当它需要被显示的时候。此外，它可以在应用沙箱之外加载文件。

和`FromBundle`一样，`FromFile`也有一些缺点。

*   首先，它不缓存图像，因此相同图像的额外加载仍然会导致磁盘读取命中。
*   第二，它不包括任何`FromBundle`的`@2x`文件名魔术。

#### 哪一个？

一般来说，如果您需要一次加载许多图像，您应该使用`FromFile`，因为它采用了惰性加载方法。如果你需要反复使用同一个图像，你应该使用`FromBundle`。

如果你想使用在`FromBundle`中自动使用的`@2x`后缀，但是你需要加载许多图像，你应该使用`FromFile`来代替，但是要添加代码来做设备检查并基于此加载适当的文件。

### 子类化(创建自定义控件)

如果你一直在读这本书，你实际上已经知道了很多关于创建自定义控件的子类化的知识。每当您从`UIView`或`UIViewController`继承时，您已经对它们进行了子类化以执行定制功能。

但是，在创建自定义控件时，有几件事情需要记住。

#### 必要的构造器

除了您可能希望放在控件上的自己的构造函数之外，如果您的控件将从 xib 文件初始化，您还需要一个额外的构造函数:

**清单 6–9。***Objective-C 运行时所需的 NSCoder 构造函数。*

`public Foo (NSCoder coder)`

当从 xib 文件实例化控件时，运行库调用此构造函数。

#### 注册您的控件

当创建需要在 Interface Builder 中使用的控件和/或类时，您需要将它们注册为对 Objective-C 运行时可见。MonoTouch 包含了`MonoTouch.Foundation.Register`属性，允许你给你的类一个 Objective-C 可见的名字。例如，下面的代码注册了`Example_StandardControls`伴随代码中的`TapZoomScrollView`控件([清单 6–10](#list_6_10))。

**清单 6–10。** *使用注册属性使一个类对 Objective-C 运行时可见*

`[MonoTouch.Foundation.Register("TapZoomScrollView")]
public class TapZoomScrollView : UIScrollView
{
        // implementation
}`

#### 使用界面构建器中的控件

如果你创建了一个继承自`UIView`、`UIController`的控件，或者在界面构建器的`Library`窗口中的一个现有控件，如`UIButton`、`UILabel`等。，您可以使用您的控件来代替您从继承的控件。尽管界面构建器非常原始，所以不像传统的微软 .NET 框架，如 WPF，除了已经存在的基本控件之外，没有提供任何真正的设计时控件。

要使用自定义控件，请将基本控件(如`UIView`或`UIButton`)拖动到设计图面，然后在`Identity Inspector`窗口的`Class`说明符中设置您的自定义控件名称。例如，在下面的截图中，我有一个继承自`UIView`的自定义控件，名为`RoundRectangleGroupView`。为了使用它，我将一个`UIView`放到了`Designer`上，然后在`Inspector`窗口中，我设置了它的类名，如图[图 6–6](#fig_6_6)所示。

![images](img/.jpg)

**图 6–6。** *在界面生成器中使用自定义控件*

在`Design`窗口中，视图只是显示为普通视图，但是当我在设备或模拟器上运行它时，我会看到我的定制。

### 原型 vs .代表 vs .事件，什么？

Objective-C 和 CocoaTouch 在处理用户交互和数据绑定方面有着与传统非常不同的约定。网络模型。例如，当绑定到 ASP.NET 的一个`DataGrid`时，您设置了`DataSource`属性，只要数据源实现了`IEnumerable`，网格就会为您完成工作。当用户选择一行时，网格会引发一个事件，告诉您选择了哪一行。

在 CocoaTouch，情况有所不同。例如，如果您正在处理一个表，您将一个数据源分配到您的表，但是该表调用您的数据源上的方法，询问那里有多少项，如何构建每个单元格，等等。当用户在表上选择一行时，您不需要引发一个您处理的事件，而是在表上分配一个特殊的类，它调用一个方法让您知道一行被选择了。由于这种模型，CocoaTouch 中的数据源必须符合它所绑定到的每种类型的控件。出于这个原因，数据源有了不同的含义，而不是简单地保存数据，它实际上是一个知道如何执行数据绑定的引擎。通常，在 CocoaTouch 中，您会为数据源分配一个模型(您的数据),这样它就可以在仅仅包含数据和实际知道如何进行数据绑定之间架起一座桥梁。

MonoTouch 试图通过保留苹果的做事方式来弥合这一差距，同时也提供 .NET 之类的方法。因此，有几种不同的方法来使用控件。

#### 协议

在 Objective-C 编程中，你会听到很多关于协议的内容。在 Apple 的世界中，协议类似于. NET 中的接口。协议定义了一个契约，调用方通过该契约知道某些方法将存在于符合该契约或接口的类中。例如，您可以定义一个接口`Iperson,`，它具有以下方法:

`Run(int howFar)`

区别在于，对于苹果的 API，协议上的方法实际上是可选的。如果运行时没有找到`Run`方法，也没关系；运行时就是不调用它。

这引发了一个有趣的问题。如果你在 MonoTouch 中实现一个协议，Objective-C 运行时需要能够“看到”你的方法。然而，因为 iOS 没有任何 C#的内在知识，所以您的方法对于 iOS 来说是不可见的，就像您编写 Objective-C 代码一样。

为了使您的方法对底层 Objective-C 运行时可见，您必须通过将它们修饰为`MonoTouch.Foundation.Export`属性来注册它们。例如，下面的代码，如[清单 6–11](#list_6_11)所示，将一个`DoSomeRunning`方法作为`Run`方法导出到 Objective-C 运行时。

**清单 6–11。** *使用导出属性使一个方法对 Objective-C 运行时可见*

`[Export (“Run”)]
public void DoSomeRunning(int howFarToRun) {...}`

请注意，C#方法名与导出的方法名不匹配。您可以随意命名您的方法，只要您使用运行库期望的方法导出它。

#### 代表们

用`Export`属性标记所有的方法可能相当乏味。首先，您必须确切地知道运行时期望的方法名是什么，其次，您必须知道签名是什么样子的。

MonoTouch 试图通过提供已经有这些方法和它们各自的`Export`属性的强类型委托基类来使这变得简单一些。

要使用它们，我们只需编写一个从适当的基类委托类派生的类，重写我们关心的方法，并将我们的类分配给需要它的任何类的委托属性。

这样做的好处之一是，如果我们在 MonoDevelop 中，我们只需在从委托派生的类中键入`override`,它会给我们自动完成功能，以及我们想要覆盖的任何方法的选项。这样我们就不必记住所有的方法和它们的签名了！

**注意:**当重写强类型委托类方法时，你不应该调用基本实现。例如，如果你正在覆盖`GetView`方法，你不应该在被覆盖的`GetView`实现中调用`base.GetView()`。

#### 弱势代表

你不必使用 MonoTouch 给你的强类型委托。您可以编写自己的自定义委托类，然后在您想要公开以处理回调的方法上用`Export`属性来修饰它们。为此，只需创建您的类，使用`Export`属性标记您的方法，然后将您的自定义类设置为任何需要委托的类的`WeakDelegate`属性。更多信息，请参见:`[http://monotouch.net/Documentation/API_Design.rf](http://monotouch.net/Documentation/API_Design.rf)`

当这样做时，您需要知道运行时期望的确切名称。幸运的是，Mono(和 MonoTouch)的创始人 Miguel de Icaza 在线更新了一个 Rosetta stone，它映射了 MonoTouch 方法(用于强类型委托)和苹果使用的方法。可以在这里找到:`[http://tirania.org/tmp/rosetta.html](http://tirania.org/tmp/rosetta.html)`。

**注意:**苹果的“方法”实际上叫做`selectors`，因为 Objective-C 是一种基于消息的语言，通过它你可以传递消息，而不是调用方法。使用选择器名称时，必须使用整个字符串，包括尾随冒号(如果有)。例如，下面的`Export`声明，如[清单 6–12](#list_6_12)所示，对于由`UITableView`调用以获取行标题文本的`titleForHeaderInSection`选择器来说是正确的。

**清单 6–12。** *导出时，选择器名称必须完全匹配，包括冒号。*

`[Export(“tableView:titleForHeaderInSection:”)]
protected string GetTitleForHeader(UITableView tableView, int section) {...}`

### 从 UI 线程更新你的控件

您经常会发现自己在执行长时间运行的操作和单独的线程，这样就可以保持 UI 的响应性。例如，假设您正在编写一个新闻阅读器应用，它从互联网上下载信息。您可能希望在后台线程上这样做，以便用户可以查看应用中的其他屏幕或与之交互，或者您可能希望在新闻条目出现时填充它们。

这一切都很好，直到你需要从那些线程中更新你的用户界面。两个后台进程试图同时更新 UI 线程，或者在 UI 执行某个操作时，一个后台进程试图更新 UI，这样就会出现问题。这可能导致线程锁和应用崩溃。在最好的情况下，MonoTouch 运行时实际上会给你一个运行时线程间异常，告诉你不应该从后台线程更新 UI，但是你甚至可能得不到这样的礼遇:MonoTouch 可能会因为一个无意义的错误而崩溃。

因此，您应该总是从主线程(也称为 UI 线程)更新您的 UI。但是你是怎么做到的呢？嗯，就像 WPF 或 Winforms 开发一样，MonoTouch 提供了一种方法来做到这一点。它叫做`InvokeOnMainThread`，在`UIView`级上可以买到。要使用`InvokeOnMainThread`，只需向它传递一个应该在主 UI 线程上运行的委托(或 lambda，或匿名方法)。一旦有空闲时间，iOS 将排队并运行该方法。

例如，下面的方法([清单 6–13](#list_6_13))来自`Example_StandardControls`配套应用中的`ActivityIndicatorAlertView`类。

**清单 6–13。** *调用主 UI 线程上的方法*

`public void Hide (bool animated)
{
        this.InvokeOnMainThread (delegate {
                   this.DismissWithClickedButtonIndex (0, animated);
        });
}`

`ActivityIndicatorAlertView`是一个定制的警报视图，显示一个旋转的活动指示器。它旨在后台进程运行时显示，然后在后台进程完成其工作时退出。因为后台进程可能在不同的线程上，`Hide`方法确保警报视图在 UI 线程上被消除。

**注意:**如果您想在主线程上进行异步调用，也可以使用`BeginInvokeOnMainThread`。然而，与正常情况下的`BeginInvoke/EndInvoke`模式不同 .NET 编程中，没有对调用完成通知的底层支持，因此没有`EndInvorkeOnMainThread`或类似的东西。

### 总结

本章向您介绍了控件，并为您提供了一些使用控件的基础知识，但是在您使用控件一段时间后，这里的许多概念和信息会变得更有意义。在接下来的几章中，我们将做到这一点:我们将探索 CocoaTouch 中的几乎每一个控件。