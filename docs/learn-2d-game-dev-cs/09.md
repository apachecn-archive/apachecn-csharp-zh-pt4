# 九、构建您的第一个 2D 游戏

完成本章后，您将能够:

*   开始设计一个 2D 游戏
*   枚举并指定游戏中元素的功能
*   将游戏元素规范翻译成 C#类
*   欣赏并使用 GameTime 类支持的准确性
*   将前面的元素合成为一个最终的有趣游戏
*   接近对你自己游戏的评价
*   开始调查发布你的最终游戏的程序

本章涵盖了使用本书中讨论的概念和技术创建你自己的简单游戏的过程和实现细节。它将展示你如何利用你已经生成的代码来实现简单的游戏，比如本章中描述的那个。事实上，本章描述的游戏是在一个周末创作出来的。这种类型的快速开发允许你快速创建你的想法的原型，或者仅仅专注于为你的目标受众创建一个有趣的和具有挑战性的体验。最后，在这一章的最后，讨论了发布你的游戏的一些注意事项，并提供了一些相关的参考资料以供进一步研究。

简单游戏:鱼食

在这个游戏中，玩家扮演一条沿着海底游动的鱼，试图游得越远越好。当它行进时，鱼会遇到几条敌人的鱼。玩家必须避开这些鱼，才能继续沿着海底前进。这种鱼在旅行中也会遇到蠕虫，为了长得更大，它会吃掉蠕虫。如果玩家的鱼被抓住，它将失去一个尺寸，如果是一个尺寸，游戏将结束，它走过的距离将被显示。玩家的鱼也可以向敌人的鱼发射气泡，以便在试图躲避它们时使它们昏迷几秒钟。

鱼类食品项目

这个项目演示了如何通过利用和修改本书的内容来创建一个简单的游戏。在游戏中，玩家控制一个英雄角色，并试图在被敌人抓住之前尽可能远地旅行。你可以在[图 9-1](#Fig1) 中看到这个项目运行的初始闪屏。

![9781430266044_Fig09-01.jpg](img/-01.jpg)

[图 9-1](#_Fig1) 。运行鱼食游戏

该项目的控制如下:

*   **左手拇指棒(WSAD 键)**移动那个英雄角色
*   按钮 A (K 键)发射泡泡或开始游戏

该项目的目标如下:

*   用一个不平凡的游戏体验整个游戏开发过程
*   体验游戏性描述到游戏元素规格的映射
*   迭代并指定一个非平凡游戏中的所有元素
*   体验每个游戏元素的类的编码和修改
*   合成 GameState 类中的所有游戏元素以支持游戏性

构建一个完整游戏的第一步其实不是编程；相反，这完全是关于设计的。对于鱼食游戏，我们首先指定游戏的完整功能，然后枚举游戏中每个元素的功能，包括游戏窗口、环境、英雄、食物、敌人和相机行为。这个完整的游戏规范被称为游戏设计文档。这个文档应该完整地描述游戏将如何进行。在开始实际编程之前，这些文档保持一致是非常重要的。这是因为通过修改描述来改变游戏元素的行为要比改变编程代码容易得多。

枚举完游戏设计后，创建项目的步骤如下:

1.  用最简单的行为构建对象，在本例中是 BubbleShot 类。
2.  创建英雄职业来代表玩家将要控制的鱼。
3.  修改 PatrolEnemy 职业，允许敌人使用精灵和其他自定义行为。
4.  创造敌人:水母，河豚和斗鱼类。
5.  创建 PatrolEnemySet 类来方便地处理敌人的集合。
6.  创建 FishFood 类来喂养英雄鱼。
7.  创建 EnvironmentGenerator 类来提供游戏环境。
8.  修改 GameState 类，在最终游戏的实现中加入前面所有的元素。

在开始之前，将以下资源(可以在 Chapter9\SourceCode\Resources 文件夹中找到)添加到您的内容项目中:

*   Break.xnb
*   Bubble.xnb
*   BUBBLE_1.xnb
*   Chomp.xnb
*   Eat.xnb
*   敌人 _1.xnb
*   敌人 _2.xnb
*   敌人 _3.xnb
*   GAMEOVERSCREEN_1.xnb
*   GROUND_1.xnb
*   HERO_1.xnb
*   Hit.xnb
*   记住，xnb
*   SEAWEEDSMALL_1.xnb
*   SEAWEEDTALL_1.xnb
*   SIGN_1.xnb
*   SPLASHSCREEN_1.xnb 版
*   Stun.xnb
*   Touch.xnb
*   WORM_1.xnb

鱼食游戏设计

在创建或实现游戏或原型之前，写下游戏的概念和功能总是一个好主意。这个文档可以成为你的游戏设计文档的基础。在开发游戏时，拥有一份设计文档通常是很重要的，因为它为你提供了游戏对象以及它们之间的交互或行为的概述。这对于较大的项目或者有多个团队成员的项目尤其重要。对于这个简单的游戏项目，由于其有限的大小和范围，一个基本功能的小总结和大纲将足以作为设计文档。

![image](img/.jpg) **注**请参考位于源代码[第 9 章](09.html)的 GameDesignDocTemplate.doc，获取一个完整的游戏设计文档模板的示例。

游戏功能概述

*   *目标和目的:*

*   尽可能远行
*   避免被其他鱼抓住
*   消耗食物来增加英雄的体型

*   *游戏*

*   无休止地向右滚动
*   你走得越远，产卵的鱼越多，难度就越大
*   显示英雄走过的距离和大小
*   提供开始和结束闪屏

*   *环境*

*   当镜头向右平移时，通过重复海底和一些海藻生成一个简单的无尽地形
*   以固定间隔生成显示行驶距离的标志

*   *英雄，由玩家控制*

*   可以上下左右移动
*   可以射出射弹来击晕敌人
*   可以改变大小

*   *食物*

*   以半随机的时间间隔周期性地落到海底
*   可以被英雄吃掉以增加它的体积

*   *敌人*

*   水母:可以向四面八方巡逻，当它们碰到英雄时会击晕英雄
*   河豚:在垂直方向巡逻，并在被触碰时减小英雄尺寸
*   斗鱼:在水平方向巡逻，并在被触碰时减少英雄的尺寸，除非英雄的尺寸更大
*   当英雄靠近时，所有的敌人都会追逐他

*   *摄像机*

*   将英雄束缚在屏幕上
*   当英雄穿过屏幕中央时，向右平移

您可以从创建最简单的对象开始。前面的设计大纲说明了英雄角色可以发射炮弹。投射或气泡镜头是非常基本的，它的所有行为都来自基类。

创建 *BubbleShot* 类 T3】

1.  首先创建一个名为 BubbleShot 的新类，它继承自 GameObject。您可能还记得，您之前实现的 GameObject 类为游戏对象提供了行为。为其大小和速度添加一个常量变量。初始化适当的变量并使用提供的气泡图。

    ```cs
    public class BubbleShot : GameObject
    {
        private const float kBubbleShotWidth = 7f;
        private const float kBubbleShotHeight = 7f;
        private const float kBubbleShotSpeed = 1.8f;

        public BubbleShot(Vector2 position, int facing)
            : base("BUBBLE_1", position,
                   new Vector2(kBubbleShotWidth, kBubbleShotHeight), null)
        {
            Speed = kBubbleShotSpeed;
            mVelocityDir = new Vector2(facing, 0);
        }
    }
    ```

2.  现在只需添加一个函数，利用您之前创建的 Camera 类返回 BubbleShot 当前是否在屏幕上。

    ```cs
    public bool IsOnScreen()
    {
        // take advantage of the camera window bound check
        Camera.CameraWindowCollisionStatus status = Camera.CollidedWithCameraWindow(this);
        return (Camera.CameraWindowCollisionStatus.InsideWindow == status);
    }
    ```

创造了*级英雄*级级

1.  创建一个名为 Hero 的新类，它继承自 SpritePrimitive。添加以下变量和函数，以便为英雄提供粒子支持。

    ```cs
    public class Hero : SpritePrimitive
    {
      #region Particle Stuff
      private const float kCollideParticleSize = 4f;
      private const int kCollideParticleLife = 20;

      ParticleSystem mCollisionEffect = new ParticleSystem();
      // to support particle system
      private ParticlePrimitive CreateParticle(Vector2 pos)
      {
        return new ParticlePrimitive(pos, kCollideParticleSize, kCollideParticleLife);
      }
      #endregion
      ...
    }
    ```

2.  接下来，为英雄尺寸、射击间隔时间、射击的偏移位置、英雄可以昏迷的时间以及英雄的最大成长尺寸添加以下常量。还要添加以下实例变量。请注意，英雄大小访问器也执行大小重新计算。

    ```cs
    //Constants
    private const float kHeroWidth = 20f;
    private const float kTimeBetweenBubbleShot = 1.5f;     // number of seconds between shots
    private const float kBubbleShotOffset = 0.35f * kHeroWidth;
    private const float kStunTimer = 1.5f;
    private const int kMaxHeroSize = 2;
    private float mTimeSinceLastShot = 0;
    private float mStunTimer;
    private int mHeroCurrentSize;
    public int HeroSize
    {
        get { return mHeroCurrentSize; }
        set
        {
            mHeroCurrentSize = value;
            this.Size = new Vector2(
                    kHeroWidth + kHeroWidth * (mHeroCurrentSize - 1) / 3,
                    kHeroWidth + kHeroWidth * (mHeroCurrentSize - 1) / 3);
        }
    }
    ```

3.  现在为主角的当前状态创建一个枚举，并为 BubbleShot 添加一个列表和访问器。

    ```cs
    private enum HeroState
    {
        Playing,
        Stunned,
        Unstunnable,
        Lost
    }
    private HeroState mCurrentHeroState;
    private List<BubbleShot> mBubbleShots;
    public List<BubbleShot> AllBubbleShots() { return mBubbleShots; }
    ```

4.  现在，您可以创建一个构造函数来初始化所需的实例变量。记得传入适当的 sprite 工作表，并将其初始化到起始帧。

    ```cs
    public Hero(Vector2 position)
        : base("HERO_1", position, new Vector2(kHeroWidth, kHeroWidth), 2, 2, 0)
    {
        mHeroCurrentSize = 1;
        mStunTimer = 0;
        mCurrentHeroState = HeroState.Playing;
        mBubbleShots = new List<BubbleShot>();
        mTimeSinceLastShot = kTimeBetweenBubbleShot;

        SetSpriteAnimation(0, 0, 1, 1, 10);
        SpriteCurrentRow = 1;
    }
    ```

5.  对于 update 函数，创建一个根据主角的当前状态更新的 switch 语句，如下所示。

    ```cs
    public void Update(GameTime gameTime, Vector2 delta, bool shootBubbleShot)
    {
        switch(mCurrentHeroState)
        {
            case HeroState.Playing:
                UpdatePlayingState(gameTime, delta, shootBubbleShot);
                break;
            case HeroState.Stunned:
                UpdateStunnedState(gameTime);
                break;
            case HeroState.Unstunnable:
                UpdateUnstunnableState(gameTime);
                UpdatePlayingState(gameTime, delta, shootBubbleShot);
                break;
            case HeroState.Lost:
                mCurrentHeroState = HeroState.Lost;
                break;
            default:
                break;
        }
    }
    ```

6.  为了英雄之州。播放、创建和调用函数

    ```cs
    public void UpdatePlayingState(GameTime gameTime, Vector2 delta, bool shootBubbleShot)
    {
        base.Update();
        // take advantage of the camera window bound check
        BoundObjectToCameraWindow();

        // Player control
        mPosition += delta;

        // Sprite facing direction
        if (delta.X > 0)
            SpriteCurrentRow = 1;
        else if (delta.X < 0)
            SpriteCurrentRow = 0;

        // BubbleShot direction
        int bubbleShotDir = 1;
        if (SpriteCurrentRow == 0)
            bubbleShotDir = -1;

        mCollisionEffect.UpdateParticles();

        float deltaTime = gameTime.ElapsedGameTime.Milliseconds;
        mTimeSinceLastShot += deltaTime / 1000;

        // Can the hero shoot a BubbleShot?
        if (mTimeSinceLastShot >= kTimeBetweenBubbleShot)
        {
            if (shootBubbleShot)
            {
                BubbleShot j = new BubbleShot(
                            new Vector2(Position.X + kBubbleShotOffset * bubbleShotDir,
                             Position.Y), bubbleShotDir);
                mBubbleShots.Add(j);
                mTimeSinceLastShot = 0;
                AudioSupport.PlayACue("Bubble");
            }
        }

        // now update all the BubbleShots out there ...
        int count = mBubbleShots.Count;
        for (int i = count - 1; i >= 0; i--)
        {
            if (!mBubbleShots[i].IsOnScreen())
            {
                // outside now!
                mBubbleShots.RemoveAt(i);
            }
            else
                mBubbleShots[i].Update();
        }
    }
    ```

    *   将主角限制在屏幕上
    *   将玩家输入应用到英雄的位置
    *   使精灵和泡泡朝向正确的方向
    *   更新粒子
    *   计算拍摄之间的时间间隔，并在可能的情况下拍摄气泡
    *   更新所有已拍摄的气泡
7.  为了英雄之州。晕眩，创建并调用一个实现晕眩定时器的函数。这很容易做到，通过每次更新所经过的时间来增加计时器。击晕英雄的动作来自于这个更新被调用的事实，而不是 UpdatePlayingState()函数。

    ```cs
    public void UpdateStunnedState(GameTime gameTime)
    {
        float deltaTime = gameTime.ElapsedGameTime.Milliseconds;
        mStunTimer += deltaTime / 1000;
        if (mStunTimer >= kStunTimer)
        {
            mStunTimer = 0;
            mCurrentHeroState = HeroState.Unstunnable;
        }
    }
    ```

8.  For HeroState.Unstunnable, create and call a function that transitions the hero from the stunned state to the playing state. This state is required to ensure that the hero is not stunned permanently. This can be accomplished by reusing the stun timer as shown in the following code.

    ```cs
    public void UpdateUnstunnableState(GameTime gameTime)
    {
        float deltaTime = gameTime.ElapsedGameTime.Milliseconds;
        mStunTimer += deltaTime / 1000;
        if (mStunTimer >= kStunTimer)
        {
            mStunTimer = 0;
            mCurrentHeroState = HeroState.Playing;
        }
    }
    ```

    ![image](img/.jpg) **注意**更新函数使用了游戏时间的参数类型。这是通过基本更新功能提供的。到目前为止，对于所有基于时间的计算，您都使用了更新分笔成交点的概念。这是特定操作之间更新函数调用的次数。虽然这样做效果很好，但并不总是理想的，因为每次更新函数调用之间的时间可能不同。GameTime 通过为您提供获取 ElapsedGameTime 的能力来精确计算更新函数调用之间的时间，从而弥补了更新函数调用之间的可变持续时间。有关 GameTime 的更多信息，请参考[http://msdn . Microsoft . com/library/Microsoft . xna . framework . game time(v = xnagamestudio . 40)。aspx](http://msdn.microsoft.com/library/microsoft.xna.framework.gametime(v=xnagamestudio.40).aspx) 。

9.  现在，您可以通过覆盖基本的 draw 函数来实现 Draw()，并绘制主角、气泡和粒子。

    ```cs
    public override void Draw()
    {
        base.Draw();
        foreach (var j in mBubbleShots)
            j.Draw();
        mCollisionEffect.DrawParticleSystem();
    }
    ```

10.  最后，功能需要提供简单的功能，如调整大小的英雄，昏迷的英雄，检查玩家是否已经失去了，并喂养英雄。这些函数的实现非常简单，如下面的代码所示。当当前英雄的大小小于 1 时，记得将当前英雄的状态设置为丢失。

    ```cs
    public void AdjustSize(int incAdjustment)
    {
        if (incAdjustment + HeroSize > kMaxHeroSize)
            return;
        HeroSize += incAdjustment;
        MathHelper.Clamp(HeroSize, 0, 3);
        if (HeroSize <= 0)
        {
            mCurrentHeroState = HeroState.Lost;
        }
    }

    public void StunHero()
    {
        if (mCurrentHeroState != HeroState.Unstunnable && mCurrentHeroState != HeroState.Stunned)
        {
            mCurrentHeroState = HeroState.Stunned;
            AudioSupport.PlayACue("Stun");
            AdjustSize(-1);
        }
    }

    public bool HasLost()
    {
        if (mCurrentHeroState == HeroState.Lost)
            return true;
        else
            return false;
    }

    public void Feed()
    {
        AdjustSize(1);
        AudioSupport.PlayACue("Chomp");
    }
    ```

英雄完成后，你现在可以开始为敌人做基础职业了。在游戏的设计大纲中，每个敌人都有自己的巡逻风格；由于这种通用性，一个经过大量修改的 PatrolEnemy 类可以用作基类。修改的广泛性是让敌人能够使用精灵和其他定制的行为。由于各种各样的变化，我们将提供整个类的快速分解。

修改*巡逻敌人*等级 T3】

1.  回想一下在第 6 章中引入的巡逻敌人职业是为了支持半自动行为。这里我们从改变 PatrolEnemy 类来继承 SpritePrimitive 类开始。然后，向 PatrolState 枚举添加一个名为 StunState 的新状态。还要创建一个名为 PatrolType 的新枚举。

    ```cs
    public class PatrolEnemy : SpritePrimitive
    {
        protected enum PatrolState
        {
            PatrolState,
            ChaseHero,
            StuntState
        }

        protected enum PatrolType
        {
            FreeRoam,
            LeftRight,
            UpDown
        }
        ...
    }
    ```

2.  现在添加下面的常量和颜色变量，如下面的代码所示，用于跟踪敌人的各种属性，如速度、攻击半径和大小。

    ```cs

        // Constants  ...
        private const float kPatrolSpeed = 0.2f;
        private const float kCloseEnough = 20f; // distance to trigger next patrol target
        private const float kDistToBeginChase = 40f; // distance to trigger patrol chasing of hero
        private const int kStateTimer = 60 * 5; // this is about 5 seconds
        private const int kStunCycle = kStateTimer / 2; // half of regular state timer
        private const float kChaseSpeed = 0.3f;
        protected const float kEnemyWidth = 10f;
        protected const int kInitFishSize = 1;

        private Color kPatrolTint = Color.White;
        private Color kChaseTint = Color.OrangeRed;
        private Color kStuntTint = Color.LightCyan;
    ```

3.  现在，您可以为状态计时器、销毁标志和鱼大小添加实例变量和后继变量。

    ```cs

        private Vector2 mTargetPosition;            // Target position we are moving towards
        private PatrolState mCurrentState;          // Current State
        protected PatrolType mCurrentPatrolType;    // Current Patrol Type
        protected EnemyType mCurrentEnemyType;
        protected bool mAllowRotate;

        private int mStateTimer;    // interestingly, with "gradual" velocity changing, we cannot
                                    // guarantee that we will ever reach the mTargetPosition
                                    // (we may ended up orbiting the target), so we set a timer
                                    // when timer is up, we transit

        private bool mDestoryFlag;
        public bool DestoryFlag { get { return mDestoryFlag; } }

        protected int mFishSize;
        public int FishSize
        {
            get { return mFishSize; }
            set
            {
                mFishSize = value;
                this.Size = new Vector2(mFishSize * kEnemyWidth + kEnemyWidth,
                                        mFishSize * kEnemyWidth + kEnemyWidth);
            }
        }
    ```

4.  接下来是构造函数和参数支持，用于通过使用基类初始化 sprite 表，以及将变量初始化为它们的默认值，如下面的代码所示。不要忘记设置精灵工作表的当前帧和滴答速率。此外，显示的许多值将被从 PatrolEnemy 继承的类覆盖。

    ```cs
    public PatrolEnemy(String image, Vector2 position, Vector2 size, int rowCounts, int columnCount, int padding) :
            base(image, position, size, rowCounts, columnCount, padding)
        {
            // causes update state to always change into a new state
            mTargetPosition = Position = Vector2.Zero;
            Velocity = Vector2.UnitY;
            mTintColor = kPatrolTint;
            mCurrentPatrolType = PatrolType.FreeRoam;
            Position = RandomPosition(true);
            mDestoryFlag = false;
            mAllowRotate = false;
            SetSpriteAnimation(0, 0, 1, 1, 10);
            FishSize = kInitFishSize;
            mCurrentEnemyType = EnemyType.BlowFish;
        }
    ```

5.  现在我们可以实现更新功能了。在该功能中，如果敌人没有被击晕，可以执行更新位置和速度以及敌人面对方向等常见操作。此外，当敌人巡逻和追逐英雄时，使用一个开关盒来调用更新功能。

    ```cs
    public bool UpdatePatrol(Hero hero, out Vector2 caughtPos)
    {
        bool caught = false;
        caughtPos = Vector2.Zero;

        mStateTimer--;

        // perform operation common to all states ...
        if (mCurrentState != PatrolState.StuntState)
        {
            base.Update();
            Vector2 toHero = hero.Position - Position;
            toHero.Normalize();
            Vector2 toTarget = mTargetPosition - Position;
            float distToTarget = toTarget.Length();
            toTarget /= distToTarget; // this is the same as normalization
            ComputeNewDirection(toTarget, toHero);

            switch (mCurrentState)
            {
                case PatrolState.PatrolState:
                     UpdatePatrolState(hero, distToTarget);
                     break;

                case PatrolState.ChaseHero:
                     caught = UpdateChaseHeroState(hero, distToTarget, out caughtPos);
                     break;
            }
        }
        else
        {
            UpdateStuntState(hero);
        }
        return caught;
    }
    ```

    1.  创建 UpdatePatrolState()函数，它根据 PatrolType 更新敌人的状态。如果已经到达目的地或者状态计时器超时，您可以看到根据 PatrolType 调用了不同的目标生成函数。此外，还需要进行一次检查，看看敌人是否应该追击英雄。

        ```cs
        private void UpdatePatrolState(GameObject hero, float distToTarget)
        {
             if ((mStateTimer < 0) || (distToTarget < kCloseEnough))
             {
                 switch (mCurrentPatrolType)
                 {
                    case PatrolType.FreeRoam:
                         RandomNextTarget();
                         break;
                    case PatrolType.LeftRight:
                         GenerateLeftRightTarget();
                         break;
                    case PatrolType.UpDown:
                         GenerateUpDownTarget();
                         break;
                }
            }
            DetectHero(hero); // check if we should transit to ChaseHero
        }
        ```

    2.  现在创建 UpdateChaseHeroState()函数，该函数处理与英雄碰撞时敌人的反应。你可以看到，根据敌人的类型，会有不同的反应。对于河豚，英雄尺寸减小，河豚被消灭；对于水母，英雄惊呆了；对于斗鱼来说，要进行大小比较，要么英雄以斗鱼为食，要么相反。此外，如果状态定时器已经到期并且鱼没有被捕获，则选择新的随机目标。

        ```cs
        private bool UpdateChaseHeroState(Hero hero, float distToHero, out Vector2 pos)
        {
            bool caught = false;
            caught = PixelTouches(hero, out pos);
            mTargetPosition = hero.Position;

            if (caught)
            {
                switch (mCurrentEnemyType)
                {
                     case EnemyType.BlowFish:
                         hero.AdjustSize(-1);
                         this.FishSize--;
                         this.mDestoryFlag = true;
                         break;
                    case EnemyType.JellyFish:
                         hero.StunHero();
                         break;
                    case EnemyType.FightingFish:
                         if (hero.HeroSize > this.FishSize)
                         {
                            this.FishSize--;
                            this.mDestoryFlag = true;
                            hero.Feed();
                         }
                         else if (hero.HeroSize <= this.FishSize)
                         {
                            this.FishSize--;
                            this.mDestoryFlag = true;
                            hero.AdjustSize(-1);
                         }
                         break;
                    default:
                         break;
                }
            }
            else if (mStateTimer < 0)
                RandomNextTarget();

            return caught;
        }
        ```

    3.  在 UpdateStuntState()函数中，只需等待状态定时器到期，然后转换到追逐状态。

        ```cs
        private void UpdateStuntState(Hero hero)
        {
            if (mStateTimer < 0)
                SetToChaseState(hero);
        }
        ```

6.  接下来，添加在状态之间改变的功能，简单地修改敌人的当前色调颜色、播放和音频提示，并设置当前状态。

    ```cs
    public void SetToStuntState()
    {
        mTintColor = kStuntTint;
        mStateTimer = kStunCycle;
        mCurrentState = PatrolState.StuntState;
        AudioSupport.PlayACue("Stun");
    }
    ```

7.  创建一个简单的函数来检测英雄是否在追逐的距离内。如果有，改变敌人的状态。

    ```cs
    private void DetectHero(GameObject hero)
    {
        Vector2 toHero = hero.Position - Position;
        if (toHero.Length() < kDistToBeginChase)
            SetToChaseState(hero);
    }
    ```

8.  ComputeNewSpeedAndResetTimer()函数与之前版本的《巡逻之敌》保持不变。

    ```cs
    private void ComputeNewSpeedAndResetTimer()
    {
        Speed = kPatrolSpeed * (0.8f + (float)(0.4 * Game1.sRan.NextDouble()));
                                                     // speed: ranges between 80% to 120
        mStateTimer = (int)(kStateTimer * (0.8f + (float)(0.6 * Game1.sRan.NextDouble())));
    }
    ```

9.  在 ComputeNewDirection()函数中，由于游戏的侧滚性质，如果我们允许敌人完全旋转，他们的脸会看起来很奇怪。为了避免这一点，增加了一个新的情况，只允许敌人根据面对的方向向左或向右看。这是通过使用精灵表来完成的。对于像水母这样没有脸的敌人，现有的代码仍然有效。

    ```cs
    private void ComputeNewDirection(Vector2 toTarget, Vector2 toHero)
    {
        if (mAllowRotate)
        {
            // figure out if we should continue to adjust our direction ...
            double cosTheta = Vector2.Dot(toTarget, FrontDirection);
            float theta = (float)Math.Acos(cosTheta);
            if (theta > float.Epsilon)
            {
                Vector3 frontDir3 = new Vector3(FrontDirection, 0f);
                Vector3 toTarget3 = new Vector3(toTarget, 0f);
                Vector3 zDir = Vector3.Cross(frontDir3, toTarget3);
                RotateAngleInRadian -= Math.Sign(zDir.Z) * 0.03f * theta;
                                            // rotate 5% at a time towards final direction
                VelocityDirection = FrontDirection;
            }
        }
        else
        {
            VelocityDirection = toTarget;
            if (VelocityDirection.X > 0)
                SpriteCurrentRow = 1;
            else if (VelocityDirection.X < 0)
                SpriteCurrentRow = 0;
        }
    }
    ```

10.  下一组函数都与生成一个新的随机目标有关。在先前版本的 PatrolEnemy 中，您实现了 RandomNextTarget()，除了增加了更改敌人的色调颜色之外，它基本上保持不变。然而，增加了这一概念的两个新变体。一个垂直生成目标，另一个水平生成目标。在这些函数中，如果您检查下面的代码，您会注意到摄像机被引用，以便在屏幕上保持巡逻目标，除了在左右巡逻时。

    ```cs
    private void RandomNextTarget()
    {
        mStateTimer = kStateTimer;
        mCurrentState = PatrolState.PatrolState;
        mTintColor = kPatrolTint;
        // Generate a random begin state
        double initState = Game1.sRan.NextDouble();
        ...
        ComputeNewSpeedAndResetTimer();
    }

    private void GenerateUpDownTarget()
    {
        mStateTimer = kStateTimer;
        mCurrentState = PatrolState.PatrolState;
        mTintColor = kPatrolTint;
        float posY;
        float distToTopOfScreen = Camera.CameraWindowUpperLeftPosition.Y - PositionY;
        float distToBottomOfScreen = PositionY - Camera.CameraWindowLowerLeftPosition.Y;
        if (distToTopOfScreen >= distToBottomOfScreen)
        {
            posY = (float)Game1.sRan.NextDouble() *
                    distToTopOfScreen / 2 * 0.80f + PositionY + distToTopOfScreen / 2;
        }
        else
        {
            posY = (float)Game1.sRan.NextDouble() *
                    -distToBottomOfScreen / 2 * 0.80f + PositionY - distToBottomOfScreen / 2;
        }

        mTargetPosition = new Vector2(PositionX, posY);
        ComputeNewSpeedAndResetTimer();
    }

    private void GenerateLeftRightTarget()
    {
        mStateTimer = kStateTimer;
        mCurrentState = PatrolState.PatrolState;
        mTintColor = kPatrolTint;
        float posX;
        if (Velocity.X <= 0)
        {
            posX = (float)Game1.sRan.NextDouble() * Camera.Width /2 + PositionX;
        }
        else
        {
            posX = (float)Game1.sRan.NextDouble() * -Camera.Width /2 + PositionX;
        }
        mTargetPosition = new Vector2(posX, PositionY);
        ComputeNewSpeedAndResetTimer();
    }
    ```

11.  ComputePoint()函数确保敌人可以在屏幕外生成目标。你会注意到 Y 值总是在摄像机的范围内，但是 X 值根据敌人的位置而变化。

    ```cs
    private const float sBorderRange = 0.55f;
    private Vector2 ComputePoint(double xOffset, double yOffset)
    {
        Vector2 min = new Vector2(PositionX - Camera.Width/2,
                                  Camera.CameraWindowLowerLeftPosition.Y);
        Vector2 max = new Vector2(PositionX + Camera.Width / 2,
                                  Camera.CameraWindowUpperLeftPosition.Y);
        Vector2 size = max - min;
        float x = min.X + size.X * (float)(xOffset + (sBorderRange * Game1.sRan.NextDouble()));
        float y = min.Y + size.Y * (float)(yOffset + (sBorderRange * Game1.sRan.NextDouble()));
        return new Vector2(x, y);
    }
    ```

12.  随机位置函数都很少或没有变化。您可以在下面的代码中看到这一点。

    ```cs
    const float kMinOffset = -0.05f;
    private Vector2 RandomBottomRightPosition()
    {
        return ComputePoint(0.5, kMinOffset);
    }
    ...
    ```

13.  您需要实现的最后一个函数用于为产卵的敌人生成一个相机外的随机位置。这很容易通过在摄像机视野内获得一个随机位置，然后向右移动该位置来实现。

    ```cs
    public Vector2 RandomPosition(bool offCamera)
    {
        Vector2 position;
        float posX = (float)Game1.sRan.NextDouble() * Camera.Width * 0.80f
                                    + Camera.Width * 0.10f;
        float posY = (float)Game1.sRan.NextDouble() * Camera.Height * 0.80f
                                    + Camera.Height * 0.10f;

        if(offCamera)
            posX += Camera.CameraWindowUpperRightPosition.X;

        position = new Vector2(posX, posY);
        return position;
    }
    ```

现在 PatrolEnemy 类已经被修改为支持多种行为，它可以作为游戏敌人类型的基类。在之前定义的游戏设计大纲中，有三种敌人类型，每种都有自己的行为。这三种敌人类型现在可以很容易地通过更改 PatrolEnemy 类中定义的 mCurrentEnemyType 变量的值来表示。

创造出*水母*、*河豚*、*斗鱼*类

1.  首先创建一个名为水母的新类，它继承自 PatrolEnemy。初始化以下变量，以便给水母所需的行为。记住通过调用基本构造函数来使用正确的 sprite 工作表图像和相应的设置。精灵表由两个精灵组成；因此，行数设置为 2，列数设置为 1。

    ```cs
    public class JellyFish : PatrolEnemy
    {
        public JellyFish() :
            base("ENEMY_3", Vector2.Zero,
                 new Vector2(kInitFishSize * kEnemyWidth + kEnemyWidth,
                 kInitFishSize * kEnemyWidth + kEnemyWidth), 2, 1, 0)
        {
            mAllowRotate = true;
            mInitFrontDir = Vector2.UnitY;
            mCurrentPatrolType = PatrolType.FreeRoam;
            FishSize = kInitFishSize;
            mCurrentEnemyType = EnemyType.JellyFish;
        }
    }
    ```

2.  现在创建一个名为 BlowFish 的新类，它继承自 PatrolEnemy。将其行为变量初始化为以下值。记得利用河豚雪碧表。请注意，在基本构造函数中，列计数现在设置为 2。这是因为 BlowFish 精灵表由四个精灵组成。

    ```cs
    public class BlowFish : PatrolEnemy
    {
        public BlowFish() :
            base("ENEMY_1", Vector2.Zero,
                  new Vector2(kInitFishSize * kEnemyWidth + kEnemyWidth,
                  kInitFishSize * kEnemyWidth + kEnemyWidth), 2, 2, 0)
        {
            mAllowRotate = false;
            mInitFrontDir = Vector2.UnitX;
            mCurrentPatrolType = PatrolType.UpDown;
            FishSize = kInitFishSize;
            mCurrentEnemyType = EnemyType.BlowFish;
        }
    }
    ```

3.  最后，创建一个名为 FightingFish 的新类，它继承自 PatrolEnemy。将其行为初始化为以下值，并将正确的 sprite 表传递给基本构造函数。

    ```cs
    public class FightingFish : PatrolEnemy
    {
        public FightingFish() :
            base("ENEMY_2", Vector2.Zero,
                 new Vector2(kInitFishSize * kEnemyWidth + kEnemyWidth,
                 kInitFishSize * kEnemyWidth + kEnemyWidth), 2, 2, 0)
        {
            mAllowRotate = false;
            mInitFrontDir = Vector2.UnitX;
            mCurrentPatrolType = PatrolType.LeftRight;
            FishSize = kInitFishSize;
            mCurrentEnemyType = EnemyType.FightingFish;
        }
    }
    ```

现在所有的敌人都已经被创造出来了，通过控制敌人的创造和毁灭来组织敌人的职业就可以实现了。这是通过创建一个包含敌人的类来实现的，就像你在之前的项目中所做的一样。这种组合对象以形成更复杂对象的概念在面向对象编程中被称为组合。

创建 *PatrolEnemySet* 类 T3】

1.  Create a new class called PatrolEnemySet. Similarly to the Hero, add static variables and functions for supporting particles. Next, add a constant for the number of enemies to spawn initially. Lastly, add a list to hold all the enemies and a distance interval at which a new enemy will be added.

    ```cs
    public enum EnemyType
    {
        BlowFish = 0,
        JellyFish = 1,
        FightingFish = 2
    }

    public class PatrolEnemySet
    {
        #region Particles
        private const float kCollideParticleSize = 3f;
        private const int kCollideParticleLife = 80;
        private static ParticleSystem sCollisionEffect = new ParticleSystem();
        // to support particle system
        static private ParticlePrimitive CreateRedParticle(Vector2 pos)
        {
            return new ParticlePrimitive(pos, kCollideParticleSize, kCollideParticleLife);
        }
        static private ParticlePrimitive CreateDarkParticle(Vector2 pos)
        {
            return new DarkParticlePrimitive(pos,
                    kCollideParticleSize, kCollideParticleLife);
        }
        #endregion

        private List<PatrolEnemy> mTheSet = new List<PatrolEnemy>();
        private float mAddEnemyDistance = 100f;

        //Constants
        private const int kNumEnemies = 5;

        ...
    }
    ```

    ![image](img/.jpg) **注意**在 PatrolEnemySet 上面增加了一个 enum，叫做 EnemyType 这是为了提供对类型的命名空间范围的访问。还要注意，每种类型都有一个与之相关联的不同整数。

2.  接下来，在构造函数中，通过调用 SpawnRandomPatrolEnemy()创建敌人，并将他们添加到集合中。

    ```cs
    public PatrolEnemySet()
    {
        // Create many ...
        for (int i = 0; i < kNumEnemies; i++)
        {
            PatrolEnemy e = SpawnRandomPatrolEnemy();
            mTheSet.Add(e);
        }
    }
    ```

3.  现在创建 SpawnRandomPatrolEnemy()函数。通过获取一个随机数并根据其值实例化相应的敌人类型，可以很容易地做到这一点。

    ```cs
    public PatrolEnemy SpawnRandomPatrolEnemy()
    {
        int randNum = (int)(Game1.sRan.NextDouble() * 3);
        PatrolEnemy enemy = null;
        switch (randNum)
        {
            case (int)EnemyType.BlowFish:
                enemy = new BlowFish();
                break;
            case (int)EnemyType.JellyFish:
                enemy = new JellyFish();
                break;
            case (int)EnemyType.FightingFish:
                enemy = new FightingFish();
                break;
            default:
                break;

        }
        return enemy;
    }
    ```

4.  现在创建更新函数。在其中，首先计算是否应该增加一个额外的敌人，然后移除被摧毁的敌人，重生新的敌人，更新现有的敌人，并检查与英雄射击的气泡的碰撞。最后，记得更新粒子和复活镜头外的敌人。

    ```cs
    public int UpdateSet(Hero hero)
    {
        int count = 0;
        Vector2 touchPos;

        //Add an enemy at 100m and every 50 after
        //Should an additional enemy be added?
        if (hero.PositionX / 20 > mAddEnemyDistance)
        {
            PatrolEnemy e = SpawnRandomPatrolEnemy();
            mTheSet.Add(e);
            mAddEnemyDistance += 50;
        }

        // destroy and respawn, update and collide with bubbles
        for (int i = mTheSet.Count - 1; i >= 0; i--)
        {
            if (mTheSet[i].DestoryFlag)
            {
                mTheSet.Remove(mTheSet[i]);
                mTheSet.Add(SpawnRandomPatrolEnemy());
                continue;
            }

            if (mTheSet[i].UpdatePatrol(hero, out touchPos))
            {
                sCollisionEffect.AddEmitterAt(CreateRedParticle, touchPos);
                count++;
            }

            List<BubbleShot> allBubbleShots = hero.AllBubbleShots();
            int numBubbleShots = allBubbleShots.Count;
            for (int j = numBubbleShots - 1; j >= 0; j--)
            {
                if (allBubbleShots[j].PixelTouches(mTheSet[i], out touchPos))
                {
                    mTheSet[i].SetToStuntState();
                    allBubbleShots.RemoveAt(j);
                    sCollisionEffect.AddEmitterAt(CreateRedParticle, touchPos);
                }
            }
        }

        sCollisionEffect.UpdateParticles();
        RespawnEnemies();
        return count;
    }
    ```

5.  创建一个函数来重生摄像机左侧的敌人。这很容易通过检查敌人的 X 位置和相机的左侧位置来完成。

    ```cs
    // Respawn enemies that are off to the left side of the camera
    public void RespawnEnemies()
    {
        for (int i = mTheSet.Count - 1; i >= 0; i--)
        {
            if (mTheSet[i].PositionX < (Camera.CameraWindowLowerLeftPosition.X - mTheSet[i].Width))
            {
                mTheSet.Remove(mTheSet[i]);
                mTheSet.Add(SpawnRandomPatrolEnemy());
            }
        }
    }
    ```

6.  最后，创建绘制函数来绘制每个敌人和粒子。

    ```cs
    public void DrawSet()
    {
        foreach (var e in mTheSet)
            e.Draw();

        sCollisionEffect.DrawParticleSystem();
    }
    ```

现在已经创建了三种敌人类型，最后需要的交互对象是食物。该设计表明，食物可以被英雄鱼吃掉，并会定期从屏幕顶部落下。这种行为类似于第五章中的简单物理项目，你只是对物体施加一个向下的垂直速度。

创建*鱼食*类

1.  首先创建一个名为 FishFood 的新类，它继承自 SpritePrimitive。为食物的大小添加一个常量，并添加一个 bool 标志来跟踪食物的移动状态。

    ```cs
    public class FishFood : SpritePrimitive
    {
        private const float kFoodSize = 8;
        private bool mCanMove;

        ...
    }
    ```

2.  现在添加一个构造函数，将必要的变量初始化为以下值。利用提供的蠕虫精灵表。记得设置精灵动画的开始帧和滴答计时器。

    ```cs
    public FishFood() :
        base("WORM_1", Vector2.Zero, new Vector2(kFoodSize, kFoodSize), 2, 1, 0)
    {
        Position = RandomPosition(true);
        SetSpriteAnimation(0, 0, 1, 1, 10);
        mCanMove = true;
        Speed = 0.2f;
    }
    ```

3.  接下来，创建它的更新函数。每次更新时，首先检查食物是否从屏幕右侧进入相机的视野。如果是这样，请向下移动。然后，检查食物是否已经离开屏幕的左侧。如果是这样，将它移到摄像机外的新位置。更新函数的最后一部分是检查它的冲突。如果它与英雄碰撞，喂英雄并且在镜头外重生食物。如果它与海床或海藻相撞，只需停止它的运动。

    ```cs
    public void Update(Hero hero, List<Platform> floor, List<Platform> seaweed)
    {
        if (Camera.CameraWindowUpperRightPosition.X > PositionX && mCanMove)
        {
            VelocityDirection = new Vector2(0, -1);
            Speed = 0.2f;
            base.Update();
        }

        if (Camera.CameraWindowUpperLeftPosition.X > PositionX)
        {
            Position = RandomPosition(true);
            mCanMove = true;
        }

        Vector2 vec;
        if (hero.PixelTouches(this, out vec))
        {
            Stop();
            hero.Feed();
            Position = RandomPosition(true);
            mCanMove = true;
        }
        for (int i = 0; i < floor.Count; i++)
        {
            if (floor[i].PixelTouches(this, out vec))
            {
                Stop();
            }
        }
        for (int i = 0; i < seaweed.Count; i++)
        {
            if (seaweed[i].PixelTouches(this, out vec))
            {
                Stop();
            }
        }
    }
    ```

4.  增加一个计算随机位置的函数，在镜头外产生食物。这个函数类似于你在巡逻敌人类中创建的随机位置函数，除了因为你想让食物从屏幕顶部落下，Y 位置总是被设置为相机的最大 Y 值。

    ```cs
    private Vector2 RandomPosition(bool offCamera)
    {
        Vector2 position;
        float posX = (float)Game1.sRan.NextDouble() * Camera.Width * 0.80f + Camera.Width * 0.10f;
        float posY = Camera.CameraWindowUpperRightPosition.Y;

        if (offCamera)
            posX += Camera.CameraWindowUpperRightPosition.X + Camera.Width*2;

        position = new Vector2(posX, posY);
        return position;
    }
    ```

5.  需要的最后一个函数是 Stop()函数；这只是禁止食物移动，直到它在其他地方被启用。

    ```cs
    private void Stop()
    {
        mCanMove = false;
        Velocity = Vector2.Zero;
        Speed = 0;
    }
    ```

创建了游戏的所有对象后，现在你需要一种方法来创建一个环境并在其中填充敌人。在游戏大纲中，写明了环境会无休止的进行下去。乍看之下，无穷无尽的概念似乎令人望而生畏；然而，在这样一个简单的游戏中，这很容易完成。

到目前为止，我们已经实现了英雄的自我保护机制(BubbleShot)、英雄、敌人行为(PatrolEnemy)、敌人(水母、河豚和战斗鱼)、敌人的收集集(PatrolEnemySet)和英雄的食物(FishFood)，我们需要做的就是定义背景(EnvironmentGenerator)和游戏逻辑(GameState)来将所有这些类联系在一起。

创建*环境生成器*类 T3】

1.  首先创建一个名为 EnvironmentGenerator 的类。为地板和小而高的海藻添加一个平台对象列表。此外，为标志、敌人和食物添加变量。最后，创建如下代码所示的常量。

    ```cs
    public class EnvironmentGenerator
    {
        private List<Platform> mTheFloorSet;
        private List<Platform> mTheSeaweedTallSet;
        private List<Platform> mTheSeaweedSmallSet;
        private Platform mTheSign;
        private PatrolEnemySet mEnemies;
        private FishFood mFishFood;

        private int mOffsetCounter;
        private const int kSectionSize = 800;
        private const int kFloorAndRoofSize = 40;
        private const int kSignSize = 30;
        private const int kInitialSignPosX = 100;
        private const int kSignUnitScaler = 20;

        ...
    }
    ```

2.  现在创建一个负责将环境设置为初始状态的构造函数。你可以通过创建地板、海藻、敌人、标志和食物来实现这一点。请注意，地板被布置在屏幕的底部，五种又高又小的海藻随机分布在屏幕上。

    ```cs
    public void InitializeEnvironment()
    {
        Camera.SetCameraWindow(Vector2.Zero, 300);
        mOffsetCounter = -20;
        mTheFloorSet = new List<Platform>();
        mTheSeaweedTallSet = new List<Platform>();
        mTheSeaweedSmallSet = new List<Platform>();

        mEnemies = new PatrolEnemySet();

        for (int i = 0; i < kSectionSize / kFloorAndRoofSize; i++)
        {
            mOffsetCounter += kFloorAndRoofSize;
            mTheFloorSet.Add(new
            Platform("GROUND_1",
                    new Vector2(mOffsetCounter, 20),
                    new Vector2(kFloorAndRoofSize, kFloorAndRoofSize)));
        }

        mTheSign = new Platform("SIGN_1",
                    new Vector2(kInitialSignPosX, kFloorAndRoofSize / 2 + kSignSize / 2),
                    new Vector2(kSignSize, kSignSize));

        float randNum;
        for (int i = 0; i < 5; i++)
        {
            randNum = (float)Game1.sRan.NextDouble() *
                            mTheFloorSet[mTheFloorSet.Count - 1].PositionX + kInitialSignPosX * 2;
            mTheSeaweedTallSet.Add(new Platform("SEAWEEDTALL_1",
                            new Vector2(randNum, kFloorAndRoofSize),
                            new Vector2(kFloorAndRoofSize / 1.5f, kFloorAndRoofSize * 1.5f)));
        }

        for (int i = 0; i < 5; i++)
        {
            randNum = (float)Game1.sRan.NextDouble() *
                            mTheFloorSet[mTheFloorSet.Count - 1].PositionX;
            mTheSeaweedSmallSet.Add(new Platform("SEAWEEDSMALL_1",
                            new Vector2(randNum, kFloorAndRoofSize / 2 - 5),
                            new Vector2(kFloorAndRoofSize / 2, kFloorAndRoofSize / 2)));
        }

        mFishFood = new FishFood();
    }
    ```

3.  现在，您可以创建一个更新函数来支持地形的无限再生。有几种方法可以实现这一点，但最直接的方法之一是简单地将对象从相机左侧移动到屏幕右侧的新的相机外位置。地板的长度大于摄像机的宽度，当摄像机的右侧到达最后一块地砖时，整个地板阵列向前移动。这可以在没有任何明显瑕疵的情况下完成，因为所有的地砖都是一样的。最后，标志沿着海床以不同的间隔重新张贴。

    ```cs
    public void Update(Hero theHero)
    {
        mFishFood.Update(theHero, mTheFloorSet, mTheSeaweedTallSet);
        mEnemies.UpdateSet(theHero);

        if (Camera.CameraWindowLowerRightPosition.X >
                    mTheFloorSet[mTheFloorSet.Count - 1].Position.X)
        {
            for (int i = 0; i < mTheFloorSet.Count; i++)
            {
                mTheFloorSet[i].PositionX += kFloorAndRoofSize * 10;
            }

            float randNum;
            for (int i = 0; i < mTheSeaweedTallSet.Count; i++)
            {
                if (mTheSeaweedTallSet[i].PositionX <
                            Camera.CameraWindowLowerLeftPosition.X - mTheSeaweedTallSet[i].Width)
                {
                    randNum = (float)Game1.sRan.NextDouble() * kSectionSize / 2
                                    + Camera.CameraWindowLowerRightPosition.X;
                    mTheSeaweedTallSet[i].PositionX = randNum;
                }
            }

            for (int i = 0; i < mTheSeaweedSmallSet.Count; i++)
            {
                if (mTheSeaweedSmallSet[i].PositionX <
                            Camera.CameraWindowLowerLeftPosition.X - mTheSeaweedTallSet[i].Width)
                {
                    randNum = (float)Game1.sRan.NextDouble() * kSectionSize / 2
                                    + Camera.CameraWindowLowerRightPosition.X;
                    mTheSeaweedSmallSet[i].PositionX = randNum;
                }
            }
        }

        if ((Camera.CameraWindowLowerLeftPosition.X - mTheSign.Width) > mTheSign.PositionX)
        {
            if (mTheSign.PositionX == kInitialSignPosX)
                mTheSign.PositionX = 0;
            mTheSign.PositionX += 500;
        }
    }
    ```

4.  现在您可以创建 draw 函数了。这只是调用这个环境对象的每个 Draw()方法，包括敌人和食物的方法。此外，请注意，标志的位置是通过其标签打印出来的。

    ```cs
    public void Draw()
    {
        for (int i = 0; i < mTheFloorSet.Count; i++)
            mTheFloorSet[i].Draw();

        mTheSign.Draw();
        String msg = (mTheSign.Position.X / 20).ToString() + "m";

        FontSupport.PrintStatusAt(mTheSign.Position, msg, Color.Black);

        for (int i = 0; i < mTheSeaweedTallSet.Count; i++)
            mTheSeaweedTallSet[i].Draw();

        for (int i = 0; i < mTheSeaweedSmallSet.Count; i++)
            mTheSeaweedSmallSet[i].Draw();

        mEnemies.DrawSet();
        mFishFood.Draw();
    }
    ```

现在已经创建了游戏所需的所有对象，是时候修改游戏状态以利用它们了。游戏状态将处理控件的逻辑、平移摄像机和游戏屏幕之间的切换。

修改*游戏状态*类 T3】

1.  首先为 GameState 对象的三种不同状态添加 enum。然后，为闪屏、环境生成器、英雄和旅行距离添加实例变量。

    ```cs
    public class GameState
    {
        public enum GameStates
        {
            StartScreen,
            Playing,
            Dead
        }

        private int mDistantTraveled = 0;
        private GameStates mCurrentGameState;
        private TexturedPrimitive mSplashScreen;
        private TexturedPrimitive mGameOverScreen;
        private EnvironmentGenerator mEnvironment;
        private Hero mHero;

        ...

    }
    ```

2.  接下来，在构造函数中，将当前游戏状态设置为 StartScreen，启动背景音乐，初始化开始菜单。在开始菜单的初始化中，将启动画面设置为相机的视角，并通知用户如何开始游戏。

    ```cs
    public GameState()
    {
        mCurrentGameState = GameStates.StartScreen;
        AudioSupport.PlayBackgroundAudio("Mind_Meld", 0.5f);
        InitializeStartMenu();
    }

    public void InitializeStartMenu()
    {
        float centerX = Camera.CameraWindowUpperRightPosition.X - Camera.Width/2;
        float centerY = Camera.CameraWindowUpperRightPosition.Y- Camera.Height/2;

        mSplashScreen = new TexturedPrimitive("SPLASHSCREEN_1",
                    new Vector2(centerX, centerY), new Vector2(Camera.Width, Camera.Height));
        String msg = "Press the 'K' key to start.";
        mSplashScreen.Label = msg;
        mSplashScreen.LabelColor = Color.Black;
    }
    ```

3.  接下来，创建函数来初始化游戏和屏幕上的游戏。当游戏初始化时，只需实例化英雄和环境。当屏幕上的游戏初始化时，实例化闪屏上的游戏，并通知玩家他们已经走了多远。

    ```cs
    public void InitializeGamePlay()
    {
        mHero = new Hero(new Vector2(20f, 30f));
        mEnvironment = new EnvironmentGenerator();
    }

    public void InitializeGameOverScreen()
    {
        float centerX = Camera.CameraWindowUpperRightPosition.X - Camera.Width/2;
        float centerY = Camera.CameraWindowUpperRightPosition.Y- Camera.Height/2;

        mGameOverScreen = new TexturedPrimitive("GAMEOVERSCREEN_1",
                            new Vector2(centerX, centerY),
                            new Vector2(Camera.Width, Camera.Height));
        String msg = mDistantTraveled +  "m traveled. Press the 'K' key to try agian.";
        mGameOverScreen.Label = msg;
        mGameOverScreen.LabelColor = Color.Black;
    }
    ```

4.  现在创建一个更新函数，根据游戏的当前状态更新游戏。

    ```cs
    public void UpdateGame(GameTime gameTime)
    {
        switch(mCurrentGameState)
        {
            case GameStates.StartScreen:
                 UpdateStartScreen();
                 break;
            case GameStates.Playing:
                 UpdateGamePlay(gameTime);
                 break;
            case GameStates.Dead:
                 UpdateGameOverScreen();
                 break;
        }
    }
    ```

    1.  对于 UpdateStartScreen()函数，轮询 A 按钮是否被按下。如果是，改变当前游戏状态并初始化游戏。

        ```cs
        public void UpdateStartScreen()
        {
            if (InputWrapper.Buttons.A == ButtonState.Pressed)
            {
                mSplashScreen = null;
                mCurrentGameState = GameStates.Playing;
                InitializeGamePlay();
            }
        }
        ```

    2.  UpdateGameOverScreen()函数的行为本质上反映了 UpdateStartScreen()函数的行为。事实上，可以很容易地从它们中提取出另一个功能来减少冗余。

        ```cs
        public void UpdateGameOverScreen()
        {
            if (InputWrapper.Buttons.A == ButtonState.Pressed)
            {
                mGameOverScreen = null;
                mCurrentGameState = GameStates.Playing;
                InitializeGamePlay();
            }
        }
        ```

    3.  对于 UpdateGamePlay()函数:

        ```cs
        public void UpdateGamePlay(GameTime gameTime)
        {
            mDistantTraveled = (int)mHero.PositionX / 20;
            if (mHero.HasLost())
            {
                mCurrentGameState = GameStates.Dead;
                AudioSupport.PlayACue("Break");
                InitializeGameOverScreen();
                return;
            }

            bool shootBubbleShot = (InputWrapper.Buttons.A == ButtonState.Pressed);
            mHero.Update(gameTime, InputWrapper.ThumbSticks.Left, shootBubbleShot);
            mEnvironment.Update(mHero);

            #region hero moving the camera window
            float kBuffer = mHero.Width * 5f;
            float kHalfCameraSize = Camera.Width * 0.5f;
            Vector2 delta = Vector2.Zero;
            Vector2 cameraLL = Camera.CameraWindowLowerLeftPosition;
            Vector2 cameraUR = Camera.CameraWindowUpperRightPosition;
            const float kChaseRate = 0.05f;

            if (mHero.PositionX > (cameraUR.X - kHalfCameraSize))
            {
                delta.X = (mHero.PositionX + kHalfCameraSize - cameraUR.X) * kChaseRate;
            }

            Camera.MoveCameraBy(delta);
            #endregion
        }
        ```

        *   记录行进的距离
        *   检查英雄是否输了
        *   检查玩家是否打出了泡泡
        *   更新英雄和环境
        *   允许主人公将摄像机向右平移
5.  最后，实现 draw 函数，根据游戏的当前状态绘制游戏。在游戏状态下，记得打印出英雄走过的距离和大小。

    ```cs
    public void DrawGame()
    {
        switch (mCurrentGameState)
        {
            case GameStates.StartScreen:
                 if(mSplashScreen != null)
                     mSplashScreen.Draw();
                 break;
            case GameStates.Playing:
                 mEnvironment.Draw();
                 mHero.Draw();
                 FontSupport.PrintStatus("Distance: " + mDistantTraveled
                                            + "  Size: " + mHero.HeroSize, null);
                 break;
            case GameStates.Dead:
                 if (mGameOverScreen != null)
                     mGameOverScreen.Draw();
                 break;
        }
    }
    ```

恭喜你！你已经完成了整个鱼食游戏！正如本章前面所描述的，这个游戏很重要，但也不太复杂。图 9-2 显示了一个你在玩鱼食游戏时应该看到的例子。

![9781430266044_Fig09-02.jpg](img/-02.jpg)

[图 9-2](#_Fig2) 。完成的鱼食游戏的示例屏幕

游戏批评和扩展

现在整个游戏已经实现了，构建并运行代码以便进行测试。试着看看你能走多远，然后看看你是否能跑完这段距离。游戏给人什么样的印象？是不是太简单了？难度如何？好玩的因素怎么样？你对这些问题的回答都与你的游戏创作有关。总的来说，我们希望你看到这个游戏并不完美。事实上，这个游戏有很多地方可以改进。这包括游戏性、界面、控制、效果、主题、艺术、声音，甚至代码本身。

如果你有一个可以在任何方面改进游戏的想法，那就去实现它吧！如果你正在努力思考一个需要改进的地方，试试下面的建议。

*   内容！游戏总是可以使用更多的内容，比如敌人类型，食物类型，英雄角色类型，甚至环境类型。
*   游戏性和功能性！这可以包括像相机变焦，英雄或敌人的能力，或食物奖励。
*   特效！通常最好的游戏有很好的效果，比如令人满意的声音或粒子行为。
*   控制！控制感觉直观吗？有没有更自然的玩法？笨拙的控制往往会降低游戏的趣味性。
*   代码质量和可理解性！代码总是可以改进的！是否可以对某些东西进行重新分解或润色，以提供更简单的方法？

请记住，一些变化可能会影响到游戏的其他部分。例如，如果您要实现相机缩放功能，在缩小时，您可能会发现环境不再像您预期的那样运行。然而，我们鼓励你扩展和实现你的想法，如果不是在这个游戏中，也许是在你自己的游戏中。这个游戏里可能有适用于你一直在思考的一个游戏的东西。太好了！拆那部分和/或采取你所学到的，并开始创造有趣和具有挑战性的 2D 游戏！

设备部署和发布游戏

我们在本书中使用的 MonoGame 框架是专门为跨平台库设计的。本着“一次编写，随处播放”的理念，该框架目前支持大多数流行的操作系统，包括运行在 Linux、Windows、iOS 和 Android 上的设备。这意味着一旦你开发了一个游戏，你将能够在所有这些设备上构建和运行相同的游戏。

最终，游戏是为玩家和所有欣赏我们努力的人而设计的。发布一款游戏曾经是绝对专业人士的专利。幸运的是，最近所有主要供应商都开放了市场，这意味着任何人都可以参与并自行发布他们自己的游戏！

加上 MonoGame 的跨平台支持，这意味着你最终将能够在 MonoGame 支持的所有平台上发布你的游戏。在写这本书的时候，虽然完全可以操作，但是 MonoGame 跨平台部署机制仍然在经历重大的变化。我们鼓励感兴趣的读者在[http://www.monogame.net](http://www.monogame.net)访问 MonoGame 网站获取最新信息。

此外，感兴趣的读者还应该参考各个供应商的自助出版指南:

*   iOS:[http://developer.apple.com/appstore/guidelines.html](http://developer.apple.com/appstore/guidelines.html)
*   Android:[http://developer . Android . com/tools/publishing/publishing _ overview . html](http://developer.android.com/tools/publishing/publishing_overview.html)
*   windows Phone:[http://developer.windowsphone.com/en-us/publish](http://developer.windowsphone.com/en-us/publish)

每个供应商通常会要求您签署不同的许可协议，他们希望您的游戏遵守的用户界面设计指南(例如字体、大小)，他们希望您在游戏上执行的测试级别，您的游戏需要的机器功能和设备传感器的文档，以及对于移动设备上的游戏，您的游戏将访问的玩家隐私信息(例如位置信息等)的种类以及如何使用这些信息的文档。请参考上述网站，了解每个供应商的详细要求。

最后，我们应该再一次提到，这本书只关注构建游戏的技术方面。正如在第一章中所讨论的，技术诀窍是构建有趣游戏的重要前提，但不是唯一的因素。我们认为，总的来说，在尝试构建自发布游戏之前，了解游戏设计主题是一个好主意(请参考[第 1 章](01.html)中的一些推荐参考资料)，因为这些想法和概念是有价值的工具，可以帮助你充分利用你的想法。事实上，你拿起这本书的原因可能是因为你有许多游戏想法在你的脑海中浮动。游戏设计过程旨在帮助你记录这些想法，并从想法跳到真实游戏的内容和机制。

最后，记得享受过程！制作游戏不是一件小事，但是如果你喜欢看到你的想法变成现实的过程，那么花时间和精力是值得的。我们希望利用你从本书中学到的知识，你现在可以开始创建自己的 2D 游戏之旅。祝你好运，并享受构建和玩你的第一个游戏！