# 三、2D 图形、坐标和游戏状态

完成本章后，您将能够:

*   控制游戏窗口的大小
*   创建并使用自定义 C# 类来支持纹理的绘制和简单行为
*   区分像素坐标系和用户定义的坐标系
*   设计和创建您自己的坐标系，为您的游戏提供最佳支持
*   创建简单的游戏对象
*   创建一个简单的游戏状态

介绍

如今大多数游戏都以某种形式使用图形来代表或传达他们的状态，2D 游戏也不例外。无论是使用纹理来表现英雄角色还是使用粒子来展示爆炸，2D 游戏也依靠图形和效果来使他们的游戏世界变得生动。这一章将会介绍一些基本的构建模块，这些模块是为你的游戏获得想要的图形和效果所需要的。

就像本书的一般内容一样，您可以使用 Chapter03\SourceCode 文件夹中包含的示例项目来遵循这些章节。更好的方法是创建您自己的项目，并在逐步执行过程中插入所需的代码。自己构建项目将会给你带来实际的开发经验和对所涵盖的概念的更好的理解。同样重要的是要注意，大多数项目都是建立在彼此之上的，因此经常重用前面章节中的代码。

游戏窗口

首先要解决的是游戏窗口。游戏窗口通常以两种模式之一显示:窗口模式或全屏模式。在*窗口*模式中，你可以指定你的游戏窗口所需的分辨率，它将包含在操作系统(Windows)的默认窗口中。*全屏*模式将使你的游戏适合整个屏幕——即使窗口大小不匹配，这可能导致游戏看起来被拉长或像素化，除非你仔细计划和处理全屏情况。

游戏窗口大小项目

这个项目演示了如何在全屏模式和窗口模式之间切换。[图 3-1](#Fig1) 显示了项目在窗口模式下运行的示例。

![9781430266044_Fig03-01.jpg](img/-01.jpg)

[图 3-1](#_Fig1) 。在窗口模式下运行游戏窗口大小项目

项目的 控件如下:

*   **返回按钮(F1 键)**退出程序
*   **一个按钮(K 键)**切换到全屏模式
*   **B 按钮(L 键)**切换到窗口模式

项目的目标如下:

*   了解如何使用代码控制应用游戏窗口的大小
*   为了能够在全屏和窗口模式之间切换
*   确定对图形对象的需求

修改游戏窗口

1.  创建一个名为 *GameWindowSize* 的新项目，或者按照 Chapter03\SourceCode\1 中的示例项目进行操作。GameWindowSize 文件夹。如果你需要一个关于如何用 Visual Studio 和 MonoGame 创建一个新项目的提示，请参考[第 2 章](02.html)“了解 MonoGame 框架”中的例子
2.  在 Game1 类中，声明变量 kWindowWidth 和 kWindowHeight 来保存您想要的窗口大小，如下面的代码所示:

    ```cs
    public class Game1 : Game
    {
        GraphicsDeviceManager mGraphics;
        SpriteBatch mSpriteBatch;

        // Prefer window size
        const int kWindowWidth = 1000;
        const int kWindowHeight = 700;
         ...
    }
    ```

3.  接下来，如下面的代码所示，通过创建图形设备管理器并在构造函数中设置其 PreferredBackBufferWidth 和 PreferredBackBufferHeight 来设置窗口大小。这是所有需要指定您的初始窗口大小！

    ```cs
    public Game1()
    {
        mGraphics = new GraphicsDeviceManager(this);
        Content.RootDirectory = "Content";

        // Set preferred window size
        mGraphics.PreferredBackBufferWidth = kWindowWidth;
        mGraphics.PreferredBackBufferHeight = kWindowHeight;

        ...
    }
    ```

4.  现在，通过将如下所示的代码插入到 Update()函数中，添加对全屏模式切换的支持。这段代码添加了一个允许游戏退出的 if 语句，以及另外两个支持全屏模式切换的 if 语句。后两个 if 语句中的第一个负责切换到全屏模式。代码在每个更新周期中检查 A 按钮的状态(按钮是否被按下)。如果按钮被按下，代码将检查游戏是否已经处于全屏模式。如果没有，代码使用图形设备管理器将 IsFullScreen 设置为 true，然后调用 ApplyChanges()立即应用更改，因为您是在运行时修改窗口状态。第二个 if 语句类似，但是检查 B 按钮是否被按下。如果是，它会检查游戏当前是否处于全屏模式，如果是，则退出全屏模式，然后立即应用更改。

    ```cs
    protected override void Update(GameTime gameTime)
    {
        // Allows the game to exit
        if (InputWrapper.Buttons.Back == ButtonState.Pressed)
            this.Exit();

        // "A" to toggle to full-screen mode
        if (InputWrapper.Buttons.A == ButtonState.Pressed)
        {
            if (!mGraphics.IsFullScreen)
            {
                mGraphics.IsFullScreen = true;
                mGraphics.ApplyChanges();
            }
        }

        // "B" toggles back to windowed mode
        if (InputWrapper.Buttons.B == ButtonState.Pressed)
        {
            if (mGraphics.IsFullScreen)
            {
                mGraphics.IsFullScreen = false;
                mGraphics.ApplyChanges();
            }
        }
    }
    ```

虽然修改窗口大小和状态是有用的，但如果游戏中没有任何图形对象来显示这些变化，就不是很有趣了。接下来，您将看到如何向游戏中添加一些图形对象。

纹理图元

大多数游戏使用图像或纹理来表现角色或物体。在适当的支持下，图像或纹理提供了一种直接的方式将资产或艺术带入游戏。一般来说，你可以在游戏中使用各种各样的纹理，包括背景表现和 UI 布局。本节将指导您实现一个旨在支持纹理的项目。

纹理原始项目

这个项目演示了如何导入纹理和操纵它们的位置和大小。它还演示了如何选择要控制的纹理。[图 3-2](#Fig2) 显示项目运行 。

![9781430266044_Fig03-02.jpg](img/-02.jpg)

[图 3-2](#_Fig2) 。运行纹理基元项目

项目的 控件如下:

*   **返回按钮(F1 键)**退出程序
*   **一个按钮(K 键)**切换到全屏模式
*   **B 按钮(L 键)**切换到窗口模式
*   **左键(WSAD 键)**移动当前选中的纹理
*   **右键(箭头键)**改变当前选中纹理的大小
*   **X 按钮(J 键)**切换当前选择的纹理

项目的目标如下:

*   理解图形原语的抽象(TexturedPrimitive)
*   了解如何创建和使用 TexturedPrimitive
*   观察使用默认像素空间的限制

创建项目的步骤如下:

1.  为项目创建一个新的 C# 类。
2.  定义该类的行为。
3.  使用新的类。

将 TexturedPrimitive 抽象成一个类使您能够在将来轻松地重用、修改和构建该对象，这就是面向对象编程的目的。

创建 *TexturedPrimitive* 类

1.  要继续，您应该使用以前的项目或遵循 Chapter03\SourceCode\2 中的示例项目。TexturedPrimitive 文件夹。
2.  Modify the Game1 class to support static variables for SpriteBatch, ContentManager, and GraphicsDeviceManager, as shown in the following code. Making these variables static allows you to access them globally and allows convenient drawing and loading of textures and fonts.

    ```cs
    public class Game1 : Game
    {
        static public SpriteBatch sSpriteBatch;        // Drawing support
        static public ContentManager sContent;         // Loading textures
        static public GraphicsDeviceManager sGraphics; // Current display size

        ...
    }
    ```

    ![image](img/.jpg) **注意**以字母 s 开头的变量(例如 sStaticVariable)表示它们是静态的。

3.  下一步是创建一个新的 C# 类来显示纹理。您可能知道，创建一个为纹理支持而设计的类可以让您重用相同的代码，而不必重新编写。例如，当您的游戏需要多个纹理时，您可以简单地实例化对象的多个实例。
    1.  Before creating the class itself, however, you should first create a folder to keep your project organized. To create a folder, right-click the project name in Solution Explorer, and then select Add ![image](img/.jpg) New Folder, as shown in the image that follows. Name the folder GraphicsSupport.

        ![9781430266044_unFig03-01.jpg](img/-01.jpg)

    2.  Now that you have created the GraphicsSupport folder for organizing the class, you can create the new class. To create a new C# class, right-click the GraphicsSupport folder and select Add ![image](img/.jpg) New Item, as shown following. A new template window will appear.

        ![9781430266044_unFig03-02.jpg](img/-02.jpg)

    3.  Select the Class template as shown following and name it TexturedPrimitive. Click the Add button, and the new class will appear within Visual Studio under your GraphicsSupport folder.

        ![9781430266044_unFig03-03.jpg](img/-03.jpg)

    4.  The image that follows shows the new class file inside the GraphicsSupport folder. This file is accessible from your current project as long as it shares the same namespace with the rest of the source code files.

        ![9781430266044_unFig03-04.jpg](img/-04.jpg)

您已经在项目中创建了一个新的 C# 类文件。接下来，您将为这个新类定义功能和行为。

向 TexturedPrimitive 添加自定义功能和行为使其能够处理自己的绘制和更新周期，从而保持对象的自包含性并简化管理。

添加 *TexturedPrimitive* 功能和行为

1.  You can now add the code needed to support textures in the TexturedPrimitive.cs source file. Start by declaring three instance variables: a Texture2D variable to hold the image and two Vector2 variables for the position and size of the image or texture.

    ```cs
    protected Texture2D mImage;     // The UWB-JPG.jpg image to be loaded
    protected Vector2 mPosition;    // Center position of image
    protected Vector2 mSize;        // Size of the image to be drawn
    ```

    ![image](img/.jpg) **注意**以字母 m 开头的变量是实例变量。这些变量可以在类的范围内访问。

2.  接下来，在构造函数中用相应的参数初始化这些变量。您可以在下面的代码中看到这样的例子。请注意，为了加载纹理，您是如何访问 Game1 的 static sContent 变量的。

    ```cs
    public TexturedPrimitive(String imageName, Vector2 position, Vector2 size)
    {
        mImage = Game1.sContent.Load<Texture2D>(imageName);
        mPosition = position;
        mSize = size;
    }
    ```

3.  下一步是创建 Update()函数。当这个函数被调用时，它通过应用参数传递的数量来改变纹理的位置和大小。您可以在下面的代码中看到这一点，其中 deltaTranslate 和 deltaScale 被添加到当前位置和大小。如果 deltaTranslate 和 deltaScale 没有改变，那么纹理将保持相同的大小和静止。

    ```cs
    public void Update(Vector2 deltaTranslate, Vector2 deltaScale)
    {
        mPosition += deltaTranslate;
        mSize += deltaScale;
    }
    ```

4.  您需要的最后一个函数是 Draw()函数。这个函数负责将纹理绘制到屏幕上。您可以通过为纹理的大小和位置创建一个矩形对象并使用 Game1.sSpriteBatch.Draw 调用来实现这一点，该调用接受一个纹理对象、一个基本(矩形)对象和一个颜色。

    ```cs
    public void Draw()
    {
        // Defines where and size of the texture to show
        Rectangle destRect = new Rectangle((int)mPosition.X, (int)mPosition.Y,
                                                (int)mSize.X, (int)mSize.Y);
        Game1.sSpriteBatch.Draw(mImage, destRect, Color.White);
    }
    ```

现在你已经完成了 TexturedPrimitive 类，它可以在 Game1 类中使用。

使用 *TexturedPrimitive* 类

1.  打开 Game1 类(通过在解决方案资源管理器中双击 Game1.cs 文件，并声明变量 kNumObjects、mGraphicsObjects 和 mCurrentIndex，如下所示。整数 kNumObjects 表示您将使用的对象数量，TexturedPrimitive 数组 mGraphicsObjects 保存纹理对象，整数 mCurrentIndex 保存当前选定纹理的索引。下面的代码展示了 Game1.cs 文件中的变化:

    ```cs
    public class Game1 : Game
    {
        static public SpriteBatch sSpriteBatch;        // Drawing support
        static public ContentManager sContent;         // Loading textures
        static public GraphicsDeviceManager sGraphics; // Current display size

        // Preferred window size
        const int kWindowWidth = 1000;
        const int kWindowHeight = 700;

        const int kNumObjects = 4;
        // Work with the TexturedPrimitive class
        TexturedPrimitive[] mGraphicsObjects; // An array of objects
        int mCurrentIndex = 0;

        ...
    }
    ```

2.  下一步是在 LoadContent() 中加载纹理。将以下代码行添加到 Game1 的 LoadContent()函数中，以创建纹理数组并设置其起始图像、位置和大小。还记得[第 2 章](02.html)中的内容吗，比如图像，应该在使用之前加载到内容项目(在本例中是 TexturedPrimitiveContent)中。右键单击内容项目并选择 Add ![image](img/.jpg) Existing Item。将 UWB-JPG.jpg 和 UWB-PNG.png 都添加到 TexturedPrimitiveContent。它们可以在本章的 Book_Img 文件夹中找到。

    ```cs
    protected override void LoadContent()
    {
        // Create a new SpriteBatch, which can be used to draw textures.
        Game1.sSpriteBatch = new SpriteBatch(GraphicsDevice);

        // Create the primitives.
        mGraphicsObjects = new TexturedPrimitive[kNumObjects];
        mGraphicsObjects[0] = new TexturedPrimitive("UWB-JPG",               // Image file name
                                                    new Vector2(10, 10),     // Position to draw
                                                    new Vector2(30, 30));    // Size to draw
        mGraphicsObjects[1] = new TexturedPrimitive("UWB-JPG",
                                                    new Vector2(200, 200), new Vector2(100, 100));
        mGraphicsObjects[2] =  new TexturedPrimitive("UWB-PNG",
                                                    new Vector2(50, 10), new Vector2(30, 30));
        mGraphicsObjects[3] = new TexturedPrimitive("UWB-PNG",
                                                    new Vector2(50, 200), new Vector2(100, 100));
    }
    ```

3.  现在您已经准备好了 LoadContent()函数，下一步是将纹理绘制到屏幕上。你可能已经猜到了，这是在 Game1 的 Draw()函数中完成的。添加如下所示的代码，该代码循环遍历每个 TexturedPrimitive 并调用其 Draw()函数:

    ```cs
    protected override void Draw(GameTime gameTime)
    {
        // Clear to background color
        GraphicsDevice.Clear(Color.CornflowerBlue);

        Game1.sSpriteBatch.Begin(); // Initialize drawing support

        // Loop over and draw each primitive
        foreach (TexturedPrimitive p in mGraphicsObjects)
        {
            p.Draw();
        }

        Game1.sSpriteBatch.End(); // Inform graphics system we are done drawing

        base.Draw(gameTime);
    }
    ```

4.  所需代码的最后一部分位于 Update()函数中。首先，为了支持在所选纹理之间切换，使用游戏手柄的 X 按钮来修改当前的索引变量(mCurrentIndex)。接下来，使用 TexturedPrimitive 的 Update()函数结合游戏手柄的左右拇指来更新当前选中纹理的大小和位置。您可以在下面的代码中看到这一点:

    ```cs
    protected override void Update(GameTime gameTime)
    {
        // Allows the game to exit
        ...
        // "A" to toggle to full screen
        ...
        // "B" toggles back to window
        ...

        // Button X to select the next object to work with
        if (InputWrapper.Buttons.X == ButtonState.Pressed)
            mCurrentIndex = (mCurrentIndex + 1) % kNumObjects;

        // Update currently working object with thumb sticks.
        mGraphicsObjects[mCurrentIndex].Update(
            InputWrapper.ThumbSticks.Left,
            InputWrapper.ThumbSticks.Right);

        base.Update(gameTime);
    }
    ```

观察

随着 TexturedPrimitive 项目所有必要组件的完成，是时候构建和运行项目了，同时进行一些观察。运行项目并试验其功能。分别移动每个拇指棒时，以及在全屏模式之间切换时，观察图像的行为。特别是，您应该注意以下几点:

*   注意 y 轴的反转。当向上移动游戏手柄的左拇指操纵杆时，选中的图像向下移动。这种行为对于大多数用户来说并不直观。
*   当移动右拇指操纵杆时，图像不相对于它们的中心缩放；相反，缩放是相对于左上角的。您可以通过识别左上角在缩放操作期间保持其位置来识别这种行为。
*   注意窗口模式和全屏模式下图像的相对大小。您会注意到，在窗口模式和全屏模式之间，图像大小不会改变。这对于开发人员来说很麻烦，因为你不知道一个对象相对于游戏窗口大小的相对大小。我们将在下一节中更多地触及这个概念。

在接下来的项目中，您将学习必要的概念来解决和纠正这些行为，以支持用户更直观的体验，以及更直观的游戏世界供您开发。

坐标系和摄像机

正如您在上一节末尾所看到的，TexturedPrimitive 项目成功地向游戏世界添加了多个图像，并支持与图像的直接交互。然而，它也揭示了使用默认像素空间时出现的几个问题。通过创建您自己的用户定义的坐标系，可以解决使用默认像素空间会产生的这些和许多其他问题。

为了讨论的目的，*像素空间*描述了游戏窗口以像素为单位占据的区域。游戏窗口中的每个像素代表离散坐标系中的一个点，其中原点位于窗口的左上角，x 轴指向右侧，y 轴指向下方。*用户自定义坐标系*是一个由您创建的笛卡尔坐标系，以满足您对项目的需求。自定义坐标系与像素空间有两个独特的区别:一是自定义坐标系的单位与像素无关；第二，用户定义系统的 y 轴指向上。用户定义的坐标系充当默认像素空间和您(开发者)之间的层，以便在不同的窗口大小和视图之间标准化游戏世界。

![image](img/.jpg) **注意**术语*用户自定义坐标系*和*用户自定义坐标空间*从这里开始可以互换使用。

从技术和设计的角度来看，创建用户定义的坐标系使开发人员的工作变得更加容易。例如，假设您正在创建一个使用真人大小角色的游戏。在一个用户定义的坐标系下，你可以用一米作为你的基本单位，并把你的角色设计成两个单位高。然而，在像素空间系统下，一个字符会变成任意数量的像素高。当考虑像照相机变焦这样的效果时，这个问题变得更糟，因为角色的像素高度已经被指定了。一个用户定义的坐标系允许增加新功能的灵活性，同时保持标准化游戏外观所需的核心功能。

用户定义的坐标系项目

这个项目为用户定义的坐标系建立了基础设施支持，并允许您离开像素空间。这种基础结构支持包括定义一个新的 Camera 类和在 TexturedPrimitive 类中构建新的功能。项目的功能与纹理基元项目相同。然而，作为一名开发者，你将能够独立于像素分辨率来指定对象的位置和大小。[图 3-3](#Fig3) 显示项目运行。

![9781430266044_Fig03-03.jpg](img/-03.jpg)

[图 3-3](#_Fig3) 。运行用户定义的坐标系项目

项目的 控件如下:

*   **返回按钮(F1 键)**退出程序
*   **一个按钮(K 键)**切换到全屏模式
*   **B 按钮(L 键)**切换到窗口模式
*   **左键(WSAD 键)**移动当前选中的纹理
*   **右键(箭头键)**改变当前选中纹理的大小
*   **X 按钮(J 键)**切换当前选择的纹理

项目的目标如下:

*   了解坐标系的细节和要求
*   要了解如何创建坐标系
*   在用户定义的坐标系中定义和使用相机窗口

创建项目的步骤如下:

1.  创建用户定义的坐标系。这是通过创建一个新的 Camera 类并修改 TexturedPrimitive 类来实现的。
2.  使用 Camera 类。这允许在用户定义的坐标系中导航。

了解像素空间和用户定义的空间

在我们进入创建用户自定义坐标系的细节之前，我们将首先讨论默认像素空间，如图 3-4 中的[所示。经过检查，您会注意到原点位于游戏窗口的左上角，而不是左下角。此外，y 轴的值向下增加，而不是像通常预期的那样向上增加。另外需要注意的是，我们用 *W* <sub>*p*</sub> 来表示游戏窗口的宽度，用 *H* <sub>*p*</sub> 来表示游戏窗口的高度。](#Fig4)

![9781430266044_Fig03-04.jpg](img/-04.jpg)

[图 3-4](#_Fig4) 。默认像素空间

现在您已经知道了默认像素空间的布局，您可以开始设计用户定义的坐标系来反映更直观的布局。首先，最好先指定所需的用户定义空间。通常这是通过创建一个观察游戏世界特定部分的摄像机区域来实现的。在图 3-5 中，你可以看到一个用户自定义空间的例子，浅蓝色的矩形代表应该显示在游戏窗口中的摄像机区域(或摄像机窗口)。您可以在相机窗口外看到，所需的用户定义空间的原点位于左下角，y 轴向上逐渐增大。相机窗口本身由它的左下角( *X* <sub>*c*</sub> 和 *Y* <sub>*c*</sub> )、它的宽度( *W* <sub>*c*</sub> )和它的高度( *H* <sub>*c*</sub> )。

![9781430266044_Fig03-05.jpg](img/-05.jpg)

[图 3-5](#_Fig5) 。用户定义的坐标系

定义了像素空间和所需的用户空间后，现在可以开始处理从用户空间到像素空间的转换任务了。要过渡到像素空间，你首先需要将相机窗口移动或平移到原点，如图 3-6 中的[所示。这是通过从相机窗口的位置减去 *X* <sub>*c*</sub> 和 *Y* <sub>*c*</sub> 来完成的。](#Fig6)

![9781430266044_Fig03-06.jpg](img/-06.jpg)

[图 3-6](#_Fig6) 。具有平移原点的用户定义坐标系

接下来，用户定义的空间需要调整大小(或缩放),以匹配像素空间的宽度和高度。这可以通过将宽度 *W* <sub>*c*</sub> 乘以*W*<sub>*p*</sub>/*W*<sub>*c*</sub>和高度 *H* <sub>*c*</sub> 乘以*H*<sub>*p*</sub>/*H 你可以在图 3-7 中看到这一点。*

![9781430266044_Fig03-07.jpg](img/-07.jpg)

[图 3-7](#_Fig7) 。应用缩放的用户定义的坐标系

转换到像素空间的最后一步是翻转 y 轴，使原点位于左上角。这可以通过获取像素空间的高度并从中减去 y 值来实现。这使你在窗口的左上角有一个原点，如图[图 3-8](#Fig8) 所示。

![9781430266044_Fig03-08.jpg](img/-08.jpg)

[图 3-8](#_Fig8) 。具有反向 y 轴的用户定义坐标系

现在你已经知道了转换到像素空间的过程，看看下面的公式，其中相机位置在自定义空间中用( *C* <sub>*x*</sub> *，C* <sub>*y*</sub> )表示，对应的像素空间位置表示为(*P*<sub>*x*</sub>*，P*<sub>y</sub>

 *![image](img/-1.jpg)

![image](img/-2.jpg)

如果您遵循 y 值的等式，您可以看到转换过程中的每一步都按顺序进行。首先你通过从 *C* <sub>*y*</sub> 中减去 *Y* <sub>*c*</sub> 平移到原点。接下来，通过乘以(*H*<sub>*p*</sub>*/H*<sub>*c*</sub>)来缩放以匹配像素空间的大小。最后通过*H*T26】T27】pT29】用减法翻转 y 轴。对于 x 轴值，公式是类似的，只是不需要翻转水平轴。

现在您已经了解了从用户定义的空间转换到像素空间所涉及的过程和数学，接下来您将了解如何创建一个 Camera 类来支持这种转换。要继续，继续使用本章前面的纹理基元项目，因为添加了相机支持，或者按照 3。Chapter03\SourceCode 文件夹中提供的 UserDefinedCoordinateSystem 示例。

创建一个用户定义的坐标系

1.  首先在项目的 GraphicsSupport 文件夹中创建一个新类。给班级命名为 Camera。
2.  将该类设为静态，因为您希望避免 Camera 类的多个实例化。

    ```cs
    namespace Book_Example
    {
        static public class Camera
        {
            ...
        }
    }
    ```

3.  接下来，添加以下变量来表示原点、宽度以及相机和像素窗口之间的比率:

    ```cs
    static private Vector2 sOrigin = Vector2.Zero;   // Origin of the world
    static private float sWidth = 100f;              // Width of the world
    static private float sRatio = -1f;                // Ratio between camera window and pixel
    ```

4.  现在创建一个私有函数，返回两个窗口之间的比率，如下面的代码所示。如果按照代码来看，可以看到 game 1 . sgraphics . preferredbackbufferwidth/swid th 从前面推导的公式中表示(*W*<sub>*p*</sub>*/W*<sub>*c*</sub>)。

    ```cs
    static private float cameraWindowToPixelRatio()
    {
        if (sRatio < 0f)
            sRatio = (float) Game1.sGraphics.PreferredBackBufferWidth / sWidth;
        return sRatio;
    }
    ```

5.  Now you need a function to set the camera window’s position and size. This is easily done by creating a set function like the one shown following:

    ```cs
    static public void SetCameraWindow(Vector2 origin, float width)
    {
        sOrigin = origin;
        sWidth = width;
    }
    ```

    ![image](img/.jpg) **注意**注意只能指定相机窗口的宽度。这是因为一旦定义了宽度，相机窗口的高度就取决于游戏窗口的实际高度。只允许宽度被修改保证了摄像机能够以合适的纵横比绘制到整个游戏窗口。

6.  接下来，您需要实现一个位置从用户定义的空间到像素空间的转换，以便进行绘制。这可以通过实现本节前面所示的 P <sub>x</sub> 和 P <sub>y</sub> 方程来实现。再次注意，只有 y 轴被翻转。

    ```cs
    static public void ComputePixelPosition(Vector2 cameraPosition, out int x, out int y)
    {
        float ratio = cameraWindowToPixelRatio();

        // Convert the position to pixel space
        x = (int)(((cameraPosition.X - sOrigin.X) * ratio) + 0.5f);
        y = (int)(((cameraPosition.Y - sOrigin.Y) * ratio) + 0.5f);

        y = Game1.sGraphics.PreferredBackBufferHeight - y;
    }
    ```

7.  Camera 类的最后一个函数需要将一个矩形区域从用户定义的坐标空间转换到像素空间。这是通过将相机窗口的位置和大小转换到相应的像素空间来实现的。您可以在下面的代码中看到这一点:

    ```cs
    static public Rectangle ComputePixelRectangle(Vector2 position, Vector2 size)
    {
        float ratio = cameraWindowToPixelRatio();

        // Convert size from camera window space to pixel space.
        int width = (int)((size.X * ratio) + 0.5f);
        int height = (int)((size.Y * ratio) + 0.5f);

        // Convert the position to pixel space
        int x, y;
        ComputePixelPosition(position, out x, out y);

        // Reference position is the center
        y -= height / 2;
        x -= width / 2;

        return new Rectangle(x, y, width, height);
    }
    ```

使用*相机*类

1.  通过在 Game1 的 LoadContent()函数中使用 SetCameraWindow()函数定义一个摄像头窗口来使用摄像头类。将其原点设置为(10，20)，宽度设置为 100。请注意，宽度与像素空间中游戏窗口覆盖的像素数量无关。

    ```cs
    protected override void LoadContent()
    {
        // Create a new SpriteBatch, which can be used to draw textures.
        Game1.sSpriteBatch = new SpriteBatch(GraphicsDevice);

        // Define camera window bounds
        Camera.SetCameraWindow(new Vector2(10f, 20f), 100f);

        // Create the primitives
        mGraphicsObjects = new TexturedPrimitive[kNumObjects];
        mGraphicsObjects[0] = new TexturedPrimitive("UWB-JPG",
                                                new Vector2(15f, 25f), new Vector2(10f, 10f));
        mGraphicsObjects[1] = new TexturedPrimitive("UWB-JPG",
                                                new Vector2(35f, 60f), new Vector2(50f, 50f));
        mGraphicsObjects[2] = new TexturedPrimitive("UWB-PNG",
                                                new Vector2(105f, 25f), new Vector2(10f, 10f));
        mGraphicsObjects[3] = new TexturedPrimitive("UWB-PNG",
                                                new Vector2(90f, 60f), new Vector2(35f, 35f));
        // NOTE: Since the creation of TexturedPrimitive involves loading of textures,
        // the creation should occur in or after LoadContent()
    }
    ```

2.  最后，在每次绘图之前，必须将所有位置和大小从用户定义的坐标转换到像素空间。如下面 TexturedPrimitive.cs 文件中 Draw()函数的代码所示，Camera。调用 ComputePixelRectangle()来执行适当的转换:

    ```cs
    public void Draw()
    {
       // Defines where and size of the texture to show
       Rectangle destRect = Camera.ComputePixelRectangle(Position, Size);
       Game1.sSpriteBatch.Draw(mImage, destRect, Color.White);
    }
    ```

构建并运行项目。结果应该与之前在[图 3-3](#Fig3) 中显示的像素空间中的结果相同。现在我们来看看用户定义的空间。[图 3-9](#Fig9) 显示了用户自定义空间中的游戏世界。

![9781430266044_Fig03-09.jpg](img/-09.jpg)

[图 3-9](#_Fig9) 。像素空间内用户定义的坐标系

现在尝试切换按钮 A 和 B，在窗口模式和全屏模式之间切换。请注意对象的相对大小如何保持不变——在全屏模式下，占据游戏窗口一半的对象将继续占据另一半。作为一名游戏开发人员，您现在可以专注于设计游戏对象的相对大小和位置，而不用担心游戏窗口的最终像素分辨率。

认识到坐标空间之间相机的宽度和位置的差异是很重要的。相机在用户定义的坐标空间中仅覆盖 100 个宽度单位，而在像素空间中覆盖 1000 个像素。同样，摄像机的原点位于左下角，在(10，20)，而游戏窗口的原点位于左上角，在(0，0)。这表明您已经成功地将用户定义的坐标系从游戏窗口的像素空间中分离出来。

字体输出

许多游戏用于各种任务的一个有价值的工具是文本输出。这是因为文本提供了一种向用户和你——开发者——传达信息的有效方式。例如，它可以用来交流游戏的故事，玩家的分数，或开发过程中的调试信息。然而，与控制台编程不同的是，MonoGame 提供的游戏窗口不包括直接的文本输出支持。幸运的是，这可以通过使用 SpriteFont 类创建一个自定义类来生成游戏窗口的文本输出来轻松解决。

SpriteFont 类获取你想要的字体，并在构建时将字符转换成纹理。要使用 SpriteFont 类，必须创建一个字体文件，如 Arial.spritefont，然后必须将该文件转换为 xnb 格式，最后添加到项目中。与图像类似，字体应该在使用前添加到内容文件夹中。这是因为，像图像一样，字体文件是一种外部资源。

![image](img/.jpg) **注意** SpriteFonts 是 XML 文件，可以从你的 PC 上现有的字体生成。为了创建或定制您自己的 SpriteFont，请参考[http://msdn.microsoft.com/library/bb447673.aspx](http://msdn.microsoft.com/library/bb447673.aspx)。有关 SpriteFont 类及其属性的更多信息，请参考[http://msdn.microsoft.com/library/bb447759.aspx](http://msdn.microsoft.com/library/bb447759.aspx)。同样重要的是要注意，虽然你可以从你的电脑上现有的字体创建 SpriteFonts，你可能需要在你的游戏中使用这些字体的许可。

在创建一个支持字体的类之前，你应该首先在 Chapter 03 \ source code \ ImagesAndFontUsed 文件夹中找到 Arial.spritefont 字体描述资源文件，并将该文件转换为 Arial.xnb。这种转换可以通过从 XNB Builder 工具调用 XNAFormatter 程序来完成，该工具是你在第 1 章中执行的“下载和安装”操作的一部分，你已经下载并解压缩了。转换完成后，您可以将 Arial.xnb 文件包含到 MonoGame 项目中，方式与我们处理图像文件的方式类似:右键单击内容文件夹并导航到 Add ![image](img/.jpg) Existing Item，或者将文件拖放到内容文件夹中。

![image](img/.jpg) **注意**与图像一样，如果您选择将 Arial.xnb 文件拖放到内容文件夹中，您必须记得打开属性窗口并将构建动作字段更改为内容，如果较新，则复制到输出目录进行复制。

字体输出项目

这个项目演示了如何使用 FontSprite 资源在游戏屏幕上绘制文本。支持两种类型的打印功能。一个打印到屏幕的左上角，另一个打印到用户定义的坐标空间中的任何指定位置。当需要在对象上打印文本时，打印到某个位置非常有用；注意，图 3-10 中当前选中的纹理被识别。

![9781430266044_Fig03-10.jpg](img/-10.jpg)

[图 3-10](#_Fig10) 。运行字体输出项目

项目控制如下:

*   **返回按钮(F1 键)**退出程序
*   **一个按钮(K 键)**切换到全屏模式
*   **B 按钮(L 键)**切换到窗口模式
*   **左键(WSAD 键)**移动当前选中的纹理
*   **右键(箭头键)**改变当前选中纹理的大小
*   **X 按钮(J 键)**切换当前选择的纹理

项目的目标如下:

*   为了理解文本如何输出到屏幕上
*   要了解如何使用 FontSprite 资源
*   创建和使用 FontSupport 类

创建项目的步骤如下:

1.  为项目创建一个新的 FontSupport 类。
2.  使用并观察 FontSupport 类。

创建 *FontSupport* 类

1.  在 GraphicsSupport 文件夹中创建一个名为 FontSupport 的类，并将该类设为静态。
2.  在 FontSupport.cs 文件中声明三个静态变量 sprite 字体、颜色和位置——如以下代码所示:

    ```cs
    static private SpriteFont sTheFont = null;
    static private Color sDefaultDrawColor = Color.Black;
    static private Vector2 sStatusLocation = new Vector2(5, 5);
    ```

3.  Now create a function called LoadFont(), which initializes the SpirteFont variable by loading it with the font resource that was added to the content project (in this case, Arial.spritefont).

    ```cs
    static private void LoadFont()
    {
        // For demo purposes, loads Arial.spritefont
        if (null == sTheFont)
            sTheFont = Game1.sContent.Load<SpriteFont>("Arial");
    }
    ```

    ![image](img/.jpg) **注意**注意 Load()函数没有指定扩展名(。spritefont)，只有字体名称(Arial)。

4.  接下来，添加一个名为 ColorToUse()的简单函数，该函数允许将颜色从默认颜色(黑色)更改为任何指定的颜色。在下面的代码中，可以看到如果传入颜色为 null，则返回默认颜色；否则，返回指定的颜色。

    ```cs
    static private Color ColorToUse(Nullable<Color> c)
    {
        return (null == c) ? sDefaultDrawColor : (Color)c;
    }
    ```

5.  为了完成这个类，添加两个函数来支持游戏窗口的打印。
    1.  将第一个函数命名为 PrintStatus，并给它两个参数:一个用于将要打印的消息，另一个用于字体颜色。这个功能会把消息放在游戏窗口的左上角。您可以在下面的代码中看到这是如何实现的。再次注意，静态 SpriteBatch 变量用于绘制到屏幕上。

        ```cs
        static public void PrintStatus(String msg, Nullable<Color> drawColor)
        {
            LoadFont();
            Color useColor = ColorToUse(drawColor);

            // Compute top-left corner as the reference for output status
            Game1.sSpriteBatch.DrawString(sTheFont, msg, sStatusLocation, useColor);
        }
        ```

    2.  将第二个函数命名为 PrintStatusAt。该函数类似于 PrintStatus 函数；但是，它支持打印到指定的位置，方法是接受一个位置参数，并使用 Camera 类的 ComputePixelPosition()函数将该位置转换到用户定义的坐标空间。您可以在下面的代码中看到这一点:

        ```cs
        static public void PrintStatusAt(Vector2 pos, String msg, Nullable<Color> drawColor)
        {
            LoadFont();

            Color useColor = ColorToUse(drawColor);

            int pixelX, pixelY;
            Camera.ComputePixelPosition(pos, out pixelX, out pixelY);
            Game1.sSpriteBatch.DrawString(sTheFont, msg,
                                                new Vector2(pixelX, pixelY), useColor);
        }
        ```

FontSupport 类的完整列表显示在[列表 3-1](#list1) 中。

***[清单 3-1](#_list1)*** 。完整的*字体支持*类

```cs
static public class FontSupport
{
    static private SpriteFont sTheFont = null;
    static private Color sDefaultDrawColor = Color.Black;
    static private Vector2 sStatusLocation = new Vector2(5, 5);

    static private void LoadFont()
    {
        // for demo purposes, loads Arial.spritefont
        if (null == sTheFont)
            sTheFont = Game1.sContent.Load<SpriteFont>("Arial");
    }

    static private Color ColorToUse(Nullable<Color> c)
    {
        return (null == c) ? sDefaultDrawColor : (Color)c;
    }

    static public void PrintStatusAt(Vector2 pos, String msg, Nullable<Color> drawColor)
    {
        LoadFont();

        Color useColor = ColorToUse(drawColor);

        int pixelX, pixelY;
        Camera.ComputePixelPosition(pos, out pixelX, out pixelY);
        Game1.sSpriteBatch.DrawString(sTheFont, msg,
                                            new Vector2(pixelX, pixelY), useColor);
    }

    static public void PrintStatus(String msg, Nullable<Color> drawColor)
    {
        LoadFont();
        Color useColor = ColorToUse(drawColor);

        // compute top-left corner as the reference for output status
        Game1.sSpriteBatch.DrawString(sTheFont, msg, sStatusLocation, useColor);
    }

}
```

使用并遵守 *FontSupport* class

要使用 FontSupport 类，只需调用 Game1 的 Draw()函数中的 PrintStatus 和 PrintStatusAt 函数。PrintStatus 会将消息打印到游戏窗口的左上角，PrintStatusAt 会在你指定的位置打印消息。就这么简单。

```cs
protected override void Draw(GameTime gameTime)
{
    // Clear to background color
    ...
    // Loop over and draw each primitive
    ...
    // Print out text message to echo status
    FontSupport.PrintStatus("Selected object is:" + mCurrentIndex +
                      " Location=" + mGraphicsObjects[mCurrentIndex].Position, null);

    FontSupport.PrintStatusAt(mGraphicsObjects[mCurrentIndex].Position, "Selected", Color.Red);
    ...
}
```

如果您构建并运行该程序，您可以看到它的行为符合预期(如前面的[图 3-10](#Fig10) 所示)。了解 PrintStatus()函数从不将其消息的位置转换到用户定义的坐标空间是很重要的。这意味着它将保持在游戏窗口的左上角，即使相机被重新定位。

一个简单的游戏对象

现在，您已经了解了用户定义的坐标系如何通过 Camera 类工作，并且现在可以将文本输出到游戏窗口，是时候创建您的第一个游戏对象了。让我们从简单开始，创建一个具有一些基本功能的球，比如多重实例化、移动控制和边界碰撞检测。

简单的游戏对象项目

这个项目演示了如何创建与屏幕边缘碰撞的足球。[图 3-11](#Fig11) 显示项目运行。

![9781430266044_Fig03-11.jpg](img/-11.jpg)

[图 3-11](#_Fig11) 。运行简单的游戏对象项目

项目控制如下:

*   **返回按钮(F1 键)**退出程序
*   **一个按钮(K 键)**产生一个新的足球
*   **右手拇指操纵杆(箭头键)**移动新产生的足球

项目的目标如下:

*   了解如何创建具有简单行为的对象以及这样做的原因
*   使用对象的交互和相机窗口的边界
*   体验使用对象的边界

创建项目的步骤如下:

1.  修改现有的类以包含边界支持。
2.  添加对碰撞检测的支持。
3.  创建一个名为 SoccerBall 的球类。
4.  使用 SoccerBall 类。

在实现边界支持之前，您需要了解对象的边界是什么。看一下[图 3-12](#Fig12) 。它显示了纹理的边界，表示为 MinBound 和 MaxBound。MinBound 在纹理的左下角，MaxBound 在纹理的右上角。这是表示矩形对象边界的一种相当常见的方式，因为它只使用了两个点。定义了对象的边界后，您可以添加碰撞等行为。

![9781430266044_Fig03-12.jpg](img/-12.jpg)

[图 3-12](#_Fig12) 。纹理的边界和中心位置

您可以通过使用已知的纹理的位置和大小来计算这些边界的值。让我们试一试。

修改类以包含边界支持

1.  将 MinBound 和 MaxBound 变量添加到 TexturedPrimitive 类中。您可以在下面的代码中看到这一点。使用纹理的位置和大小允许边界被计算和返回。请注意，这两个界限都无法设置。这是因为只有当纹理的位置或大小改变时，纹理的边界才会改变。在计算中同时使用位置和大小可以确保边界的准确性。

    ```cs
    public Vector2 MinBound { get { return mPosition - (0.5f * mSize); } }
    public Vector2 MaxBound { get { return mPosition + (0.5f * mSize); } }
    ```

2.  现在给相机添加类似的边界。通过使用它的位置(sOrigin)和大小(sWidth，sHeight)来实现这一点。但是，请记住，sOrigin 位于相机的左下角，因此是相机的 MinBound。通过将宽度和高度加到源上，可以很容易地计算出 MaxBound。您可以在下面的代码中看到这一点:

    ```cs
    /// Accessors to the camera window bounds
    static public Vector2 CameraWindowLowerLeftPosition
        { get { return sOrigin; } }
    static public Vector2 CameraWindowUpperRightPosition
        { get { return sOrigin + new Vector2(sWidth, sHeight); } }
    ```

添加碰撞检测支持

1.  Start by creating an enum (enumerated date type) in the Camera class called CameraWindowCollisionStatus to represent the five simple states that an object can have in colliding with the camera window: Top, Bottom, Left, Right *,* and Inside.

    ![image](img/.jpg) **注**关于 enums 的更多信息，请参考[http://msdn.microsoft.com/library/sbbt4032.aspx](http://msdn.microsoft.com/library/sbbt4032.aspx)。

    ```cs
    // Support collision with the camera bounds
    public enum CameraWindowCollisionStatus {
        CollideTop = 0,
        CollideBottom = 1,
        CollideLeft = 2,
        CollideRight = 3,
        InsideWindow = 4
    };
    ```

2.  接下来，您需要为摄像机添加碰撞检测功能。以下代码显示了 CollidedWithCameraWindow()函数，该函数接受一个 TexturedPrimitive 对象，测试它与相机边界的碰撞，并返回碰撞状态:

    ```cs
    static public CameraWindowCollisionStatus CollidedWithCameraWindow(TexturedPrimitive prim)
    {
        Vector2 min = CameraWindowLowerLeftPosition;
        Vector2 max = CameraWindowUpperRightPosition;

        if (prim.MaxBound.Y > max.Y)
           return CameraWindowCollisionStatus.CollideTop;
        if (prim.MinBound.X < min.X)
           return CameraWindowCollisionStatus.CollideLeft;
        if (prim.MaxBound.X > max.X)
           return CameraWindowCollisionStatus.CollideRight;
        if (prim.MinBound.Y < min.Y)
           return CameraWindowCollisionStatus.CollideBottom;

        return CameraWindowCollisionStatus.InsideWindow;
    }
    ```

3.  最后，在 Game1 类中添加一个简单的随机数生成器，方法是创建一个随机类型变量，并在构造函数中初始化它:

    ```cs
    static public Random sRan; // For generating random numbers

    public Game1()
    {
        ...
        Game1.sRan = new Random();
    }
    ```

既然所有必要的支持代码都已完成，现在是时候创建 SoccerBall 类了。

创建*足球*类

1.  首先将图像 Soccer.png 添加到您的内容项目中。该图像可以在 chapter 03 \ source code \ ImagesAndFontUsed 文件夹中找到。
2.  创建一个新类，将其命名为 SoccerBall，并让它从 TexturedPrimitive 继承。这将允许您利用 SoccerBall 类中的所有 TexturedPrimitive 功能，并定义专门的行为。

    ```cs
    public class SoccerBall : TexturedPrimitive
    {
        ...
    }
    ```

3.  添加一个名为 mDeltaPosition 的变量来表示对象位置的变化。这将用于在更新期间移动球。

    ```cs
    private Vector2 mDeltaPosition; // Change current position by this amount
    ```

4.  根据下面的代码创建构造函数。首先初始化足球的位置和大小，并将这些值传递给基类(TexturedPrimitive)。然后通过使用 Game1 类的随机数支持来定义 mDeltaPosition 的变化量。

    ```cs
    public SoccerBall(Vector2 position, float diameter) :
            base("Soccer", position, new Vector2(diameter, diameter))
    {
        mDeltaPosition.X = (float) (Game1.sRan.NextDouble()) * 2f - 1f;
        mDeltaPosition.Y = (float) (Game1.sRan.NextDouble()) * 2f - 1f;
    }
    ```

5.  Add a variable for modifying and retrieving the radius of the ball. Remember that the SoccerBall class is a rectangle; therefore, changing its radius means changing the size of the rectangle’s width and height. You can see an example of this in the following image:

    ![9781430266044_unFig03-05.jpg](img/-05.jpg)

    ```cs
    public float Radius {
         get { return mSize.X * 0.5f; }
         set { mSize.X = 2f * value; mSize.Y = mSize.X;}
    }
    ```

6.  接下来，定义足球在碰撞时的行为。您可以在 SoccerBall 类的 Update()函数中实现这一点。添加 Update()函数，如下面的代码所示。请注意 mDeltaPosition 的 x 或 y 方向是如何根据球与相机边界的碰撞位置而反转的。Update()函数中的最后一行用 mDeltaPosition 的值改变球的位置。现在球应该会从摄像机的边界弹开。下图显示了碰撞情况的示例:

![9781430266044_unFig03-06.jpg](img/-06.jpg)

```cs
public void Update()
{
    Camera.CameraWindowCollisionStatus status = Camera.CollidedWithCameraWindow(this);
    switch (status) {
        case Camera.CameraWindowCollisionStatus.CollideBottom:
        case Camera.CameraWindowCollisionStatus.CollideTop:
            mDeltaPosition.Y *= -1;
        break;
        case Camera.CameraWindowCollisionStatus.CollideLeft:
        case Camera.CameraWindowCollisionStatus.CollideRight:
            mDeltaPosition.X *= -1;
        break;
    }
    Position += mDeltaPosition;
}
```

这就是 SoccerBall 类目前所需要的全部内容。现在可以使用了。足球的完整代码清单。cs 如[清单 3-2](#list2) 所示。

***[清单 3-2](#_list2)*** 。完整的*足球*类

```cs
public class SoccerBall : TexturedPrimitive
{
    private Vector2 mDeltaPosition; // Change current position by this amount

    /// <summary>
    /// Constructor of SoccerBall
    /// </summary>
    /// <param name="position">center position of the ball</param>
    /// <param name="diameter">diameter of the ball</param>
    public SoccerBall(Vector2 position, float diameter) :
            base("Soccer", position, new Vector2(diameter, diameter))
    {
        mDeltaPosition.X = (float) (Game1.sRan.NextDouble()) * 2f - 1f;
        mDeltaPosition.Y = (float) (Game1.sRan.NextDouble()) * 2f - 1f;
    }

    // Accessors
    public float Radius
        {
            get { return mSize.X * 0.5f; }
            set { mSize.X = 2f * value; mSize.Y = mSize.X;}
        }

    /// <summary>
    /// Compute the soccer ball's movement in the camera window
    /// </summary>
    public void Update()
    {
        Camera.CameraWindowCollisionStatus status =
                        Camera.CollidedWithCameraWindow(this);
        switch (status) {
            case Camera.CameraWindowCollisionStatus.CollideBottom:
            case Camera.CameraWindowCollisionStatus.CollideTop:
                mDeltaPosition.Y *= -1;
                break;
            case Camera.CameraWindowCollisionStatus.CollideLeft:
            case Camera.CameraWindowCollisionStatus.CollideRight:
                mDeltaPosition.X *= -1;
                break;
        }
        Position += mDeltaPosition;
    }
}
```

剩下的就是在你的游戏中使用足球。您可以在 Game1 类中做到这一点。

使用*足球*类

1.  首先，在 Game1 类 :

    ```cs
    TexturedPrimitive mUWBLogo;
    SoccerBall mBall;
    Vector2 mSoccerPosition = new Vector2(50, 50);
    float mSoccerBallRadius = 3f;
    ```

    中声明一个名为 mBall 的足球变量和一个名为 mUWBLogo 的 TexturedPrimitive 变量
2.  接下来，通过在 LoadContent()函数中实例化 mBall 和 mUWBLogo 将球加载到游戏中，如下所示:

    ```cs
    protected override void LoadContent()
    {
         ...
         // Create the primitives
         mUWBLogo = new TexturedPrimitive("UWB-PNG", new Vector2(30, 30), new Vector2(20, 20));
         mBall = new SoccerBall(mSoccerPosition, mSoccerBallRadius*2f);
    }
    ```

3.  现在通过调用球的 update()函数在 Update()函数中更新球；记得将控件(右边的拇指棒)作为参数传入。此外，增加了当游戏手柄的 A 按钮被按下时实例化一个新球的支持。

    ```cs
    protected override void Update(GameTime gameTime)
    {
         ...
         mUWBLogo.Update(InputWrapper.ThumbSticks.Left, Vector2.Zero);
         mBall.Update();
         mBall.Update(Vector2.Zero, InputWrapper.ThumbSticks.Right);

         if (InputWrapper.Buttons.A == ButtonState.Pressed)
              mBall = new SoccerBall(mSoccerPosition, mSoccerBallRadius*2f);
         ...
    }
    ```

4.  最后，记住通过调用 Game1 的 draw()函数中的 Draw()函数来绘制球。

    ```cs
    protected override void Draw(GameTime gameTime)
    {
         // Clear to background color
         ...
         mUWBLogo.Draw();
         mBall.Draw();

         // Print out text message to echo status
         FontSupport.PrintStatus("Ball Position:" + mBall.Position, null);
         FontSupport.PrintStatusAt(mUWBLogo.Position,
               mUWBLogo.Position.ToString(), Color.White);
         FontSupport.PrintStatusAt(mBall.Position, "Radius" + mBall.Radius, Color.Red);
         ...
    }
    ```

构建并运行程序。输出应该类似于[图 3-11](#Fig11) 。虽然程序应该运行，但在使用它时，您会注意到许多意想不到的奇怪现象。例如，如果球的大小在靠近窗口的边界时发生了变化，球将会卡在边界上。此外，有时球会移动到窗口边界之外，基本上就消失了。你可以通过在 A 按钮被按下时创建一个新球来避免这个问题；然而，这并不理想。要理解和解决这些问题，你需要钻研一些数学和物理(我们将在下一章讨论)。

简单游戏状态

既然已经成功地向 TexturedPrimitive 类添加了简单的行为，那么是时候探索如何支持简单的类似游戏的交互，或者一个*游戏状态*了。然而，在深入研究创建游戏状态项目的细节之前，我们将首先帮助组织您的想法。

到目前为止，您已经修改了 Game1.cs 来处理项目的初始化、加载、更新和绘制。理想情况下，避免直接使用 Game1.cs 是一个很好的做法，这样可以防止初始化或绘制函数等函数的复杂性，这会导致以后浪费调试时间。另外，需要一个新的类来帮助管理游戏状态。

您可以隔离您与 Game1.cs 的交互，并通过创建一个单独的类作为您与 Game1.cs 之间的接口来处理游戏状态的管理。我们将这个类称为 MyGame。MyGame 游戏状态类将包含 Update()和 Draw()函数，这些函数将处理游戏中每个对象的更新和绘制。这两个函数为您的游戏提供了 Game1.cs 所需的功能。上一个项目(简单的游戏对象)另一个值得注意的方面是子类化的实践。在那个项目中，您从 TexturedPrimitive 子类化了 SoccerBall 类,以利用预定义的行为。这样做为您提供了 TexturedPrimitive 类的功能以及向 SoccerBall 添加新的或专门的行为的能力。子类化不仅避免了不必要的代码，还减少了未来潜在的错误和重构代码的需要。掌握这个概念很重要，因为在你作为开发人员的剩余时间里，以及在本书的剩余时间里，你会多次遇到它。

简单游戏状态项目

这个项目演示了如何在屏幕上移动角色或英雄来收集篮球。篮球将随机生成，并随着时间的推移不断增加大小。一旦篮球达到一定的尺寸，它们就会爆炸。在爆炸前网住足够多的篮球会让你赢，让太多的篮球爆炸会让你输。[图 3-13](#Fig13) 显示项目运行。

![9781430266044_Fig03-13.jpg](img/-13.jpg)

[图 3-13](#_Fig13) 。运行简单的游戏状态项目

项目控制如下:

*   **返回按钮(F1 键)**退出程序
*   **一个按钮(K 键)**开始新游戏
*   **右手拇指操纵杆(箭头键)**控制英雄的移动

项目的目标如下:

*   了解游戏状态组织的需求
*   实现 GameState 类来存放游戏逻辑和控件

创建项目的步骤如下:

1.  添加 TexturedPrimitive 碰撞检测支持。
2.  创建一个篮球班。
3.  创建 GameState 类。
4.  修改 Game1.cs 支持游戏状态。

在开始之前，将以下资源(可在 chapter 03 \ source code \ ImagesAndFontsUsed 文件夹中找到)添加到内容项目中:

*   篮球. png
*   Loser.jpg
*   Winner.jpg
*   我.png

添加 *TexturedPrimitive* 碰撞检测支持

在创建新对象和定义游戏状态之前，打开 TexturedPrimitive 类并添加以下代码。PrimitivesTouches()函数检测两个 TexturedPrimitive 对象在空间上是否重叠。这是通过将两个对象的位置之间的距离与两个对象的总宽度的一半进行比较来实现的。理解这个函数的一个简单方法是，注意它使用对象之间的距离的简单比较，同时考虑它们的大小，以查看两个对象是否重叠。

```cs
public bool PrimitivesTouches(TexturedPrimitive otherPrim)
{
    Vector2 v = mPosition - otherPrim.Position;
    float dist = v.Length();
    return (dist < ((mSize.X / 2f) + (otherPrim.mSize.X / 2f)));
}
```

创建一个*篮球*班

1.  首先创建一个名为 BasketBall 的类，它继承自 TexturedPrimitive。接下来，添加三个变量 kIncreaseRate、kInitSize 和 kFinalSize，如下面的代码所示。

    ```cs
    private const float kIncreaseRate = 1.001f;
    private Vector2 kInitSize = new Vector2(5, 5);
    Private const float kFinalSize = 15f;
    ```

    *   kIncreaseRate 是篮球尺寸增加的速率。
    *   kInitSize 是篮球的初始尺寸。
    *   kFinalSize 是篮球爆炸时的大小。
2.  现在给这个类一个构造函数，将篮球的位置初始化为一个随机点，并设置它的初始大小。记得使用 TexturedPrimitive 提供的基本函数。

    ```cs
    public BasketBall() : base("BasketBall")
    {
        mPosition = Camera.RandomPosition();
        mSize = kInitSize;
    }
    ```

3.  The last function needed for the BasketBall class provides the object with some specialized behavior. Create an UpdateAndExplode() function that will increase the ball size and check whether the ball should explode or expire if the final size is reached.

    ```cs
    public bool UpdateAndExplode()
    {
        mSize *= kIncreaseRate;
        return mSize.X > kFinalSize;
    }
    ```

    这就是篮球课所需要的。清单 3-3 显示了 BasketBall 类的完整代码清单。

***[清单 3-3](#_list3)*** 。完整的篮球课

```cs
public class BasketBall : TexturedPrimitive
{
    // Change current position by this amount
    private const float kIncreaseRate = 1.001f;
    private Vector2 kInitSize = new Vector2(5, 5);
    private const float kFinalSize = 15f;

    public BasketBall() : base("BasketBall")
    {
        mPosition = Camera.RandomPosition();
        mSize = kInitSize;
    }

    public bool UpdateAndExplode()
    {
        mSize *= kIncreaseRate;
        return mSize.X > kFinalSize;
    }
}
```

创建游戏状态对象

1.  首先创建一个名为 MyGame 的新类。
2.  Next, you need to declare the variables the game will need. This includes the variables required for the hero, the basketballs, and the game state.
    1.  对于英雄，声明一个 TexturedPrimitive，并声明两个 Vector2s 一个用于英雄大小，一个用于位置:

        ```cs
        // Hero stuff ...
        TexturedPrimitive mHero;
        Vector2 kHeroSize = new Vector2(15, 15);
        Vector2 kHeroPosition = Vector2.Zero;
        ```

    2.  对于篮球，您需要一个篮球对象列表，因为您将在整个游戏过程中创建新的篮球。此外，您需要一个 timespan 和 integer 来跟踪何时生成下一个 BasketBall 对象并将其添加到列表中。最后，您将使用另一个整数来存储创建的球的总数。

        ```cs
        // Basketballs ...
        List<BasketBall> mBBallList;
        TimeSpan mCreationTimeStamp;
        int mTotalBBallCreated = 0;
        // this is 0.5 seconds
        const int kBballMSecInterval = 500;
        ```

    3.  您需要声明的最后一个变量与游戏状态相关。以下代码显示了跟踪游戏分数所需的变量，以及在玩家赢或输时显示的 TexturedPrimitive 对象。

        ```cs
        // Game state
        int mScore = 0;
        int mBBallMissed=0, mBBallHit=0;
        const int kBballTouchScore = 1;
        const int kBballMissedScore = -2;
        const int kWinScore = 10;
        const int kLossScore = -10;
        TexturedPrimitive mFinal = null;
        ```

    现在是时候添加构造函数、更新函数和绘制函数了。

3.  首先用指定的纹理、位置和大小初始化你的英雄对象。同时初始化篮球列表和 mCreationTimeStamp:

    ```cs
    public MyGame()
    {
        // Hero ...
        mHero = new TexturedPrimitive("Me", kHeroPosition, kHeroSize);

        // Basketballs
        mCreationTimeStamp = new TimeSpan(0);
        mBBallList = new List<BasketBall>();
    }
    ```

4.  接下来，您需要创建更新函数。这个稍微复杂一点；以下是步骤:
    1.  *检查是否需要更新。*这里你首先需要检查的是输赢条件。这通过检查 mFinal 是否等于 null 来实现。如果 mFinal 不等于 null，那么已经满足了输赢条件，游戏不再需要更新。

        ```cs
        public void UpdateGame(GameTime gameTime)
        {
            #region Step a.
            if (null != mFinal) // Done!!
            return;
            #endregion Step a.
            ...
        }
        ```

    2.  *更新所有对象*。接下来，通过调用更新函数来更新每个游戏对象。在英雄的更新功能中，游戏手柄的右手拇指棒被传入以允许控制。在篮球对象列表中，调用 UpdateAndExplode()函数，如果返回值为真(意味着球确实爆炸了)，那么从列表中移除相应的对象，更新分数。

        ```cs
        public void UpdateGame(GameTime gameTime)
        {
            ...
            #region Step b.
            // Hero movement: right thumb stick
            mHero.Update(InputWrapper.ThumbSticks.Right);

            // Basketball ...
            for (int b = mBBallList.Count-1; b >= 0; b--)
            {
                if (mBBallList[b].UpdateAndExplode())
                {
                    mBBallList.RemoveAt(b);
                    mBBallMissed++;
                    mScore += kBballMissedScore;
                }
            }
            #endregion Step b.
                  ...
        }
        ```

    3.  *处理所有对象之间的交互*。现在你需要处理游戏对象之间的任何交互。具体来说，您希望使用 PrimitivesTouches()函数遍历篮球列表，检查英雄是否与它们发生了碰撞。如果一个物体发生碰撞，你从列表中删除篮球物体并更新分数。

        ```cs
        public void UpdateGame(GameTime gameTime)
        {
            ...
            #region Step c.
            for (int b = mBBallList.Count - 1; b >= 0; b--)
            {
                if (mHero.PrimitivesTouches(mBBallList[b]))
                {
                    mBBallList.RemoveAt(b);
                    mBBallHit++;
                    mScore += kBballTouchScore;
                }
            }
            #endregion Step c.
                  ...
        }
        ```

    4.  产生新的敌人。接下来，您想要检查是否需要创建一个新的 BasketBall 对象。通过记录当前时间和球创建的最后时间，然后检查以确定这两个时间之间的差值是否大于创建时间间隔(kBballMSecInterval)。如果是这样，您创建一个新的篮球对象，将其添加到列表中，并增加球总数。

        ```cs
        public void UpdateGame(GameTime gameTime)
        {
            ...
            #region Step d.
            // Check for new basketball condition
            TimeSpan timePassed = gameTime.TotalGameTime;
            timePassed = timePassed.Subtract(mCreationTimeStamp);
            if (timePassed.TotalMilliseconds > kBballMSecInterval)
            {
                mCreationTimeStamp = gameTime.TotalGameTime;
                BasketBall b = new BasketBall();
                mTotalBBallCreated++;
                mBBallList.Add(b);
            }
            #endregion Step d.
            ...
        }
        ```

    5.  *Check for a win-or-loss condition*. The last thing you need to check in the update function is whether the win-or-loss condition has been met. For this game, you can do this easily by determining whether the current score (mScore) is greater than the winning score or less than the losing score. If either of those conditions has been met, you can assign the appropriate corresponding texture to the mFinal TexturedPrimitive object.

        ```cs
        public void UpdateGame(GameTime gameTime)
        {
            ...
            #region Step e.
            // Check for winning condition ...
            if (mScore > kWinScore)
                mFinal = new TexturedPrimitive("Winner",
                                                        new Vector2(75, 50), new Vector2(30, 20));
            else if (mScore < kLossScore)
                mFinal = new TexturedPrimitive("Looser",
                                                        new Vector2(75, 50), new Vector2(30, 20));
            #endregion Step e.
        }
        ```

        虽然不是小事，但是你通常可以根据游戏规则，把游戏状态的更新功能分成截然不同的逻辑步骤。刚刚描述的五个步骤是(1)检查是否需要更新，(2)更新所有游戏对象，(3)处理所有游戏对象之间的交互，(4)产生新的敌人，以及(5)检查输赢情况。这些步骤可以作为许多简单游戏的模板。

5.  所需的最后一个函数是绘制函数。这个函数通过调用相应的 draw 函数来绘制英雄、篮球对象和输赢图。此外，状态被打印出来，以显示游戏的得分和统计数据。

    ```cs
    public void DrawGame()
    {
        mHero.Draw();

        foreach (BasketBall b in mBBallList)
            b.Draw();

        if (null != mFinal)
            mFinal.Draw();

        // Drawn last to always show up on top
        FontSupport.PrintStatus("Status: " +
                                    "Score=" + mScore +
                                    " Basketball: Generated( " + mTotalBBallCreated +
                                    ") Collected(" + mBBallHit + ") Missed(" + mBBallMissed + ")", null);
    }
    ```

修改*游戏 1* 以支持游戏状态

你需要完成的最后一个任务是在 Game1.cs 中初始化并连接游戏状态(MyGame)，如下面的代码所示，通过声明一个新的 MyGame 对象，在 LoadContent 函数中初始化，在 Game1 的 update 函数中更新，在 draw 函数中绘制，就可以轻松实现。此外，请注意，我们添加了在按下 A 按钮时通过实例化新的 MyGame 对象来启动新游戏的功能。

```cs
public class Game1 : Game
{
    ...
    MyGame
mTheGame;

    public Game1()
    {
        ...
    }

    protected override void LoadContent()
    {
        ...
        mTheGame = new MyGame();
    }

    protected override void Update(GameTime gameTime)
    {
        ...
        mTheGame.UpdateGame(gameTime);

        if (InputWrapper.Buttons.A == ButtonState.Pressed)
            mTheGame = new MyGame();
        ...
    }

    protected override void Draw(GameTime gameTime)
    {
        ...
        mTheGame.DrawGame();
        ...
    }
}
```

您的游戏状态项目现在已经完成。尝试构建并运行该程序。它看起来应该类似于前面显示的图 3-13 。记住通过赢、输和开始一个新游戏来测试程序，以验证游戏的行为。

摘要

在这一章中，你已经学习了创建你自己的定制游戏所需的许多基本的图形和效果原理。这包括修改游戏窗口，创建有纹理的图元，以及将文本输出到游戏窗口。

提到的另一个重要概念是用户定义的坐标系。用户定义的坐标系提供了适当控制用户所看到的游戏世界所需的灵活性和功能。它还提供了各种游戏所需的定制。

最后，您已经看到了为对象提供简单行为和为游戏提供简单游戏状态需要什么。从技术和设计的角度来看，游戏状态和对象行为是创建一个游戏所需要的关键部分。一个对象在游戏世界中的行为方式以及它如何与用户和游戏状态交互通常被称为游戏性。在接下来的章节中，你会看到如何创建更高级的对象行为和游戏状态。

快速参考

| 

到

 | 

做这个

 |
| --- | --- |
| 改变游戏窗口的大小 | 修改图形。PreferredBackBufferWidth 和 mGraphics . preferredbackbufferheight .记住调用 mGraphics。ApplyChanges()函数来激活窗口大小的改变。 |
| 将窗口改为全屏显示 | 设置图形。IsFullScreen 为 true 或 false。再一次，记得打电话给经理。ApplyChanges()函数来激活更改。 |
| 绘制同一图形对象的多个副本并与之交互 | 定义一个类来抽象所需的行为，例如 TexturedPrimitive 类。请记住，为您的类定义 Update()和 Draw()函数非常方便。可以从 Update()和 Draw()函数中调用这些函数来更新和绘制对象。 |
| 使用你自己的游戏对象类 | 1.定义实例变量来代表你的游戏对象。
2。在 LoadContent() *中实例化并初始化游戏对象。*
3。在 Update() *中对用户进行投票并改变游戏对象。*
4。在 Draw() *中绘制游戏对象。* |
| 使用用户定义的坐标系 | 允许用户通过指定游戏窗口左下角的位置和宽度来定义所需的坐标空间。定义函数，通过平移、缩放和翻转 y 轴，将用户定义的坐标空间转换为像素坐标空间。在本章的例子中，这个功能是在 Camera 类中定义的。SetCameraWindow()函数允许用户定义坐标系。ComputePixelPosition()和 ComputePixelRectangle()函数实现了位置和矩形从用户定义的坐标空间到像素坐标空间的转换。 |
| 在用户定义的坐标系中绘制 | 1.通过调用相机来定义坐标空间。SetCameraWindow()函数。
2。在已定义的坐标空间中定义所有游戏对象。
3。在绘制游戏对象之前，记得调用相机。ComputePixelRectangle()函数从用户定义的坐标空间转换到像素坐标空间。 |
| 将字体加载到项目中 | 遵循与加载图像相同的步骤:右键单击 ContentProject 并找到字体文件。一般来说，将任何外部文件或资源加载到项目中时，都要遵循相同的步骤。 |
| 在你的游戏中绘制字体 | 您可以使用 FontSupport 类并调用 PrintStatus()函数将文本输出到游戏窗口的左上角，或者调用 PrintStatusAt()函数将文本打印到用户定义的坐标系位置。 |
| 定义游戏对象的特定行为 | 一种方便的方法是从 TexturedPrimitive 类定义一个子类:
1。将新文件添加到项目中。
2。实现行为(例如，通过更改 Update()函数)。
3。如果可能，重用 Draw()函数。
4。和你的新班级一起工作。 |
| 避免在 Game1.cs 文件中使用复杂的代码 | 创建一个单独的*游戏状态*对象来创建、维护和控制你自己的游戏状态。 |
| 实现 GameState 对象的 Update()函数 | 遵循这些简单的步骤:
1。检查是否需要更新(例如，暂停或结束游戏)。
2。为所有游戏对象调用 Update()函数。
3。处理所有相关游戏对象之间的交互。
4。如有必要，滋生新的敌人。
5。检查输赢情况。 |*