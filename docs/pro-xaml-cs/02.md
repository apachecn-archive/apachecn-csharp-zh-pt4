# 2.软件工艺

“证据就在布丁里！”

## 作为艺术和科学的软件

现在，我们已经介绍了可扩展应用程序标记语言(XAML)及其不同的“方言”，或者 WPF、Windows 8.1/Windows Store 和 Windows Phone 8.1 XAML 之间存在的异常，我们可以专注于设计模式和行业最佳实践，您将在本书的其余部分中使用它们来设计和开发“智能客户端”业务线(LOB)应用程序。这本书的主要思想是带你体验与虚拟团队一起工作的经历。这样做将有助于您学习相关的关键概念，方法是提出您将面临的一些常见问题，并为您提供无论您在哪个 IT 领域工作都会引起共鸣的提示。

本书中介绍的模式和范例将为您提供设计和开发健壮的、可重用的、与业务领域相关的软件解决方案所需的信息，这些解决方案可以解决企业中发现的问题，同时使用有效的设计方法、设计模式和软件开发社区中使用的其他工具。

这本书将提供如何在三个基于 XAML 的目标平台之间实现最高级别的用户界面层组件重用的提示和技巧。本书中的应用程序在设计时考虑了灵活性。这本书将集中在坚实的面向对象的设计原则，以帮助你设计组成你的应用程序的类。最终目标是说明如何设计被划分为逻辑层的应用程序，这些逻辑层促进关注点的清晰分离。在物理上，这些层将代表简洁、灵活、可扩展的类库，并且与整个系统中的其他组件松散耦合。这将最大化整个组织的代码重用，并使您的代码更容易编写单元测试。

## 固体面向对象设计

实线中的 S 代表单一责任原则。这个原则意味着一个类应该有且只有一个责任。例如，你的`Order`类不应该关心年度报告是如何打印的。这将是一个名为`ReportPrintService`的类的责任。`Order`类应该只负责描述系统中的订单。

实线中的 O 代表开/关原理。这意味着您应该将代码设计为对扩展性开放，对修改封闭。您可能会问自己，“我如何在不修改代码的情况下使一个类可以被扩展？”有几种方法可以帮助你实现这个原则。例如，您可以创建一个基类并从该基类继承来自己实现方法。我们最喜欢的方法是一种叫做装饰模式的设计模式。你可以在 [`http://sourcemaking.com/design_patterns/decorator`](http://sourcemaking.com/design_patterns/decorator) 找到官方定义。

> "The decorator pattern dynamically attaches additional responsibilities to an object. Decorators provide a flexible way to replace subclasses for extended functions.

在本章的后面，我们将提供这种模式的完整例子，以及其他有用的设计模式。实线中的 L 代表利斯科夫替代原理。这意味着您应该能够将您的类的实例作为该类实现的任何基类或任何接口来引用。实线中的 I 代表接口分离原则，该原则指出，如果可能的话，您应该编写接口代码，而不是具体的实现。最后，实线中的 D 代表依赖反转原则，它提倡两种模式:依赖注入(DI)和控制反转。

Note

SOLID object design principles 代表一个缩写词，其中每个字母代表在面向对象设计中设计类、属性或方法时要考虑的一个原则。

## 去单元测试还是不去单元测试？

单元测试的话题引发了争论，每个参与者都强烈地感受到他们的立场。一方可能会说，“单元测试在理论上听起来很棒，但是我没有时间满足最后期限并编写我一无所获的单元测试！”另一个人可能会坚持说，“单元测试是自切片面包和涂在上面的黄油以来最好的东西！”第三方可能会说，“我写了 20 多年的代码，没有单元测试也很好。”最后，可能会有一个人相信，“通过单元测试，我知道一个 bug 被引入系统的时刻，以及在哪里找到它。”这些只是我想到的几个论点。

没有绝对“正确”的答案。老实说，单元测试会增加额外的开发时间吗？一般来说，答案是肯定的。单元测试有助于减少应用程序中的错误吗？有许多研究表明，单元测试实际上有助于减少代码的错误倾向。就像其他任何事情一样，单元测试需要实践来获得熟练程度，这意味着只有当单元测试是质量测试时，它们才会提供质量保护。你必须知道要测试什么，哪些单元测试是多余的或误导的。熟能生巧！

### 测试驱动开发

当我们谈到单元测试的话题时，我们有义务谈一谈测试驱动开发(TDD)。TDD 是一种软件开发范例，在这种范例中，您甚至可以在实现被测试的类之前编写单元测试。如果您在测试方法之前编写每个测试，就可以保证单元测试覆盖所有方法。

使用 TDD 还有一个很多人忽略的好处。如果你在一个`PrintService.PrintReport()`存在之前为方法`PrintService.PrintReport()`编写一个单元测试，那么你就是在设计方法和`PrintService`类的公共契约。这种设计是基于您对该类应该如何使用的自然想象。因此，您不仅可以保证每个方法至少有一个与之相关的单元测试，还可以根据您将如何使用类来设计您的类。当单元测试完成时，它可以作为一个简洁的例子来说明应该如何使用这个类。

TDD 不仅仅是首先编写单元测试，所以下面是 TDD 的规则:

*   要考虑的第一条规则是“确保单元测试失败。”显然，如果您在被测试的类存在之前编写测试，您的解决方案将无法编译。这与您遇到的第一次失败不同，因此您需要为测试中使用的类创建一个空的类声明，以便它能够正确构建。一旦测试构建完成，然后运行它来经历第一次失败。一旦您的测试失败了，下一步就是对测试中的类进行尽可能小的修改，然后再次运行它。这样做，直到测试通过。这个过程的关键是在测试通过之前进行小的增量更改的重要性。如果你要构建你的单元测试，但是第一次失败了，那么你应该继续前进，让测试通过。我们建议您快速编写整个方法，尝试为您将要实现的类预测问题和其他想法。不要为了通过单元测试而做小的增量更改，而是做一个大的更改，甚至添加一些您知道将会出现的字段或方法。所以，有什么大不了的？当你以增量的方式尽可能地做最小的改变时，你将只添加绝对必要的东西，这将极大地减少你的代码的大小和复杂性。
*   现在是重构方法的时候了。因为您使用了小的、增量的变更，所以您应该重构您已经创建的方法，以确保它是干净和简洁的。因此，循环是这样的:红色➤绿色➤重构➤再测试。
    *   红色:由于没有实现，单元测试失败。
    *   绿色:在小的、递增的变化之后，单元测试通过。小的增量更改保证您不会超越自己，并且您只添加通过测试所需的代码，这可以降低复杂性。
    *   重构:返回并重构你的新代码以清理实现，并再次测试以确保你的重构没有破坏任何东西。
    *   重新测试:继续你的下一个测试。

假设您想编写一个应用程序，该应用程序在登录时接受用户名，并向用户返回一条欢迎消息。TDD 风格大概是这样的:

Create a new blank solution in Visual Studio.   Create a class library for the functionality of the program, create a new unit test project for the solution, and add a reference to the class library so that the test can actually use the library to test it.   Rename the default unit test class that is created with the unit test project.   Create your first test, which would looking something like the one shown in Listing [2-1](#FPar1).   Listing 2-1\. GreetingTests.cs

`using System;`

`using Microsoft.VisualStudio.TestPlatform.UnitTestFramework;`

`using ApressXaml.Usb;`

`namespace ApressXaml.Usb.UnitTests`

`{`

`[TestClass]`

`public class GreetingTests`

`{`

`private IUserLoginService _UserLoginService;`

`[TestInitialize]`

`public void Test_Init()`

`{`

`_UserLoginService = new UserLoginService();`

`}`

`[TestMethod]`

`public void If_A_Name_Length_GreaterThan_0_Then_Service:Returns_Message()`

`{`

`if (_UserLoginService == null)`

`throw new NullReferenceException();`

`var validName = "Buddy";`

`var actualGreeting = _UserLoginService.GreetUser(validName);`

`var expectedGreeting = "Hello Buddy!";`

`Assert.AreEqual(expectedGreeting, actualGreeting, "The user greeting is incorrect");`

`}`

`}`

`}`

如您所见，这里有一个简单的测试类。您在类库中创建一个`IUserLoginServer`接口和一个`UserLoginService`类，这样解决方案就可以编译了。然而，没有实现，所以测试一开始会失败(这是您希望发生的)。

既然测试已经成功失败，现在是时候进行小的增量更改直到测试通过，如清单 [2-2](#FPar2) 所示。

Listing 2-2\. Empty IUserLoginService.cs Interface Definition

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`namespace ApressXaml.Usb`

`{`

`public interface IUserLoginService`

`{`

`string GreetUser(string userName);`

`}`

`}`

正如您在清单 [2-3](#FPar3) 中看到的，类中唯一存在的东西是`GreetUser`方法声明。这是构建解决方案所必需的，这样测试才能失败。现在，您需要做尽可能小的改变来通过测试。这应该很容易。

Listing 2-3\. Empty UserLoginService.cs Class Definition

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`namespace ApressXaml.Usb`

`{`

`public class UserLoginService : IUserLoginService`

`{`

`public string GreetUser(string validName)`

`{`

`throw new NotImplementedException();`

`}`

`}`

`}`

用单元测试中预期的功能替换抛出`NonImplementedException`的行。清单 [2-4](#FPar4) 显示了添加了这个小改动的类。

Listing 2-4\. UserLoginService.cs with Small, Incremental Change to Make the Test Pass

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`namespace ApressXaml.Usb`

`{`

`public class UserLoginService : IUserLoginService`

`{`

`public string GreetUser(string validName)`

`{`

`return string.Format("Hello {0}!", validName);`

`}`

`}`

`}`

正如您所看到的，只有一行代码是不同的，当测试再次运行时，它通过了。然而，看一下代码。在`validName`参数上没有空引用检查。这个`validName`参数应该有一个更符合其用途的名称，并且您应该总是检查空值。

这是我们很难习惯的 TDD 的一部分。一开始，我们会在第一次编辑课程时发现这些问题并解决它们。然而，通过大量的实践，我们已经学会了等到过程的重构阶段，这样我们就可以在每次迭代中只改变最少量的代码，直到测试通过。

现在是时候重构方法了，进行清单 [2-5](#FPar5) 中所示的修改，并重新测试直到所有测试都通过。然后继续下一个测试，反过来，下一个特性。

Listing 2-5\. The Final Version of the UserLoginService.cs After Refactoring and Retesting

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`namespace ApressXaml.Usb`

`{`

`public class UserLoginService : IUserLoginService`

`{`

`public string GreetUser(string userName)`

`{`

`if (string.IsNullOrEmpty(userName))`

`throw new ArgumentNullException("userName");`

`if (userName.Length == 0)`

`throw new ArgumentException("userName cannot be empty.");`

`return string.Format("Hello {0}!", userName);`

`}`

`}`

`}`

如您所见，您添加了一些防御性编程(空引用检查)，重命名了参数，并更改了方法的返回类型。一旦你完成了这些重构，测试就会重新运行，这次它通过了。这就是我们更喜欢使用 TDD 的方式。在解决方案完成之前，您将在本书中编写更多的单元测试。

## 见见团队

设计方法和设计模式是任何软件项目的主要组成部分，但是在我们进入本书将使用的设计模式之前，让我们来认识一下我们的虚拟团队！这个场景是，您最近接受了 Acme Systems 的邀请，帮助开发几个行业应用程序。该公司最近更换了所有者，他们决定将所有的企业系统开发放在内部进行。团队中充满了个人，他们有自己的角色，有自己的观点，并为自己的工作带来不同层次的经验。

### 开发经理

开发经理是你的上司。开发经理的工作是管理分配给这个新公司项目的所有资源。开发经理必须掌握人员、项目预算和时间表。

### 商业分析师

业务分析师了解业务。更重要的是，业务分析师知道向业务用户询问什么问题，以便获得关于软件项目的有用信息。业务分析师将接受开发人员提出的需求收集问题，解释这些问题的原因，并提供解决方案。业务分析师的角色是强调获取业务领域知识的重要性，以确保用户的需求得到满足。

### 初级开发人员

初级开发人员是入门级的。团队中经验最少的. NET 程序员。初级开发人员刚从大学毕业。这是开发人员在软件开发中的第一份工作。每个人都说初级开发人员学得很快，喜欢做软件开发。初级开发人员很热情，这有时会被误解为过分热情——但这个人是好意。初级开发人员站在所有最新技术的顶端，并很快建议他们在项目中使用。初级开发人员会向你寻求指导，通过指出错误，你也可以学到新的东西。大多数人都能理解初级开发人员；毕竟每个人在职业生涯中都曾经是那样的人。

### 古鲁

古鲁用键盘施展魔法。这位大师的经验包括整本书使用的所有设计模式和技术。大师是任何与软件相关的事情(或者更多)的“关键人物”(是的，双关语)。当谈到软件开发时，大师可能是顽固的，尽管这个人在亲自考虑所有重要因素后采用新技术是众所周知的。古鲁有点内向；然而，当被问到时，这个人很乐意为团队提供指导。

### 数据库管理员

DBA 在数据访问和存储领域工作。DBA 持有数据库的密钥(是的，又是双关语)。DBA 控制着从数据库服务器类型到模式、角色、用户和权限的数据访问相关决策。DBA 负责开发过程中的模式变更请求。DBA 还负责数据库备份和恢复(灾难恢复)。您必须始终记住，DBA 不仅负责新系统，还负责旧的遗留系统。

## 第一次团队设计会议

第一次设计会议由您、初级开发人员、专家、业务分析师、DBA、产品冠军和开发经理组成。

会议期间，小组的议程如下:

*   让团队成员见面并相互熟悉
*   讨论团队将要解决的业务问题
*   确定每个人在团队中的角色
*   讨论任何存在的项目截止日期
*   决定团队发展模式
*   创建会议日程
*   决定团队将使用的沟通方法
*   决定将要使用的技术(基于已经给出的信息)

在第一次会议中，您将了解需要解决的业务问题。除了产品冠军之外，业务分析师对团队中的业务流程了如指掌。产品冠军是客户的雇员，被认为是“超级用户”这些人被选中每周分配时间来协助解决方案的开发。

会议开始时，业务分析师解释要解决的业务问题的细节。“正如你们中的许多人所知，Acme 已经决定将所有的系统开发都放在内部。当发现强制会计系统更新破坏了与 Acme Systems 中使用的内部采购申请系统的集成时，就做出了这个决定。”

计划是在一年内重写整个会计系统。之所以决定从采购申请系统开始，是因为旧的解决方案不再适用于遗留系统。

如果说我们在过去十年的软件开发中学到了什么，那就是:如果你向软件开发人员提供 20 令打印的 UML 图和其他传统风格的设计工件，并请求他们创建一个软件解决方案，十有八九你会得到一个对开发人员来说非常有意义的应用程序，但仍然不符合业务用户对系统应该是什么样子的想法。这是因为典型的软件开发人员是软件开发方面的专家，而不是他们正在解决业务问题的业务领域的专家。开发者不会像用户一样思考。

关键是您需要来自系统用户的反馈，并且在软件解决方案的开发过程中您经常需要反馈。有了开发过程中不断的反馈，您可以放心，您正在为用户的需求而开发。

## Scrum 敏捷方法

所有团队成员都有使用 Scrum 敏捷团队范式的经验，所以他们决定使用 Scrum 和敏捷方法。因此，我们决定团队将进行为期两周的冲刺或迭代开发，他们将使用 Team Foundation Services(TFS)2013 来记录产品积压、计划和安排冲刺、创建用户故事和任务以及应用程序的源代码控制。

TFS 是一个很好的选择，因为它与 Visual Studio 的集成非常棒。这是一个跟踪问题、跟踪 bug、记录用户故事和提供评估的一站式商店。您可以在整个生命周期中创建一个用户故事，从创建到创建包含开发这个故事所需的所有信息的特定子任务，一直到验收测试。

TFS 与 SharePoint 的集成增加了一个漂亮的网络友好的用户界面。您可以创建 Excel 电子表格，显示与完成的 sprints 和剩余产品待办事项相关的图表。SharePoint TFS 门户有一个 wiki，团队可以使用它来获取有关项目的重要信息。你可以从网上计划短跑等等。

TFS 的一个特点绝对是天赐之物——它与微软 Office 的集成。您可以创建查询来检索 TFS 工作项的子集，并将列表导出到 Excel 电子表格。与手动输入 50 多个用户故事相比，电子表格将允许您轻松地创建批量项目。此外，有些人会要求在 URL 上有一个电子表格来显示他们可能需要的所有信息。啊，公共电子表格——一个电子表格，一个网络共享，四个不同的用户。你可能会微笑着咬紧牙关。没有去过那里的人，要心存感激。

该团队决定用尽可能多的单元测试覆盖率来创建软件，并且他们将使用 Visual Studio 内置的 mstest 功能来维护单元测试。团队要求在两周内召开另一次会议，与产品冠军一起创建用户故事并确定其他需求。

Note

TFS 是微软的源代码控制解决方案。它提供了工作项跟踪、自动化构建等等。

## 在收集需求时，如何“言出必行”

作为一名开发人员，我相信您已经意识到，您的业务应用程序系列的用户并不在乎您在编写程序时从头实现了一个链表。他们关心系统如何被使用，它产生的结果，以及产生结果的速度。因此，开发人员与业务用户密切合作，尽可能多地了解用户日常工作负载的业务方面，以及如何创建软件来改善他们的工作，这一点很重要。

做到这一点的一个主要因素就是词汇。在头脑风暴会议期间，当业务分析师和最终用户解释系统时，一定要识别名词和动词。如果你问一个问题，而答案以“你是说一个 _ _ _ _ _ _ _ _”这样的话开头。这些是你需要识别和记录的术语，以便它们以后成为你无处不在的语言的一部分(见第 3 章)。

你对你正在创造解决方案的问题的商业方面了解得越多，你成功的机会就越大。尝试从非编程的角度研究业务领域。或许提议请业务分析师或业务用户吃午餐，这样你们就可以讨论任何问题。试着说他们的语言。

### 用户故事以及如何创建它们

在敏捷开发中，用户故事基本上是一个简化的用例。它代表了用户和系统之间的交互。有时，一个用户故事甚至会代表两个系统之间的交互！

#### 剖析一个好的用户故事

一个好的用户故事有许多众所周知的特征。首先，用户故事必须对业务有价值。这意味着用户故事应该使用业务领域中无处不在的语言来编写，这样任何人都可以理解请求。

优秀用户故事的另一个关键是简洁。这个想法并不是要详细讨论用户故事特性的设计和开发的每一个方面。相反，您应该获取足够的信息，以便能够在以后的开发过程中引用用户故事，如果特性通过了筛选，那么使用用户故事来开始规划特性的设计。如果你在一开始就用特性的设计选择创建了用户故事，而用户故事没有通过，那么你将会失去在一个不能实现的特性设计上工作的所有时间。保持简短，甜蜜，并在商业领域的条款。

咨询时，我们在创建用户故事时使用索引卡。你甚至可以问商业用户，他们是否介意尝试用自己的话在这些卡片上写下这些故事。如果用户解释了用户故事，你就一定会抓住用户想要什么，并且是用业务领域的术语。如果你自己写，你可以写一个故事标题，日期，然后是一个简短的描述。请记住，这个想法并不是要捕捉所有重要的细节；关键是要写得足够多，以便在需要的时候记得如何询问细节。

## 摘要

的确，软件开发既是一门艺术也是一门科学。在过去的十年中，编程风格、软件设计和需求收集都有了很大的进步。在这个过程中，我们学会了在项目开始时停止创建大量的工作。相反，我们开始明白变化几乎是必然的，而当前的设计风格对变化既不有益也不友好。这些变化破坏了评估和预算，最终产生了用户不得不学会“处理”而不是享受的软件。

现在，我们有了将业务放在首位的敏捷方法。没有业务问题，就没有要构建的软件解决方案。我们了解到，用户参与设计对于业务应用程序系列至关重要，最好与选定的用户一起展示进展并立即获得反馈。

还有另一种软件设计风格与我们新发现的以业务为中心的软件开发解决方案相吻合。这叫做领域驱动设计(DDD)，我们将在下一章讨论这种设计方法。