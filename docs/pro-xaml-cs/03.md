# 三、领域驱动设计

> We don't write code; We solve business problems.

## 引入领域驱动的设计

你如何衡量一个软件项目的成功？您是否仅仅依赖于按计划部署解决方案？设计文档的数量和质量，例如远景和范围文档、包图、组件图、关键特性类图和其他各种统一建模语言(UML)图，是否提供了项目成功或失败的指标？你见过在基于瀑布设计的软件开发项目中创建的文档吗？我认为试图让所有这些文档与系统不断变化的需求保持同步是一场噩梦。不用了，谢谢。我宁愿晚上睡觉。

我相信，当最终的应用提供了用户所要求的改善业务流程的价值时，软件项目就被认为是成功的。通常，它通过简化用户的工作流程，让用户的生活变得更加轻松(按计划和预算进行也没有坏处)。

在过去的十年中，应用开发有了很大的发展。面向对象的设计是成熟的，并且会一直保持下去。业界张开双臂欢迎设计模式的想法。然而，在所有的新范例中，没有一个比领域驱动设计(DDD)更能付诸实践。

Caution

领域驱动设计是规则、术语、指南和模式的巨大集合。事实上，为了完全涵盖这个范例，我需要写一本关于这个主题的书。这本书只包含 DDD 的概述。这本书提供了足够的内容，使您能够理解将要开发的示例业务线应用的体系结构。尽管如此，我还是强烈建议你买一本 Eric Evans 写的《领域驱动设计:在软件的核心处理复杂性》(Prentice Hall，2003)。这是第一本关于 DDD 的书，通常被称为“蓝皮书”这是一本学习领域驱动设计的每一个方面的书，它包含了第一个代表 DDD 的集体概念的官方介绍。

### 什么是领域驱动设计？

简而言之，领域驱动设计是一个用于设计和开发软件解决方案的框架，其中设计是围绕构成业务领域的实体构建的。DDD 提供了一套指导方针，帮助您的软件设计和实现符合客户的期望。

一旦您基于组成业务领域的核心实体构建了一个领域模型，那么您就可以添加对实体之间的关系的支持，以及它们应该如何与彼此以及系统的其余部分进行交互。你和一个业务分析师密切合作，如果你幸运的话，还有那些实际使用最终产品的人，以确保你交付的是用户所期望的。反馈是确定客户想要什么的一个很好的方法，所以你应该安排尽可能多的时间从客户那里得到反馈。

如果你遵循像 Scrum 这样的敏捷方法，正如你将在整本书中所做的那样，那么每个 sprint 的目的就是交付一组从用户故事中衍生出来的预定的特性。在每个 sprint 的结尾，你应该有一个工作的软件，它至少提供一个最终用户应该能够测试的特性，并且他们应该能够提供反馈。如果您部署了在每个 sprint 中交付的特性，并且收到了关于开发的直接反馈，那么您将会马上知道您是否开始偏离了与客户关于您正在开发的解决方案的需求的一致性。

为了开发特定业务领域的软件，您必须花时间学习该领域的当前过程、规则、约束和术语。这要求团队能够接触到业务分析师，或者更好的是，能够解释事情如何工作的建议系统的用户，特别是在与业务相关的方面，而不是软件开发方面。

### 在领域驱动设计之前

在 DDD 之前，业务分析师会收集要开发的应用的需求。然后，业务分析师将与架构师一起创建一套详细的软件设计文档和 UML 图。他们会在编写一行代码之前设计应用的每个方面。设计文档将作为创建项目时间表、生成所需资源的计划以及制定项目预算的一种方式。

随着时间的推移，很明显这种方法不是很有效。考虑到所有花费在创建设计文档上的时间，这些项目甚至很少考虑如何处理需求的变更。开发人员将依赖于“需求冻结”，这意味着，在某一点之后，需求将不会改变。这种方法的问题是，不仅需求会改变，而且它们通常会改变！

在编写任何代码之前从头到尾设计一个软件解决方案的实践可以比作设计和建造一所房子的过程。当你建造一所房子时，你和一个承包商一起工作，并且做出关于房子设计细节的所有决定。一旦计算机辅助设计(CAD)图纸完成，客户在设计方案上签字，承包商和施工团队将开始建造房屋。根据这个例子，假设承包商已经完成了房子的 40 %,客户请求修改，要求改变地基的布局。事实上，我不想成为面临这种困境的承包商！

这就清楚了，旧的软件设计和开发范例并不是真正的最佳设计风格，因为需求很可能在整个开发过程中发生变化。应用需求不仅仅在设计和开发期间经历变化。技术是不断变化的。您可能需要在任何给定的时刻更改软件解决方案的任何方面以响应技术的变化，例如发布新的 NoSQL 数据库存储引擎、基于云的文件系统，或者可能更新外部系统依赖项的实现。

通常，用户会认为他们需要一个特定的特性。然而，当他们收到最终的申请时，设计缺陷才暴露出来。在这些情况下，客户将不得不学习如何解决在项目开始时收集需求时做出的糟糕的设计决策。由于这个原因，领域驱动设计的倡导者使用敏捷开发实践在整个开发生命周期中与用户互动，以便在软件开发时获得反馈。

关键是变更是软件开发的一部分，领域驱动的设计(以及敏捷方法)引入了一套指导方针，促进开发灵活的和可扩展的软件，以最小化变更对需求的影响。

#### UML 地狱和陈旧的“需求文档”

统一建模语言提供了以预定义的图形格式交流软件开发设计工件的标准。我承认，到目前为止，我还没有描绘出 UML 的最佳图景。事实是，我喜欢 UML。当 UML 被过度使用时，我就有问题了。当 UML 开始获得面向对象软件设计和分析方法的牵引力时，许多人认为 UML 是优秀设计的“灵丹妙药”。结果，浪费了大量时间来制作图表，而这些图表在最初发布后从未被看过。

需求的变更，以及大量无用的设计图，在开发软件解决方案时会产生几个问题，其中之一就是陈旧的文档。

如果设计文档对项目至关重要，您更有可能更新它们。领域驱动设计促进了模型与实现的结合。您的代码应该清楚地表达您的模型的设计细节。

### 商业用户？那是谁？

谁是业务用户？他们是创建行业应用过程中最重要的人物。他们是一群必须处理与您的软件解决方案旨在解决的业务问题相关的问题的人。我可以有把握地说，对于我参与的项目来说，潜在用户的直接参与无疑是最好和最有回报的，我可以自由地向他们提问，并获得持续一致的反馈。最终的解决方案是根据企业用户的需求量身定制的。一个满意的客户是软件开发项目成功的最好指标。

事实是，您并不总是拥有与业务用户直接合作的优势。一般来说，你会和业务分析师一起工作。如果分析师对业务领域有清晰的了解，那么您仍然可以在您的开发项目中取得巨大的成功。关键的一点是，使用领域驱动的设计，整个团队需要在关于实体、过程、外部系统，以及最重要的，关于业务术语的通用语言方面保持一致，因为它涉及到业务领域问题空间的上下文。

#### 普遍存在的语言

当处理一个业务问题时，您可以要求五个不同的用户，五个不同的角色，来定义一个特定的领域实体，您可能会收到五个完全不同的答案。这是因为在一个用户角色的上下文中使用的某些术语和定义在另一个用户角色的上下文中使用时可能会完全不同。

这个概念也适用于开发团队。当作为一个团队学习和理解一个业务领域的来龙去脉时，重要的是要理解每个人与特定业务概念相关的方式会有差距，因此他们如何理解它。

解决方案包括作为一个团队工作来创建一种无处不在的语言，以覆盖业务术语的各种解释中的空白。一种无处不在的语言是一个字典，其中充满了与您正在创建领域模型的领域相关的业务术语。这将形成一种标准的、统一的语言，在引用领域术语时使用，这将防止混淆并促进领域模型的一致性。

## 领域驱动设计中的领域模型

什么是领域模型？域模型是一个松散耦合的组件，它包含了所有的实体、值对象、聚合根和域服务，这些都是用来描述您在其中创建软件解决方案的业务域的。领域模型是领域驱动设计范例的核心。领域模型是源代码，它使用您的通用语言中的业务术语，在代码中“建模”业务领域。

领域模型应该只封装与业务领域相关的构造。这种关注点的分离是非常重要的。当领域完全由业务实体建模时，它可以很容易地根据用户请求进行更改。当您确保您的领域模型与系统的其他部分松散耦合时，该模型可以很容易地在将来为解决新的业务问题而创建的软件解决方案中重用。

### 源代码是设计文档

在领域驱动的设计中，源代码代表领域模型，因此它充当文档。作为流程的一部分，您可以创建各种其他文档；然而，代码应该是清晰的，并且基于业务领域，这样设计就能说明一切。这是编写应用时单元测试发挥作用的另一个例子。例如，一个新的开发人员可以查看单元测试，以了解任何类应该如何使用——任何约束、参数值范围、预期的异常等等。

### 域实体

领域实体位于领域驱动设计的核心。在需求收集会议期间，您和您的团队应该与业务分析师或用户一起讨论与手头任务相关的业务流程。当你这样做的时候，你将会识别出名词，这些名词将会在你无处不在的语言中代表术语，并最终成为你的系统中的一个类。

领域实体对于它们的设计有特定的规则。实体应该代表业务领域中具有唯一身份的东西。例如，如果您正在处理一个订单系统，您将拥有一个名为`Order`的实体。该类应该只提供它负责的属性和方法。

域实体应该不知道它如何以及何时被保存到数据存储中。这是您在创建实体时经常需要忽略的准则。例如，如果您计划从数据源保存和检索一个实体，那么您通常会封装一个与数据库相关的 ID 属性。此 ID 属性与业务无关；但是，在保存和检索对象时，这是一种方便。请记住，就像任何其他设计方法一样，这些是指导方针，而不是法律。你必须决定什么最适合你。

域实体应该是代码的内聚单元，代表域中唯一的实体。一个实体应该知道如何验证它的状态，并且知道它与任何协作实体或值对象交互的方式。你的实体对系统的其他部分了解得越少越好。这种内聚性有助于创建可以在其他应用中使用的领域实体。

正如您在清单 [3-1](#FPar1) 中看到的，`Employee`实体简单到需要的程度。我们包括了一个唯一的标识符和描述员工的相关属性。总是试图让你的实体尽可能简单，只在必要的时候增加复杂性。

Listing 3-1\. Example of a Person Entity in C#

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`namespace Purchasing.Domain`

`{`

`public class Employee`

`{`

`public enum EmployeeRoleType`

`{`

`GeneralEmployee = 0,`

`TeamLeader = 1,`

`Supervisor = 2`

`}`

`private int _Id;`

`private string _FirstName;`

`private string _LastName;`

`private EmployeeRoleType _Role;`

`public int Id`

`{`

`get { return _Id; }`

`}`

`public string FirstName`

`{`

`get { return _FirstName; }`

`set { _FirstName = value; }`

`}`

`public string LastName`

`{`

`get { return _LastName; }`

`set { _LastName = value; }`

`}`

`public EmployeeRoleType Role`

`{`

`get { return _Role; }`

`set { _Role = value; }`

`}`

`public Employee(int id)`

`{`

`_Id = id;`

`}`

`}`

`}`

### 域聚合根

在源代码中对领域建模的最困难的方面之一是有效地对其他实体的引用进行建模。在大多数域中，您会发现一个包含私有字段的实体，该私有字段表示子实体或值对象的集合。如何对这样的引用建模，以便对任何被引用实体的状态的修改能够正确地传播到整个引用链中？这就是聚合根发挥作用的地方。

领域驱动设计环境中的集合是为了建模数据修改而绑定在一起的相关对象的集合。每个集合都有一个根和一个边界。根实体是聚合中唯一可以被聚合边界之外的对象引用的对象。当然，在聚合边界内部，实体可以相互引用。否则，就没有办法对复杂的关联进行建模。

以前面提到的`Order`实体为例。这个实体可能有一个`OrderItem`实体对象的集合。每个`OrderItem`实体可以有一个关联的`Product`实体，依此类推。在这个例子中，`Order`实体充当聚合根。`Order`实体是聚合边界中唯一的实体，其中边界外的对象可以保存引用，如属性或字段。

聚集根实体可以暂时传递对要在单个操作中使用的子实体的引用，其中调用对象可能不会保留该引用。聚合根的标识必须是全局的，而整个边界上的实体应该具有本地标识。根实体负责检查整个聚合边界的所有不变量或约束。

聚合根应该是数据库查询可以检索的唯一实体。聚集的所有其他实体必须通过跟随聚集的关联来加载。最后，如果对集合中的对象进行了任何修改，并且提交了修改，则必须满足所有的不变量或约束。只要聚合根控制对聚合边界中对象的所有访问，那么就有一个数据更改点，并且您可以确保所有不变量都得到实施。

在清单 [3-2](#FPar2) 中，有一个`Order`聚合根实体，它保存了对一组`LineItem`实体的引用。访问关于`LineItem`对象集合的任何信息的唯一方式是通过聚合根`Order`实体对象。

Listing 3-2\. Aggregate Root That Represents an Order Placed by a Customer

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`namespace Purchasing.Domain`

`{`

`/// <summary>`

`/// Represents a customer's order`

`/// </summary>`

`public class Order`

`{`

`#region "private members"`

`private int _Id;`

`private IList<LineItem> _LineItems;`

`private double _OrderTotal;`

`#endregion`

`#region "public properties"`

`public int Id`

`{`

`get { return _Id; }`

`}`

`public int LineItemCount`

`{`

`get`

`{`

`return _LineItems.Count();`

`}`

`}`

`#endregion`

`#region "constructor"`

`public Order()`

`{`

`_LineItems = new List<LineItem>();`

`}`

`public Order(int id)`

`{`

`_Id = id;`

`_LineItems = new List<LineItem>();`

`}`

`#endregion`

`#region "public methods"`

`public void AddLineItem(LineItem lineItem)`

`{`

`_LineItems.Add(lineItem);`

`}`

`public double CalculateOrderTotal()`

`{`

`foreach (var lineItem in _LineItems)`

`{`

`_OrderTotal += lineItem.Price;`

`}`

`return _OrderTotal;`

`}`

`#endregion`

`}`

`}`

### 域值对象

域模型中的值对象是类似于实体的对象；区别在于实体有唯一的标识，而值对象没有。一个众所周知的值对象的例子是表示客户地址的类。`Customer`对象显然是一个实体，因为它有一个身份和生命周期，这在域中被跟踪。然而，`Address`对象可以描述任何客户、个人或企业的地址。一个`Address`值对象将具有街道、房屋号码、邮政编码、州、国家等属性。当对值对象建模时，您关心属性。值对象应该是不可变的，以便共享引用和值的不同实例是安全的。

当你使一个值对象不可变时，意味着你没有改变对它的引用。如果需要进行修改，必须用值对象的新实例替换引用。其他一些很好的值对象的例子是在您的应用中使用的列表，比如一个绑定到一组`State`值对象的下拉列表，它允许用户选择一个状态。`State`值对象的集合可以与系统中需要呈现状态列表的任何部分共享。允许用户选择颜色的下拉框是另一个创建值对象的好例子(在这个例子中，类是`Color`)。

### 域服务

通常，有些操作属于这个领域；然而，它们与任何特定的实体都不匹配。您将这些操作创建为属于称为域服务的类的方法。域服务通常用于编排涉及一个或多个实体的操作。这些服务对象包含表示操作的方法，这些操作与多个域对象一起完成模型中指定的活动。

当涉及到域服务时，你必须小心不要偷懒。例如，不是将活动标识为实体或值对象的行为或责任，而是简单地创建一个服务。同时，服务通过提供一个地方来实现属于域但不属于任何特定实体或值对象的操作来帮助您。如果你只是因为找不到其他地方来放置功能，而将一个方法添加到一个实体中，你会使实体变得复杂，实体的职责也会变得模糊。最好将这种类型的功能建模为域服务，以保护域模型的完整性。

域服务必须是无状态的。在使用服务实例之前，如何使用域服务实例并不重要。该服务将使用来自其运营所在实体的数据；但是，它本身不包含任何与状态相关的属性。这降低了复杂性，因为不再需要担心服务实例是何时创建的，或者执行了哪些操作以及执行的顺序。

领域服务的方法应该使用领域模型的通用语言来命名。我们通常用服务的后缀来命名我们的域服务。域名服务名的几个例子是`PurchasingService`和`ReportService`。

在清单 [3-3](#FPar3) 中，您会看到`OrderService`，这是一个域服务，它与一个`Order`聚合根`Order`实体和一个`IOrderRepository`实例一起保存`Order`并生成一个`Invoice`实体。(我们将在下一章讨论`Repository`模式。)

Listing 3-3\. `OrderService.cs` Domain Service

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`using Purchasing.Domain.Service.Interfaces;`

`namespace Purchasing.Domain.Service`

`{`

`public class OrderService : IOrderService`

`{`

`private IOrderRepository _OrderRepository;`

`public OrderService(IOrderRepository orderRepository)`

`{`

`_OrderRepository = orderRepository;`

`}`

`public Invoice CreateInvoice(Order order)`

`{`

`_OrderRepository.AddOrder(order);`

`_OrderRepository.Commit();`

`var invoice =`

`new Invoice { OrderTotal = order.CalculateOrderTotal() };`

`return invoice;`

`}`

`}`

`}`

### 域事件

域事件是域对象，表示对域重要的事件的发生。域事件是包含表达已发生事件所需的所有属性的对象。

域事件非常强大，因为当发生系统需要知道的事件时，它们提供了一种通知系统任何部分的方式。此外，根据您的事件调度和订阅系统，事件可以超越逻辑层、物理层等等。在遵守聚合根持久性规则时，事件也提供了帮助。我们将在下一章讨论事件发布和订阅的具体设计模式。

### CQRS:命令查询责任分离

命令查询责任分离(CQRS)是一种设计理念，其中操作分为两种类型:更改域实体数据的命令和从域中读取数据的查询相关操作。这个想法是基于这两种基本类型的操作来建模你的类。您最终会得到只包含命令的服务和只包含查询的服务。本质上，留给您的是所有命令的抽象和所有查询的抽象。在某些情况下，清晰的定义可以提高领域模型的清晰度。我们不会在本书中使用 CQRS；但是，重要的是要清楚这个概念，以供参考。

## 摘要

领域驱动设计不是“灵丹妙药”尽管如此，一旦你投入了有效使用 DDD 所需的时间，你和你的团队将会创造出与用户需求相一致的软件解决方案。您将创建松散耦合的组件，当创建新的应用时，这些组件可以在整个企业中使用。

尽管使用 DDD 有诸多优势，但也有一些合理的顾虑，包括以下几点:

*   攀登陡峭的学习曲线的需要。
*   团队成员对 DDD 的绝对忠诚。
*   团队成员愿意投入必要的时间来学习 DDD 的原则。
*   为了有效地使用 DDD，整个团队必须共享对业务领域的理解。随着设计的进展，会提出一些问题，并根据这些问题的答案进行必要的修改。团队必须能够接触到对业务领域有深入了解的人，以便在整个项目生命周期中验证所做的假设。

如您所见，使用 DDD 可以学到很多东西。我们相信这一章已经提供了足够的信息来激起你继续学习和实践这种令人敬畏的设计方法的欲望。然而，就像生活中的大多数其他事情一样，你学习 DDD 的唯一方法是实践它。我们希望我们已经为您提供了足够的背景知识，以便您在本书的剩余部分中理解设计决策背后的原因。

接下来，我们将讨论现代应用中使用的设计模式，这些模式与领域驱动的设计密切相关。